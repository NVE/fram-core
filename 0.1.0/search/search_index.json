{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Macro Rendering Error","text":"<p>File: <code>index.md</code></p> <p>UndefinedError: 'HL' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/home/runner/work/fram-core/fram-core/.venv/lib/python3.12/site-packages/mkdocs_macros/plugin.py\", line 703, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/work/fram-core/fram-core/.venv/lib/python3.12/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/home/runner/work/fram-core/fram-core/.venv/lib/python3.12/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 26, in top-level template code\njinja2.exceptions.UndefinedError: 'HL' is undefined\n\n</code></pre>"},{"location":"reference/","title":"Code Reference","text":""},{"location":"reference/#framcore","title":"<code>framcore</code>","text":""},{"location":"reference/#framcore.check_type","title":"<code>check_type(value: object, expected: type | tuple[type], caller: Callable | None = None) -&gt; None</code>","text":"<p>Check a value matches expected type(s).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>value being checked.</p> required <code>expected</code> <code>type | tuple[type]</code> <p>Expected types.</p> required <code>caller</code> <code>Callable</code> <p>The origin of the check.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>When value does not match expected types.</p> Source code in <code>framcore/Base.py</code> <pre><code>def check_type(value: object, expected: type | tuple[type], caller: Callable | None = None) -&gt; None:\n    \"\"\"\n    Check a value matches expected type(s).\n\n    Args:\n        value (object): value being checked.\n        expected (type | tuple[type]): Expected types.\n        caller (Callable): The origin of the check.\n\n    Raises:\n        TypeError: When value does not match expected types.\n\n    \"\"\"\n    if not isinstance(value, expected):\n        message = f\"{expected}, got {type(value).__name__}\"\n        message = \"Expected \" + message if caller is None else f\"{caller} expected \" + message\n        raise TypeError(message)\n</code></pre>"},{"location":"reference/#framcore.Base","title":"<code>Base</code>","text":""},{"location":"reference/#framcore.Base.Base","title":"<code>Base</code>","text":"<p>Core base class to share methods.</p> Source code in <code>framcore/Base.py</code> <pre><code>class Base:\n    \"\"\"Core base class to share methods.\"\"\"\n\n    def _check_type(self, value, class_or_tuple) -&gt; None:  # noqa: ANN001\n        check_type(value, class_or_tuple, caller=self)\n\n    def _ensure_float(self, value: object) -&gt; float:\n        with contextlib.suppress(Exception):\n            return float(value)\n        message = f\"Unable to convert {value} to float.\"\n        raise ValueError(message)\n\n    def _check_int(self, value: int, lower_bound: int | None, upper_bound: int | None) -&gt; None:\n        if lower_bound is not None and value &lt; lower_bound:\n            message = f\"Value {value} is less than lower_bound {lower_bound}.\"\n            raise ValueError(message)\n        if upper_bound is not None and value &gt; upper_bound:\n            message = f\"Value {value} is greater than upper_bound {upper_bound}.\"\n            raise ValueError(message)\n\n    def _check_float(self, value: float, lower_bound: float | None, upper_bound: float | None) -&gt; None:\n        if lower_bound is not None and value &lt; lower_bound:\n            message = f\"Value {value} is less than lower_bound {lower_bound}.\"\n            raise ValueError(message)\n        if upper_bound is not None and value &gt; upper_bound:\n            message = f\"Value {value} is greater than upper_bound {upper_bound}.\"\n            raise ValueError(message)\n\n    def _report_errors(self, errors: set[str]) -&gt; None:\n        if errors:\n            n = len(errors)\n            s = \"s\" if n &gt; 1 else \"\"\n            error_str = \"\\n\".join(errors)\n            message = f\"Found {n} error{s}:\\n{error_str}\"\n            raise RuntimeError(message)\n\n    def send_event(self, event_type: str, **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"All events in core should use this.\"\"\"\n        send_event(sender=self, event_type=event_type, **kwargs)\n\n    def send_warning_event(self, message: str) -&gt; None:\n        \"\"\"Use this to send warning event.\"\"\"\n        send_warning_event(sender=self, message=message)\n\n    def send_error_event(self, message: str, exception_type_name: str, traceback: str) -&gt; None:\n        \"\"\"Use this to send error event.\"\"\"\n        send_error_event(sender=self, message=message, exception_type_name=exception_type_name, traceback=traceback)\n\n    def send_info_event(self, message: str) -&gt; None:\n        \"\"\"Use this to send info event.\"\"\"\n        send_info_event(sender=self, message=message)\n\n    def send_debug_event(self, message: str) -&gt; None:\n        \"\"\"Use this to send debug event.\"\"\"\n        send_debug_event(sender=self, message=message)\n\n    def get_fingerprint_default(\n        self,\n        refs: dict[str, str] | None = None,\n        excludes: set[str] | None = None,\n    ) -&gt; Fingerprint:\n        \"\"\"\n        Generate a Fingerprint for the object, optionally including references and excluding specified properties.\n\n        Parameters\n        ----------\n        refs : dict[str, str] | None, optional\n            Dictionary mapping property names to reference keys to include as references in the fingerprint.\n        excludes : set[str] | None, optional\n            Set of property names to exclude from the fingerprint.\n\n        Returns\n        -------\n        Fingerprint\n            The generated fingerprint for the object.\n\n        \"\"\"\n        fingerprint = Fingerprint(source=self)\n\n        if refs:\n            for ref_prop, ref_key in refs.items():\n                if ref_key is not None:\n                    fingerprint.add_ref(ref_prop, ref_key)\n\n        default_excludes = {\"_parent\"}\n\n        for prop_name, prop_value in self.__dict__.items():\n            if callable(prop_value) or (refs and prop_name in refs) or (excludes and prop_name in excludes) or prop_name in default_excludes:\n                continue\n\n            if prop_value is None:\n                continue\n\n            fingerprint.add(prop_name, prop_value)\n\n        return fingerprint\n\n    def _get_property_name(self, property_reference) -&gt; str | None:  # noqa: ANN001\n        for name, value in inspect.getmembers(self):\n            if value is property_reference:\n                return name\n        return None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Display type and non-None fields.\"\"\"\n        type_name = type(self).__name__\n        value_fields = []\n        for k, v in vars(self).items():\n            display_value = self._get_attr_str(k, v)\n            if display_value is not None:\n                value_fields.append(f\"{k}={display_value}\")\n        value_fields = \", \".join(value_fields)\n        return f\"{type_name}({value_fields})\"\n\n    def _get_attr_str(self, key: str, value: object) -&gt; str | None:\n        if value is None:\n            return None\n        if isinstance(value, int | float | str | bool):\n            return value\n        try:\n            return value._get_attr_str()  # noqa: SLF001\n        except Exception:\n            pass\n        return type(value).__name__\n</code></pre>"},{"location":"reference/#framcore.Base.Base.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Display type and non-None fields.</p> Source code in <code>framcore/Base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Display type and non-None fields.\"\"\"\n    type_name = type(self).__name__\n    value_fields = []\n    for k, v in vars(self).items():\n        display_value = self._get_attr_str(k, v)\n        if display_value is not None:\n            value_fields.append(f\"{k}={display_value}\")\n    value_fields = \", \".join(value_fields)\n    return f\"{type_name}({value_fields})\"\n</code></pre>"},{"location":"reference/#framcore.Base.Base.get_fingerprint_default","title":"<code>get_fingerprint_default(refs: dict[str, str] | None = None, excludes: set[str] | None = None) -&gt; Fingerprint</code>","text":"<p>Generate a Fingerprint for the object, optionally including references and excluding specified properties.</p>"},{"location":"reference/#framcore.Base.Base.get_fingerprint_default--parameters","title":"Parameters","text":"<p>refs : dict[str, str] | None, optional     Dictionary mapping property names to reference keys to include as references in the fingerprint. excludes : set[str] | None, optional     Set of property names to exclude from the fingerprint.</p>"},{"location":"reference/#framcore.Base.Base.get_fingerprint_default--returns","title":"Returns","text":"<p>Fingerprint     The generated fingerprint for the object.</p> Source code in <code>framcore/Base.py</code> <pre><code>def get_fingerprint_default(\n    self,\n    refs: dict[str, str] | None = None,\n    excludes: set[str] | None = None,\n) -&gt; Fingerprint:\n    \"\"\"\n    Generate a Fingerprint for the object, optionally including references and excluding specified properties.\n\n    Parameters\n    ----------\n    refs : dict[str, str] | None, optional\n        Dictionary mapping property names to reference keys to include as references in the fingerprint.\n    excludes : set[str] | None, optional\n        Set of property names to exclude from the fingerprint.\n\n    Returns\n    -------\n    Fingerprint\n        The generated fingerprint for the object.\n\n    \"\"\"\n    fingerprint = Fingerprint(source=self)\n\n    if refs:\n        for ref_prop, ref_key in refs.items():\n            if ref_key is not None:\n                fingerprint.add_ref(ref_prop, ref_key)\n\n    default_excludes = {\"_parent\"}\n\n    for prop_name, prop_value in self.__dict__.items():\n        if callable(prop_value) or (refs and prop_name in refs) or (excludes and prop_name in excludes) or prop_name in default_excludes:\n            continue\n\n        if prop_value is None:\n            continue\n\n        fingerprint.add(prop_name, prop_value)\n\n    return fingerprint\n</code></pre>"},{"location":"reference/#framcore.Base.Base.send_debug_event","title":"<code>send_debug_event(message: str) -&gt; None</code>","text":"<p>Use this to send debug event.</p> Source code in <code>framcore/Base.py</code> <pre><code>def send_debug_event(self, message: str) -&gt; None:\n    \"\"\"Use this to send debug event.\"\"\"\n    send_debug_event(sender=self, message=message)\n</code></pre>"},{"location":"reference/#framcore.Base.Base.send_error_event","title":"<code>send_error_event(message: str, exception_type_name: str, traceback: str) -&gt; None</code>","text":"<p>Use this to send error event.</p> Source code in <code>framcore/Base.py</code> <pre><code>def send_error_event(self, message: str, exception_type_name: str, traceback: str) -&gt; None:\n    \"\"\"Use this to send error event.\"\"\"\n    send_error_event(sender=self, message=message, exception_type_name=exception_type_name, traceback=traceback)\n</code></pre>"},{"location":"reference/#framcore.Base.Base.send_event","title":"<code>send_event(event_type: str, **kwargs: dict[str, Any]) -&gt; None</code>","text":"<p>All events in core should use this.</p> Source code in <code>framcore/Base.py</code> <pre><code>def send_event(self, event_type: str, **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"All events in core should use this.\"\"\"\n    send_event(sender=self, event_type=event_type, **kwargs)\n</code></pre>"},{"location":"reference/#framcore.Base.Base.send_info_event","title":"<code>send_info_event(message: str) -&gt; None</code>","text":"<p>Use this to send info event.</p> Source code in <code>framcore/Base.py</code> <pre><code>def send_info_event(self, message: str) -&gt; None:\n    \"\"\"Use this to send info event.\"\"\"\n    send_info_event(sender=self, message=message)\n</code></pre>"},{"location":"reference/#framcore.Base.Base.send_warning_event","title":"<code>send_warning_event(message: str) -&gt; None</code>","text":"<p>Use this to send warning event.</p> Source code in <code>framcore/Base.py</code> <pre><code>def send_warning_event(self, message: str) -&gt; None:\n    \"\"\"Use this to send warning event.\"\"\"\n    send_warning_event(sender=self, message=message)\n</code></pre>"},{"location":"reference/#framcore.Base.check_type","title":"<code>check_type(value: object, expected: type | tuple[type], caller: Callable | None = None) -&gt; None</code>","text":"<p>Check a value matches expected type(s).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>value being checked.</p> required <code>expected</code> <code>type | tuple[type]</code> <p>Expected types.</p> required <code>caller</code> <code>Callable</code> <p>The origin of the check.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>When value does not match expected types.</p> Source code in <code>framcore/Base.py</code> <pre><code>def check_type(value: object, expected: type | tuple[type], caller: Callable | None = None) -&gt; None:\n    \"\"\"\n    Check a value matches expected type(s).\n\n    Args:\n        value (object): value being checked.\n        expected (type | tuple[type]): Expected types.\n        caller (Callable): The origin of the check.\n\n    Raises:\n        TypeError: When value does not match expected types.\n\n    \"\"\"\n    if not isinstance(value, expected):\n        message = f\"{expected}, got {type(value).__name__}\"\n        message = \"Expected \" + message if caller is None else f\"{caller} expected \" + message\n        raise TypeError(message)\n</code></pre>"},{"location":"reference/#framcore.Model","title":"<code>Model</code>","text":""},{"location":"reference/#framcore.Model.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Base</code></p> <p>Model stores the representation of the energy system with Components, TimeVectors, Expression, and the Aggregators applied to the Model.</p> <ul> <li>Components describe the main elements in the energy system. Can have additional Attributes.</li> <li>TimeVector and Curve hold the time series data.</li> <li>Expressions for data manipulation of TimeVectors and Curves. Can be queried.</li> <li>Aggregators handle aggregation and disaggregation of Components. Aggregators are added to Model when used (Aggregator.aggregate(model)), and can be undone in LIFO order with disaggregate().</li> </ul> <p>Methods:</p> Name Description <code>get_data</code> <p>Get dict of Components, Expressions, TimeVectors and Curves stored in the Model. Can be modified.</p> <code>disaggregate</code> <p>Undo all aggregations applied to Model in LIFO order.</p> <code>get_content_counts</code> <p>Return number of objects stored in model organized into concepts and types.</p> Source code in <code>framcore/Model.py</code> <pre><code>class Model(Base):\n    \"\"\"\n    Model stores the representation of the energy system with Components, TimeVectors, Expression, and the Aggregators applied to the Model.\n\n    - Components describe the main elements in the energy system. Can have additional Attributes.\n    - TimeVector and Curve hold the time series data.\n    - Expressions for data manipulation of TimeVectors and Curves. Can be queried.\n    - Aggregators handle aggregation and disaggregation of Components. Aggregators are added to Model when used (Aggregator.aggregate(model)),\n    and can be undone in LIFO order with disaggregate().\n\n    Methods:\n        get_data(): Get dict of Components, Expressions, TimeVectors and Curves stored in the Model. Can be modified.\n        disaggregate(): Undo all aggregations applied to Model in LIFO order.\n        get_content_counts(): Return number of objects stored in model organized into concepts and types.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Create a new model instance with empty data and no aggregators.\"\"\"\n        self._data = ModelDict()\n        self._aggregators: list[Aggregator] = []\n\n    def get_data(self) -&gt; ModelDict:\n        \"\"\"Get dict of Components, Expressions, TimeVectors and Curves stored in the Model. Can be modified.\"\"\"\n        return self._data\n\n    def disaggregate(self) -&gt; None:\n        \"\"\"Undo all aggregations applied to Model in LIFO order.\"\"\"\n        while self._aggregators:\n            aggregator = self._aggregators.pop(-1)  # last item\n            aggregator.disaggregate(self)\n\n    def get_content_counts(self) -&gt; dict[str, Counter]:\n        \"\"\"Return number of objects stored in model organized into concepts and types.\"\"\"\n        data_values = self.get_data().values()\n        counts = {\n            \"components\": Counter(),\n            \"timevectors\": Counter(),\n            \"curves\": Counter(),\n            \"expressions\": Counter(),\n        }\n        for obj in data_values:\n            if isinstance(obj, Component):\n                key = \"components\"\n            elif isinstance(obj, TimeVector):\n                key = \"timevectors\"\n            elif isinstance(obj, Curve):\n                key = \"curves\"\n            elif isinstance(obj, Expr):\n                key = \"expressions\"\n            else:\n                key = \"unexpected\"\n                if key not in counts:\n                    counts[key] = Counter()\n            counts[key][type(obj).__name__] += 1\n\n        assert len(data_values) == sum(c.total() for c in counts.values())\n\n        counts[\"aggregators\"] = Counter()\n        for a in self._aggregators:\n            counts[\"aggregators\"][type(a).__name__] += 1\n\n        return counts\n</code></pre>"},{"location":"reference/#framcore.Model.Model.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Create a new model instance with empty data and no aggregators.</p> Source code in <code>framcore/Model.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create a new model instance with empty data and no aggregators.\"\"\"\n    self._data = ModelDict()\n    self._aggregators: list[Aggregator] = []\n</code></pre>"},{"location":"reference/#framcore.Model.Model.disaggregate","title":"<code>disaggregate() -&gt; None</code>","text":"<p>Undo all aggregations applied to Model in LIFO order.</p> Source code in <code>framcore/Model.py</code> <pre><code>def disaggregate(self) -&gt; None:\n    \"\"\"Undo all aggregations applied to Model in LIFO order.\"\"\"\n    while self._aggregators:\n        aggregator = self._aggregators.pop(-1)  # last item\n        aggregator.disaggregate(self)\n</code></pre>"},{"location":"reference/#framcore.Model.Model.get_content_counts","title":"<code>get_content_counts() -&gt; dict[str, Counter]</code>","text":"<p>Return number of objects stored in model organized into concepts and types.</p> Source code in <code>framcore/Model.py</code> <pre><code>def get_content_counts(self) -&gt; dict[str, Counter]:\n    \"\"\"Return number of objects stored in model organized into concepts and types.\"\"\"\n    data_values = self.get_data().values()\n    counts = {\n        \"components\": Counter(),\n        \"timevectors\": Counter(),\n        \"curves\": Counter(),\n        \"expressions\": Counter(),\n    }\n    for obj in data_values:\n        if isinstance(obj, Component):\n            key = \"components\"\n        elif isinstance(obj, TimeVector):\n            key = \"timevectors\"\n        elif isinstance(obj, Curve):\n            key = \"curves\"\n        elif isinstance(obj, Expr):\n            key = \"expressions\"\n        else:\n            key = \"unexpected\"\n            if key not in counts:\n                counts[key] = Counter()\n        counts[key][type(obj).__name__] += 1\n\n    assert len(data_values) == sum(c.total() for c in counts.values())\n\n    counts[\"aggregators\"] = Counter()\n    for a in self._aggregators:\n        counts[\"aggregators\"][type(a).__name__] += 1\n\n    return counts\n</code></pre>"},{"location":"reference/#framcore.Model.Model.get_data","title":"<code>get_data() -&gt; ModelDict</code>","text":"<p>Get dict of Components, Expressions, TimeVectors and Curves stored in the Model. Can be modified.</p> Source code in <code>framcore/Model.py</code> <pre><code>def get_data(self) -&gt; ModelDict:\n    \"\"\"Get dict of Components, Expressions, TimeVectors and Curves stored in the Model. Can be modified.\"\"\"\n    return self._data\n</code></pre>"},{"location":"reference/#framcore.Model.ModelDict","title":"<code>ModelDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>Dict storing only values of type Component | Expr | TimeVector | Curve.</p> Source code in <code>framcore/Model.py</code> <pre><code>class ModelDict(dict):\n    \"\"\"Dict storing only values of type Component | Expr | TimeVector | Curve.\"\"\"\n\n    def __setitem__(self, key: str, value: Component | Expr | TimeVector | Curve) -&gt; None:\n        \"\"\"Set item with type checking.\"\"\"\n        if not isinstance(key, str):\n            message = f\"Expected str for key {key}, got {type(key).__name__}\"\n            raise TypeError(message)\n        if not isinstance(value, Component | Expr | TimeVector | Curve):\n            message = f\"Expected Component | Expr | TimeVector | Curve for key {key}, got {type(value).__name__}\"\n            raise TypeError(message)\n        return super().__setitem__(key, value)\n</code></pre>"},{"location":"reference/#framcore.Model.ModelDict.__setitem__","title":"<code>__setitem__(key: str, value: Component | Expr | TimeVector | Curve) -&gt; None</code>","text":"<p>Set item with type checking.</p> Source code in <code>framcore/Model.py</code> <pre><code>def __setitem__(self, key: str, value: Component | Expr | TimeVector | Curve) -&gt; None:\n    \"\"\"Set item with type checking.\"\"\"\n    if not isinstance(key, str):\n        message = f\"Expected str for key {key}, got {type(key).__name__}\"\n        raise TypeError(message)\n    if not isinstance(value, Component | Expr | TimeVector | Curve):\n        message = f\"Expected Component | Expr | TimeVector | Curve for key {key}, got {type(value).__name__}\"\n        raise TypeError(message)\n    return super().__setitem__(key, value)\n</code></pre>"},{"location":"reference/#framcore.aggregators","title":"<code>aggregators</code>","text":""},{"location":"reference/#framcore.aggregators.SolarAggregator","title":"<code>SolarAggregator</code>","text":"<p>               Bases: <code>_WindSolarAggregator</code></p> <p>Aggregate Solar components into groups based on their power nodes.</p> <p>Aggregation steps (self._aggregate):</p> <ol> <li>Group components based on their power nodes (self._group_by_power_node):</li> <li>Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):<ul> <li>Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.</li> <li>Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).</li> <li>TODO: Add support for additional weighting methods (e.g. production instead of capacity).</li> <li>Production is aggregated as the sum of production levels with weighted profiles. 2a. Make new hydro module and delete original components from model data.</li> </ul> </li> <li>Add mapping from detailed to aggregated components to self._aggregation_map.</li> </ol> <p>Disaggregation steps (self._disaggregate):</p> <ol> <li>Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.</li> <li>Distribute production from aggregated components back to the original components:<ul> <li>Results are weighted based on the weighting method (now ony max_capacity supported).</li> </ul> </li> <li>Delete aggregated components from the model.</li> </ol> <p>See Aggregator for general design notes and rules to follow when using Aggregators.</p> <p>Attributes:</p> Name Type Description <code>_data_dim</code> <code>SinglePeriodTimeIndex | None</code> <p>Data dimension for eager evaluation.</p> <code>_scen_dim</code> <code>FixedFrequencyTimeIndex | None</code> <p>Scenario dimension for eager evaluation.</p> <code>_grouped_components</code> <code>dict[str, set[str]]</code> <p>Mapping of aggregated components to their detailed components.  agg to detailed</p> <p>Parent Attributes (see framcore.aggregators.Aggregator):</p> <pre><code>_is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n_original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n_aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n</code></pre> Source code in <code>framcore/aggregators/WindSolarAggregator.py</code> <pre><code>class SolarAggregator(_WindSolarAggregator):\n    \"\"\"\n    Aggregate Solar components into groups based on their power nodes.\n\n    Aggregation steps (self._aggregate):\n\n    1. Group components based on their power nodes (self._group_by_power_node):\n    2. Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):\n        - Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.\n        - Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).\n        - TODO: Add support for additional weighting methods (e.g. production instead of capacity).\n        - Production is aggregated as the sum of production levels with weighted profiles.\n    2a. Make new hydro module and delete original components from model data.\n    3. Add mapping from detailed to aggregated components to self._aggregation_map.\n\n\n    Disaggregation steps (self._disaggregate):\n\n    1. Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.\n    2. Distribute production from aggregated components back to the original components:\n        - Results are weighted based on the weighting method (now ony max_capacity supported).\n    3. Delete aggregated components from the model.\n\n\n    See Aggregator for general design notes and rules to follow when using Aggregators.\n\n    Attributes:\n        _data_dim (SinglePeriodTimeIndex | None): Data dimension for eager evaluation.\n        _scen_dim (FixedFrequencyTimeIndex | None): Scenario dimension for eager evaluation.\n        _grouped_components (dict[str, set[str]]): Mapping of aggregated components to their detailed components.  agg to detailed\n\n\n    Parent Attributes (see framcore.aggregators.Aggregator):\n\n        _is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n        _original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n        _aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n\n    \"\"\"\n\n    _component_type = Solar\n</code></pre>"},{"location":"reference/#framcore.aggregators.WindAggregator","title":"<code>WindAggregator</code>","text":"<p>               Bases: <code>_WindSolarAggregator</code></p> <p>Aggregate Wind components into groups based on their power nodes.</p> <p>Aggregation steps (self._aggregate):</p> <ol> <li>Group components based on their power nodes (self._group_by_power_node):</li> <li>Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):<ul> <li>Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.</li> <li>Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).</li> <li>TODO: Add support for additional weighting methods (e.g. production instead of capacity).</li> <li>Production is aggregated as the sum of production levels with weighted profiles. 2a. Make new hydro module and delete original components from model data.</li> </ul> </li> <li>Add mapping from detailed to aggregated components to self._aggregation_map.</li> </ol> <p>Disaggregation steps (self._disaggregate):</p> <ol> <li>Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.</li> <li>Distribute production from aggregated components back to the original components:<ul> <li>Results are weighted based on the weighting method (now ony max_capacity supported).</li> </ul> </li> <li>Delete aggregated components from the model.</li> </ol> <p>See Aggregator for general design notes and rules to follow when using Aggregators.</p> <p>Attributes:</p> Name Type Description <code>_data_dim</code> <code>SinglePeriodTimeIndex | None</code> <p>Data dimension for eager evaluation.</p> <code>_scen_dim</code> <code>FixedFrequencyTimeIndex | None</code> <p>Scenario dimension for eager evaluation.</p> <code>_grouped_components</code> <code>dict[str, set[str]]</code> <p>Mapping of aggregated components to their detailed components.  agg to detailed</p> <p>Parent Attributes (see framcore.aggregators.Aggregator):</p> <pre><code>_is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n_original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n_aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n</code></pre> Source code in <code>framcore/aggregators/WindSolarAggregator.py</code> <pre><code>class WindAggregator(_WindSolarAggregator):\n    \"\"\"\n    Aggregate Wind components into groups based on their power nodes.\n\n    Aggregation steps (self._aggregate):\n\n    1. Group components based on their power nodes (self._group_by_power_node):\n    2. Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):\n        - Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.\n        - Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).\n        - TODO: Add support for additional weighting methods (e.g. production instead of capacity).\n        - Production is aggregated as the sum of production levels with weighted profiles.\n    2a. Make new hydro module and delete original components from model data.\n    3. Add mapping from detailed to aggregated components to self._aggregation_map.\n\n\n    Disaggregation steps (self._disaggregate):\n\n    1. Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.\n    2. Distribute production from aggregated components back to the original components:\n        - Results are weighted based on the weighting method (now ony max_capacity supported).\n    3. Delete aggregated components from the model.\n\n\n    See Aggregator for general design notes and rules to follow when using Aggregators.\n\n    Attributes:\n        _data_dim (SinglePeriodTimeIndex | None): Data dimension for eager evaluation.\n        _scen_dim (FixedFrequencyTimeIndex | None): Scenario dimension for eager evaluation.\n        _grouped_components (dict[str, set[str]]): Mapping of aggregated components to their detailed components.  agg to detailed\n\n\n    Parent Attributes (see framcore.aggregators.Aggregator):\n\n        _is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n        _original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n        _aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n\n    \"\"\"\n\n    _component_type = Wind\n</code></pre>"},{"location":"reference/#framcore.aggregators.Aggregator","title":"<code>Aggregator</code>","text":""},{"location":"reference/#framcore.aggregators.Aggregator.Aggregator","title":"<code>Aggregator</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Aggregator interface class.</p> <p>Aggregators handles aggregation and disaggregation of Components. - The general approach for aggregation is to group Components, aggregate Components in the same group to (a) new Component(s), delete the detailed Components, and add the mapping to self._aggregation_map. - The general approach for disaggregation is to restore the detailed Components, move results from aggregated Components to detailed Components, and delete the aggregated Components.</p> <p>Concrete Aggregators must implement the abstract methods _aggregate() and _disaggregate().</p> <p>Some rules for using Aggregators: 1. Disaggragate can only be called after aggregate has been called. 2. Not allowed to call aggregate twice. Must call disaggregate before aggregate can be called again. 3. Aggregators are stored in Model when aggregate is called. Disaggregate by calling Model.disaggregate(),      which will disaggregate all Aggregators in LIFO order. 4. At the moment we allow changes to the aggregated Components, which is ignored during disaggregation. TODO: Handle this 5. It is recommended to only use the same Aggregator type once on the same components of a Model.     If you want to go from one aggregation level to another, it is better to use Model.disaggregate first and then aggregate again.     This is to keep the logic simple and avoid complex expressions.</p> <p>Some design notes: - Levels and profiles are aggregated separately and then combined into attributes. - We have chosen to eagerly evaluate weights for aggregation (weighted averages) and disaggregation of levels and profiles.     This approach supports any form of aggregation by varying the weights, and complex weights can be created by eagerly evaluating     expressions and using the result to compute those weights. - This is a balance between eagerly evaluating everything and setting up complex expressions.     Eagerly evaluating everything would require setting up new TimeVectors after evaluation, which is not ideal.     While setting up complex expressions gives expressions that are harder to work with and slower to query from. - This trade-off simplifies adding logic that recognises if result expressions come from aggregations or disaggregations.     When aggregating or disaggregating these, we can go back to the original results rather than setting up complex expressions     that for examples aggregates the disaggregated results.</p> Source code in <code>framcore/aggregators/Aggregator.py</code> <pre><code>class Aggregator(Base, ABC):\n    \"\"\"\n    Aggregator interface class.\n\n    Aggregators handles aggregation and disaggregation of Components.\n    - The general approach for aggregation is to group Components, aggregate Components in the same group to (a) new Component(s),\n    delete the detailed Components, and add the mapping to self._aggregation_map.\n    - The general approach for disaggregation is to restore the detailed Components, move results from aggregated\n    Components to detailed Components, and delete the aggregated Components.\n\n    Concrete Aggregators must implement the abstract methods _aggregate() and _disaggregate().\n\n    Some rules for using Aggregators:\n    1. Disaggragate can only be called after aggregate has been called.\n    2. Not allowed to call aggregate twice. Must call disaggregate before aggregate can be called again.\n    3. Aggregators are stored in Model when aggregate is called. Disaggregate by calling Model.disaggregate(),\n         which will disaggregate all Aggregators in LIFO order.\n    4. At the moment we allow changes to the aggregated Components, which is ignored during disaggregation. TODO: Handle this\n    5. It is recommended to only use the same Aggregator type once on the same components of a Model.\n        If you want to go from one aggregation level to another, it is better to use Model.disaggregate first and then aggregate again.\n        This is to keep the logic simple and avoid complex expressions.\n\n    Some design notes:\n    - Levels and profiles are aggregated separately and then combined into attributes.\n    - We have chosen to eagerly evaluate weights for aggregation (weighted averages) and disaggregation of levels and profiles.\n        This approach supports any form of aggregation by varying the weights, and complex weights can be created by eagerly evaluating\n        expressions and using the result to compute those weights.\n    - This is a balance between eagerly evaluating everything and setting up complex expressions.\n        Eagerly evaluating everything would require setting up new TimeVectors after evaluation, which is not ideal.\n        While setting up complex expressions gives expressions that are harder to work with and slower to query from.\n    - This trade-off simplifies adding logic that recognises if result expressions come from aggregations or disaggregations.\n        When aggregating or disaggregating these, we can go back to the original results rather than setting up complex expressions\n        that for examples aggregates the disaggregated results.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the Aggregator with default state for aggregation tracking and data storage.\"\"\"\n        self._is_last_call_aggregate = None\n        self._original_data: dict[str, Component | TimeVector | Curve | Expr] | None = None\n        self._aggregation_map: dict[str, set[str]] = None\n\n    def aggregate(self, model: Model) -&gt; None:\n        \"\"\"Aggregate model. Keep original data in case disaggregate is called.\"\"\"\n        self._check_type(model, Model)\n\n        if self._is_last_call_aggregate is True:\n            message = \"Will overwrite existing aggregation.\"\n            self.send_warning_event(message)\n\n        self._original_data = deepcopy(model.get_data())\n        self._aggregate(model)\n        self._is_last_call_aggregate = True\n        if self in model._aggregators:  # noqa: SLF001\n            message = f\"{model} has already been aggregated with {self}. Cannot perform the same Aggregation more than once on a Model object.\"\n            raise ValueError(message)\n\n        # transfer_unambigous_memberships to aggregated components to support further aggregation\n        mapping = self.get_aggregation_map()\n        reversed_mapping = defaultdict(set)\n        new_data = model.get_data()\n        for member_id, group_ids in mapping.items():\n            self._check_type(group_ids, set)\n            for group_id in group_ids:\n                self._check_type(group_id, str)\n                member_component = self._original_data[member_id]\n                group_component = new_data[group_id]\n                reversed_mapping[group_component].add(member_component)\n        for group_component, member_components in reversed_mapping.items():\n            transfer_unambigous_memberships(group_component, member_components)\n\n        model._aggregators.append(deepcopy(self))  # noqa: SLF001\n\n    def disaggregate(self, model: Model) -&gt; None:\n        \"\"\"Disaggregate model back to pre-aggregate form. Move results into the disaggregated objects.\"\"\"\n        self._check_type(model, Model)\n        self._check_is_aggregated()\n        self._disaggregate(model, self._original_data)\n        self._is_last_call_aggregate = False\n        self._original_data = None\n        self._aggregation_map = None\n\n    def get_aggregation_map(self) -&gt; dict[str, set[str]]:\n        \"\"\"\n        Return dictionary mapping from disaggregated to aggregated Component IDs.\n\n        The mapping should tell you which of the original Components were aggregated into which new Components.\n        Components which are left as is should not be in the mapping.\n        Components which are deleted without being aggregated are mapped to an empty set.\n        \"\"\"\n        if self._aggregation_map is None:\n            message = f\"{self} has not yet performed an aggregation or the aggregation map was not created during aggregation.\"\n            raise ValueError(message)\n        return self._aggregation_map\n\n    @abstractmethod\n    def _aggregate(self, model: Model) -&gt; None:\n        \"\"\"Modify model inplace. Replace components with aggregated components according to some method.\"\"\"\n        pass\n\n    @abstractmethod\n    def _disaggregate(\n        self,\n        model: Model,\n        original_data: dict[str, Component | TimeVector | Curve | Expr],\n    ) -&gt; None:\n        \"\"\"\n        Modify model inplace. Restore from aggregated to original components.\n\n        Transfer any results from aggregated components to restored (disaggregated) components.\n\n        Implementers should document and handle changes in model instance between aggregation and disaggregation.\n        E.g. what to do if an aggregated component has been deleted prior to disaggregate call.\n        \"\"\"\n        pass\n\n    def _check_is_aggregated(self) -&gt; None:\n        if self._is_last_call_aggregate in [False, None]:\n            message = \"Not aggregated. Must call aggregate and disaggregate in pairs.\"\n            raise RuntimeError(message)\n</code></pre>"},{"location":"reference/#framcore.aggregators.Aggregator.Aggregator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the Aggregator with default state for aggregation tracking and data storage.</p> Source code in <code>framcore/aggregators/Aggregator.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the Aggregator with default state for aggregation tracking and data storage.\"\"\"\n    self._is_last_call_aggregate = None\n    self._original_data: dict[str, Component | TimeVector | Curve | Expr] | None = None\n    self._aggregation_map: dict[str, set[str]] = None\n</code></pre>"},{"location":"reference/#framcore.aggregators.Aggregator.Aggregator.aggregate","title":"<code>aggregate(model: Model) -&gt; None</code>","text":"<p>Aggregate model. Keep original data in case disaggregate is called.</p> Source code in <code>framcore/aggregators/Aggregator.py</code> <pre><code>def aggregate(self, model: Model) -&gt; None:\n    \"\"\"Aggregate model. Keep original data in case disaggregate is called.\"\"\"\n    self._check_type(model, Model)\n\n    if self._is_last_call_aggregate is True:\n        message = \"Will overwrite existing aggregation.\"\n        self.send_warning_event(message)\n\n    self._original_data = deepcopy(model.get_data())\n    self._aggregate(model)\n    self._is_last_call_aggregate = True\n    if self in model._aggregators:  # noqa: SLF001\n        message = f\"{model} has already been aggregated with {self}. Cannot perform the same Aggregation more than once on a Model object.\"\n        raise ValueError(message)\n\n    # transfer_unambigous_memberships to aggregated components to support further aggregation\n    mapping = self.get_aggregation_map()\n    reversed_mapping = defaultdict(set)\n    new_data = model.get_data()\n    for member_id, group_ids in mapping.items():\n        self._check_type(group_ids, set)\n        for group_id in group_ids:\n            self._check_type(group_id, str)\n            member_component = self._original_data[member_id]\n            group_component = new_data[group_id]\n            reversed_mapping[group_component].add(member_component)\n    for group_component, member_components in reversed_mapping.items():\n        transfer_unambigous_memberships(group_component, member_components)\n\n    model._aggregators.append(deepcopy(self))  # noqa: SLF001\n</code></pre>"},{"location":"reference/#framcore.aggregators.Aggregator.Aggregator.disaggregate","title":"<code>disaggregate(model: Model) -&gt; None</code>","text":"<p>Disaggregate model back to pre-aggregate form. Move results into the disaggregated objects.</p> Source code in <code>framcore/aggregators/Aggregator.py</code> <pre><code>def disaggregate(self, model: Model) -&gt; None:\n    \"\"\"Disaggregate model back to pre-aggregate form. Move results into the disaggregated objects.\"\"\"\n    self._check_type(model, Model)\n    self._check_is_aggregated()\n    self._disaggregate(model, self._original_data)\n    self._is_last_call_aggregate = False\n    self._original_data = None\n    self._aggregation_map = None\n</code></pre>"},{"location":"reference/#framcore.aggregators.Aggregator.Aggregator.get_aggregation_map","title":"<code>get_aggregation_map() -&gt; dict[str, set[str]]</code>","text":"<p>Return dictionary mapping from disaggregated to aggregated Component IDs.</p> <p>The mapping should tell you which of the original Components were aggregated into which new Components. Components which are left as is should not be in the mapping. Components which are deleted without being aggregated are mapped to an empty set.</p> Source code in <code>framcore/aggregators/Aggregator.py</code> <pre><code>def get_aggregation_map(self) -&gt; dict[str, set[str]]:\n    \"\"\"\n    Return dictionary mapping from disaggregated to aggregated Component IDs.\n\n    The mapping should tell you which of the original Components were aggregated into which new Components.\n    Components which are left as is should not be in the mapping.\n    Components which are deleted without being aggregated are mapped to an empty set.\n    \"\"\"\n    if self._aggregation_map is None:\n        message = f\"{self} has not yet performed an aggregation or the aggregation map was not created during aggregation.\"\n        raise ValueError(message)\n    return self._aggregation_map\n</code></pre>"},{"location":"reference/#framcore.aggregators.Aggregator.transfer_unambigous_memberships","title":"<code>transfer_unambigous_memberships(group_component: Component, member_components: Iterable[Component]) -&gt; None</code>","text":"<p>Transfer unambiguous membership metadata from member components to a group component.</p>"},{"location":"reference/#framcore.aggregators.Aggregator.transfer_unambigous_memberships--parameters","title":"Parameters","text":"<p>group_component : Component     The component to which unambiguous membership metadata will be transferred. member_components : Iterable[Component]     The components from which membership metadata is collected.</p>"},{"location":"reference/#framcore.aggregators.Aggregator.transfer_unambigous_memberships--notes","title":"Notes","text":"<p>Only metadata keys with a single unique Member value among all member components are transferred. Existing metadata on the group component is not overwritten.</p> Source code in <code>framcore/aggregators/Aggregator.py</code> <pre><code>def transfer_unambigous_memberships(group_component: Component, member_components: Iterable[Component]) -&gt; None:\n    \"\"\"\n    Transfer unambiguous membership metadata from member components to a group component.\n\n    Parameters\n    ----------\n    group_component : Component\n        The component to which unambiguous membership metadata will be transferred.\n    member_components : Iterable[Component]\n        The components from which membership metadata is collected.\n\n    Notes\n    -----\n    Only metadata keys with a single unique Member value among all member components are transferred.\n    Existing metadata on the group component is not overwritten.\n\n    \"\"\"\n    d = defaultdict(set)\n    for member in member_components:\n        for key in member.get_meta_keys():\n            value = member.get_meta(key)\n            if not isinstance(value, Member):\n                continue\n            d[key].add(value)\n    for key, value_set in d.items():\n        test_value = group_component.get_meta(key)\n        if test_value is not None:\n            # don't overwrite if already set\n            continue\n        if len(value_set) != 1:\n            # ambigous membership\n            continue\n        value = next(iter(value_set))\n        group_component.add_meta(key, value)\n</code></pre>"},{"location":"reference/#framcore.aggregators.HydroAggregator","title":"<code>HydroAggregator</code>","text":""},{"location":"reference/#framcore.aggregators.HydroAggregator.HydroAggregator","title":"<code>HydroAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> <p>Aggregate HydroModules into two equivalent modules based on the regulation factor, into one regulated and one unregulated module per area.</p> <p>Aggregation steps (self._aggregate):</p> <ol> <li>Group modules based on their power nodes (self._group_modules_by_power_node)<ul> <li>Modules with generators are grouped based on their power nodes. You can choose to only group modules for certain power nodes by giving self._power_node_members alone or together with self._metakey_power_node. NB! Watershed that crosses power nodes should not be aggregated in two different HydroAggregators as the aggregator will remove all connected modules from the model after the first aggregation.</li> <li>Reservoirs are assigned to the power node which has the highest cumulative energy equivalent downstream of the reservoir. This is because JulES currently only support one-to-one mapping of detailed and aggregated reservoirs.</li> <li>Reservoirs without generators downstream are ignored in the aggregation.</li> </ul> </li> <li>Group area modules into regulated and unregulated based on regulation factor (self._group_modules_by_regulation_factor)<ul> <li>Regulation factor = upstream reservoir capacity / yearly upstream inflow. Modules with generators that have regulation factor &lt;= self._ror_threshold are grouped into unregulated run-of-river modules, the other modules with generators are grouped into regulated reservoir modules.</li> <li>All reservoirs are assigned to the regulated group.</li> <li>Generators without upstream inflows are ignored in the aggregation.</li> </ul> </li> <li>Make aggregated hydro module for each group (self._aggregate_groups)<ul> <li>The resulting HydroModule has a generator with energy equivalent of 1 kWh/m3. The inflow, discharge capacity and reservoir capacity is calculated based on energy and transformed back to water using this energy equivalent.</li> <li>Generation capacity (release_cap*energy_equivalent/agg_energy_equivalent, capacity of hydraulic couplings not double counted). The release capacity profile is ignored except if self._release_capacity_profile is given, then this profile is used for all aggregated modules.</li> <li>Energy reservoir capacity (res_cap*energy_equivalent_downstream/agg_energy_equivalent)</li> <li>Gross energy inflow (inflow_up*energy_equivalent/agg_energy_equivalent) - TODO: Add possibility to adjust inflow to closer represent net inflow</li> <li>Inflow profiles weighted based on gross energy inflow (inflow_up_per_profile*energy_equivalent) - calc from core model using self._map_topology()</li> <li>TODO: Other details like pumps and environmental constraints are currently ignored in the aggregation. 3a. Aggregate results if all modules in group have results.</li> <li>Production is the sum of production levels with weighted profiles</li> <li>Reservoir filling is the sum of energy reservoir filling levels (filling*energy_equivalent_downstream/agg_energy_equivalent) with weighted profiles</li> <li>TODO: Water values, spill, bypass and pumping results are currently ignored in the aggregation.</li> <li>TODO: Add possibility to skip results aggregation. 3b. Make new hydro module and delete original modules from model data.</li> </ul> </li> <li>Add mapping from detailed to aggregated modules to self._aggregation_map.</li> </ol> <p>Disaggregation steps (self._disaggregate):</p> <ol> <li>Restore original modules from self._original_data. NB! Changes to aggregated modules are lost except for results (TODO)</li> <li>Move production and filling results from aggregated modules to detailed modules, weighted based on production capacity and reservoir capacity.<ul> <li>TODO: Water values, spill, bypass and pumping results are currently ignored in the disaggregation.</li> </ul> </li> <li>Delete aggregated modules.</li> </ol> <p>NB! Watershed that crosses power nodes should not be aggregated in two different HydroAggregators as the aggregator will remove all connected modules from the model after the first aggregation. Reservoirs will also be assigned to the power node which has the highest cumulative energy equivalent, so this aggregator does not work well for reservoirs that are upstream of multiple power nodes.</p> <p>See Aggregator for general design notes and rules to follow when using Aggregators.</p> <p>Attributes:</p> Name Type Description <code>_metakey_energy_eq_downstream</code> <code>str</code> <p>Metadata key for energy equivalent downstream.</p> <code>_data_dim</code> <code>SinglePeriodTimeIndex</code> <p>Data dimension for eager evalutation.</p> <code>_scen_dim</code> <code>FixedFrequencyTimeIndex</code> <p>Scenario dimension for eager evalutation.</p> <code>_grouped_modules</code> <code>dict[str, set[str]]</code> <p>Mapping of aggregated modules to detailed modules. agg to detailed</p> <code>_grouped_reservoirs</code> <code>dict[str, set[str]]</code> <p>Mapping of aggregated reservoirs to detailed reservoirs. agg to detailed</p> <code>_ror_threshold</code> <code>float</code> <p>Regulation factor (upstream reservoir capacity / yearly upstream inflow) threshold for run-of-river classification. Default is 0.5.</p> <code>_metakey_power_node</code> <code>str | None</code> <p>If given, check metadata of power nodes to check if they should be grouped.</p> <code>_power_node_members</code> <code>list[str] | None</code> <p>If given along with metakey_power_node, group modules only for power nodes with these metadata values. If given without metakey_power_node, only group power nodes in this list.</p> <code>_release_capacity_profile</code> <code>TimeVector | None</code> <p>If given, use this profile for all aggregated modules' release capacities.</p> <p>Parent Attributes (see framcore.aggregators.Aggregator):</p> <pre><code>_is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n_original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n_aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n</code></pre> Source code in <code>framcore/aggregators/HydroAggregator.py</code> <pre><code>class HydroAggregator(Aggregator):\n    \"\"\"\n    Aggregate HydroModules into two equivalent modules based on the regulation factor, into one regulated and one unregulated module per area.\n\n    Aggregation steps (self._aggregate):\n\n    1. Group modules based on their power nodes (self._group_modules_by_power_node)\n        - Modules with generators are grouped based on their power nodes. You can choose to only group modules for certain power nodes by giving\n        self._power_node_members alone or together with self._metakey_power_node. NB! Watershed that crosses power nodes should not be aggregated in two\n        different HydroAggregators as the aggregator will remove all connected modules from the model after the first aggregation.\n        - Reservoirs are assigned to the power node which has the highest cumulative energy equivalent downstream of the reservoir. This is because JulES\n        currently only support one-to-one mapping of detailed and aggregated reservoirs.\n        - Reservoirs without generators downstream are ignored in the aggregation.\n    2. Group area modules into regulated and unregulated based on regulation factor (self._group_modules_by_regulation_factor)\n        - Regulation factor = upstream reservoir capacity / yearly upstream inflow. Modules with generators that have regulation factor &lt;= self._ror_threshold\n        are grouped into unregulated run-of-river modules, the other modules with generators are grouped into regulated reservoir modules.\n        - All reservoirs are assigned to the regulated group.\n        - Generators without upstream inflows are ignored in the aggregation.\n    3. Make aggregated hydro module for each group (self._aggregate_groups)\n        - The resulting HydroModule has a generator with energy equivalent of 1 kWh/m3. The inflow, discharge capacity and reservoir capacity\n        is calculated based on energy and transformed back to water using this energy equivalent.\n        - Generation capacity (release_cap*energy_equivalent/agg_energy_equivalent, capacity of hydraulic couplings not double counted). The release capacity\n        profile is ignored except if self._release_capacity_profile is given, then this profile is used for all aggregated modules.\n        - Energy reservoir capacity (res_cap*energy_equivalent_downstream/agg_energy_equivalent)\n        - Gross energy inflow (inflow_up*energy_equivalent/agg_energy_equivalent) - TODO: Add possibility to adjust inflow to closer represent net inflow\n        - Inflow profiles weighted based on gross energy inflow (inflow_up_per_profile*energy_equivalent) - calc from core model using self._map_topology()\n        - TODO: Other details like pumps and environmental constraints are currently ignored in the aggregation.\n    3a. Aggregate results if all modules in group have results.\n        - Production is the sum of production levels with weighted profiles\n        - Reservoir filling is the sum of energy reservoir filling levels (filling*energy_equivalent_downstream/agg_energy_equivalent) with weighted profiles\n        - TODO: Water values, spill, bypass and pumping results are currently ignored in the aggregation.\n        - TODO: Add possibility to skip results aggregation.\n    3b. Make new hydro module and delete original modules from model data.\n    4. Add mapping from detailed to aggregated modules to self._aggregation_map.\n\n\n    Disaggregation steps (self._disaggregate):\n\n    1. Restore original modules from self._original_data. NB! Changes to aggregated modules are lost except for results (TODO)\n    2. Move production and filling results from aggregated modules to detailed modules, weighted based on production capacity and reservoir capacity.\n        - TODO: Water values, spill, bypass and pumping results are currently ignored in the disaggregation.\n    3. Delete aggregated modules.\n\n    NB! Watershed that crosses power nodes should not be aggregated in two different HydroAggregators as the aggregator will remove all connected modules\n    from the model after the first aggregation. Reservoirs will also be assigned to the power node which has the highest cumulative energy equivalent, so\n    this aggregator does not work well for reservoirs that are upstream of multiple power nodes.\n\n    See Aggregator for general design notes and rules to follow when using Aggregators.\n\n    Attributes:\n        _metakey_energy_eq_downstream (str): Metadata key for energy equivalent downstream.\n        _data_dim (SinglePeriodTimeIndex): Data dimension for eager evalutation.\n        _scen_dim (FixedFrequencyTimeIndex): Scenario dimension for eager evalutation.\n        _grouped_modules (dict[str, set[str]]): Mapping of aggregated modules to detailed modules. agg to detailed\n        _grouped_reservoirs (dict[str, set[str]]): Mapping of aggregated reservoirs to detailed reservoirs. agg to detailed\n        _ror_threshold (float): Regulation factor (upstream reservoir capacity / yearly upstream inflow) threshold for run-of-river classification.\n            Default is 0.5.\n        _metakey_power_node (str | None): If given, check metadata of power nodes to check if they should be grouped.\n        _power_node_members (list[str] | None): If given along with metakey_power_node, group modules only for power nodes with these metadata values.\n            If given without metakey_power_node, only group power nodes in this list.\n        _release_capacity_profile (TimeVector | None): If given, use this profile for all aggregated modules' release capacities.\n\n    Parent Attributes (see framcore.aggregators.Aggregator):\n\n        _is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n        _original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n        _aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n\n    \"\"\"\n\n    def __init__(\n        self,\n        metakey_energy_eq_downstream: str,\n        data_dim: SinglePeriodTimeIndex,\n        scen_dim: FixedFrequencyTimeIndex,\n        ror_threshold: float = 0.5,\n        metakey_power_node: str | None = None,\n        power_node_members: list[str] | None = None,\n        release_capacity_profile: TimeVector | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize HydroAggregator.\n\n        Args:\n            metakey_energy_eq_downstream (str): Metadata key for energy equivalent downstream.\n                Can be calculated with framcore.utils.set_global_energy_equivalent\n            data_dim (SinglePeriodTimeIndex): Data dimension for eager evalutation.\n            scen_dim (FixedFrequencyTimeIndex): Scenario dimension for eager evalutation.\n            ror_threshold (float): Regulation factor (upstream reservoir capacity / yearly upstream inflow) threshold for run-of-river classification.\n                Default is 0.5.\n            metakey_power_node (str | None): If given, check metadata of power nodes to check if they should be grouped.\n            power_node_members (list[str] | None): If given along with metakey_power_node, group modules only for power nodes with these metadata values.\n                If given without metakey_power_node, only group power nodes in this list.\n            release_capacity_profile (TimeVector | None): If given, use this profile for all aggregated modules' release capacities.\n\n        \"\"\"\n        super().__init__()\n        self._check_type(metakey_energy_eq_downstream, str)\n        self._check_type(ror_threshold, float)\n        self._check_type(data_dim, SinglePeriodTimeIndex)\n        self._check_type(scen_dim, FixedFrequencyTimeIndex)\n        self._check_type(metakey_power_node, (str, type(None)))\n        self._check_type(power_node_members, (list, type(None)))\n        if ror_threshold &lt; 0:\n            msg = f\"ror_threshold must be non-negative, got {ror_threshold}.\"\n            raise ValueError(msg)\n        if metakey_power_node is not None and len(power_node_members) &lt;= 0:\n            raise ValueError(\"If metakey_power_node is given, power_node_members must also be given.\")\n\n        self._metakey_energy_eq_downstream = metakey_energy_eq_downstream\n        self._ror_threshold = ror_threshold\n        self._metakey_power_node = metakey_power_node\n        self._power_node_members = power_node_members\n        self._release_capacity_profile = release_capacity_profile\n\n        self._data_dim = data_dim\n        self._scen_dim = scen_dim\n\n        self._grouped_modules: dict[str, set[str]] = defaultdict(list)  # agg to detailed\n        self._grouped_reservoirs: dict[str, set[str]] = defaultdict(list)  # agg to detailed\n\n    def _aggregate(self, model: Model) -&gt; None:  # noqa: C901, PLR0915\n        t0 = time()\n        data = model.get_data()\n\n        t = time()\n        upstream_topology = self._map_upstream_topology(data)\n        self.send_debug_event(f\"_map_upstream_topology time: {round(time() - t, 3)} seconds\")\n\n        t = time()\n        generator_module_groups, reservoir_module_groups = self._group_modules_by_power_node(model, upstream_topology)\n        self.send_debug_event(f\"_group_modules_by_power_node time: {round(time() - t, 3)} seconds\")\n\n        t = time()\n        self._group_modules_by_regulation_factor(model, generator_module_groups, reservoir_module_groups, upstream_topology)\n        self.send_debug_event(f\"_group_modules_by_regulation_factor time: {round(time() - t, 3)} seconds\")\n\n        t = time()\n        ignore_production_capacity_modules = self._ignore_production_capacity_modules(model)\n        self.send_debug_event(f\"_ignore_production_capacity_modules time: {round(time() - t, 3)} seconds\")\n\n        t = time()\n        self._aggregate_groups(model, upstream_topology, ignore_production_capacity_modules)\n        self.send_debug_event(f\"_aggregate_groups time: {round(time() - t, 3)} seconds\")\n\n        # Add reservoir modules to aggregation map\n        t = time()\n        self._aggregation_map = {dd: set([a]) for a, d in self._grouped_reservoirs.items() for dd in d}\n        self.send_debug_event(f\"add reservoir modules to _aggregation_map time: {round(time() - t, 3)} seconds\")\n\n        # Add generator modules to aggregation map\n        t = time()\n        for a, d in self._grouped_modules.items():\n            for dd in d:\n                if dd not in self._aggregation_map:\n                    self._aggregation_map[dd] = set([a])\n                elif not (data[dd].get_reservoir() and data[a].get_reservoir()):  # reservoir modules can only be mapped to one aggregated reservoir module\n                    self._aggregation_map[dd].add(a)\n        self.send_debug_event(f\"add generator modules to _aggregation_map time: {round(time() - t, 3)} seconds\")\n\n        # Delete detailed modules and add remaining modules to aggregation map\n        t = time()\n        upstream_topology_with_bypass_spill = self._map_upstream_topology(data, include_bypass_spill=True)\n        aggregated_hydromodules = {module for modules in generator_module_groups.values() for module in modules}  # add generator modules\n        for grouped_modules in generator_module_groups.values():  # add upstream modules\n            for grouped_module in grouped_modules:\n                upstream = upstream_topology_with_bypass_spill[grouped_module]\n                aggregated_hydromodules.update(upstream)\n        for downstream_module in upstream_topology_with_bypass_spill:  # add downstream modules\n            for upstream in upstream_topology_with_bypass_spill[downstream_module]:\n                if upstream in aggregated_hydromodules:\n                    aggregated_hydromodules.add(downstream_module)\n                    break\n        other_modules = [key for key, component in data.items() if isinstance(component, HydroModule) and key not in aggregated_hydromodules]\n        other_generator_modules = [m for m in other_modules if data[m].get_generator()]\n        for m in other_modules:  # remove other modules that do not interact with generator modules\n            interacts = False\n            for upstreams in upstream_topology_with_bypass_spill[m]:\n                for upstream in upstreams:\n                    if upstream in other_generator_modules:\n                        interacts = True\n                        break\n            for gm in other_generator_modules:\n                if m in upstream_topology_with_bypass_spill[gm]:\n                    interacts = True\n                    break\n            if not interacts:\n                aggregated_hydromodules.add(m)\n                message = f\"Module {m} is not upstream or downstream of any generator module, adding to aggregation as it does not interact with power system.\"\n                self.send_warning_event(message)\n\n        for m_key in aggregated_hydromodules:\n            if m_key not in self._grouped_modules:\n                if not (m_key in self._aggregation_map or m_key in self._grouped_reservoirs):\n                    self._aggregation_map[m_key] = set()\n                del model.get_data()[m_key]\n        self.send_debug_event(f\"delete detailed modules time: {round(time() - t, 3)} seconds\")\n\n        self.send_debug_event(f\"total _aggregate: {round(time() - t0, 3)} seconds\")\n\n    def _map_upstream_topology(  # noqa: C901\n        self,\n        data: dict[str, Component | TimeVector | Curve | Expr],\n        include_bypass_spill: bool = False,\n    ) -&gt; dict[str, list[str]]:\n        \"\"\"Map HydroModules topology. Return dict[module, List[upstream modules + itself]].\"\"\"\n        module_names = [key for key, component in data.items() if isinstance(component, HydroModule)]\n\n        # Direct upstream mapping (including transport pumps)\n        direct_upstream = {module_name: [] for module_name in module_names}\n        for module_name in module_names:\n            release_to = data[module_name].get_release_to()\n            pump = data[module_name].get_pump()\n            if data[module_name].get_pump() and pump.get_from_module() == module_name:  # transport pump\n                pump = data[module_name].get_pump()\n                pump_to = pump.get_to_module()\n                direct_upstream[pump_to].append(module_name)\n            elif release_to:  # other\n                try:\n                    direct_upstream[release_to].append(module_name)\n                except KeyError as e:\n                    message = f\"Reference to {release_to} does not exist in Model. Referenced by {module_name} Module.\"\n                    raise KeyError(message) from e\n            if include_bypass_spill:\n                bypass = data[module_name].get_bypass()\n                if bypass:\n                    bypass_to = bypass.get_to_module()\n                    if bypass_to:\n                        try:\n                            direct_upstream[bypass_to].append(module_name)\n                        except KeyError as e:\n                            message = f\"Reference to {bypass_to} does not exist in Model. Referenced by {module_name} Module.\"\n                            raise KeyError(message) from e\n                spill_to = data[module_name].get_spill_to()\n                if spill_to:\n                    try:\n                        direct_upstream[spill_to].append(module_name)\n                    except KeyError as e:\n                        message = f\"Reference to {spill_to} does not exist in Model. Referenced by {module_name} Module.\"\n                        raise KeyError(message) from e\n\n        # Recursive upstream function\n        def find_all_upstream(\n            module_name: str,\n            visited: set,\n            data: dict[str, Component | TimeVector | Curve | Expr],\n        ) -&gt; list[str]:\n            if module_name in visited:\n                return []  # Avoid circular dependencies\n            visited.add(module_name)\n            upstream_names = direct_upstream[module_name]\n            all_upstream = set(upstream_names)\n            for upstream in upstream_names:\n                all_upstream.update(find_all_upstream(upstream, visited, data))\n            all_upstream.add(module_name)  # include itself\n            return visited\n\n        # Full upstream topology\n        topology = {}\n        for module_name in module_names:\n            topology[module_name] = list(find_all_upstream(module_name, set(), data))\n\n        return topology\n\n    def _build_upstream_reservoir_and_inflow_exprs(\n        self,\n        data: dict[str, Component | TimeVector | Curve | Expr],\n        upstream_topology: dict[str, list[str]],\n    ) -&gt; tuple[dict[str, Expr], dict[str, Expr]]:\n        \"\"\"Build upstream inflow and reservoir expressions for each generator module.\"\"\"\n        upstream_inflow_exprs = dict[str, Expr]()\n        upstream_reservoir_exprs = dict[str, Expr]()\n        generator_modules = [key for key, module in data.items() if isinstance(module, HydroModule) and module.get_generator()]\n        for m in generator_modules:\n            inflow_expr = 0\n            reservoir_expr = 0\n            for mm in upstream_topology[m]:\n                inflow = data[mm].get_inflow()\n                if inflow:\n                    inflow_expr += inflow.get_level()\n                reservoir = data[mm].get_reservoir()\n                if reservoir:\n                    reservoir_expr += reservoir.get_capacity().get_level()\n\n            upstream_inflow_exprs[m] = inflow_expr\n            upstream_reservoir_exprs[m] = reservoir_expr\n\n        return upstream_inflow_exprs, upstream_reservoir_exprs\n\n    def _group_modules_by_power_node(self, model: Model, upstream_topology: dict[str, list[str]]) -&gt; dict[str, list[str]]:  # noqa: C901\n        \"\"\"Group modules by power node. Return generator_module_groups, reservoir_module_groups.\"\"\"\n        data = model.get_data()\n        generator_module_groups = defaultdict(list)  # power_node -&gt; generator_modules\n        reservoir_mapping = defaultdict(set)  # reservoir -&gt; power_node(s)\n        for key, component in data.items():\n            if isinstance(component, HydroModule) and component.get_generator():\n                power_node = component.get_generator().get_power_node()\n                if self._metakey_power_node is None and self._power_node_members and power_node not in self._power_node_members:\n                    continue\n                if self._metakey_power_node is not None:  # only group modules for nodes in self._power_node_members\n                    power_node_component = data[power_node]\n                    node_meta = power_node_component.get_meta(self._metakey_power_node)\n                    if node_meta is None:\n                        message = f\"Module {key} does not have metadata '{self._metakey_power_node}' for node mapping.\"\n                        raise ValueError(message)\n                    node_meta_value = node_meta.get_value()\n                    if node_meta_value not in self._power_node_members:\n                        continue\n\n                generator_module_groups[power_node].append(key)\n\n                for m in upstream_topology[key]:\n                    if data[m].get_reservoir():\n                        reservoir_mapping[m].add(power_node)\n\n        # Group reservoirs to the power node with the highest cumulative energy equivalent downstream from the reservoir\n        reservoir_module_groups: dict[str, list[str]] = defaultdict(list)\n        for res_name in reservoir_mapping:\n            power_nodes = reservoir_mapping[res_name]\n            if len(power_nodes) &gt; 1:\n                highest_power_node = max(\n                    power_nodes,\n                    key=lambda pn: get_level_value(\n                        get_hydro_downstream_energy_equivalent(data, res_name, pn),\n                        db=model,\n                        unit=\"kWh/m3\",\n                        data_dim=self._data_dim,\n                        scen_dim=self._scen_dim,\n                        is_max=False,\n                    ),\n                )\n                reservoir_module_groups[highest_power_node].append(res_name)\n            else:\n                reservoir_module_groups[next(iter(power_nodes))].append(res_name)\n\n        return generator_module_groups, reservoir_module_groups\n\n    def _group_modules_by_regulation_factor(\n        self,\n        model: Model,\n        generator_module_groups: dict[str, list[str]],\n        reservoir_module_groups: dict[str, list[str]],\n        upstream_topology: dict[str, list[str]],\n    ) -&gt; None:\n        \"\"\"\n        Group modules into regulated and unregulated based on regulation factor and self._ror_threshold.\n\n        Regulation factor = upstream reservoir capacity / yearly upstream inflow.\n        Run-of-river = regulation factor &lt;= self._ror_threshold.\n        Regulated = regulation factor &gt; self._ror_threshold.\n        \"\"\"\n        data = model.get_data()\n        upstream_inflow_exprs, upstream_reservoir_exprs = self._build_upstream_reservoir_and_inflow_exprs(data, upstream_topology)\n\n        for area, member_modules in generator_module_groups.items():\n            ror_name = area + \"_hydro_RoR\"\n            reg_name = area + \"_hydro_reservoir\"\n\n            ror_modules = []\n            reservoir_modules = []\n\n            for m_key in member_modules:\n                if upstream_inflow_exprs[m_key] != 0:\n                    upstream_inflow = get_level_value(\n                        upstream_inflow_exprs[m_key],\n                        db=model,\n                        unit=\"Mm3/year\",\n                        data_dim=self._data_dim,\n                        scen_dim=self._scen_dim,\n                        is_max=False,\n                    )\n                else:\n                    continue  # Skip generator modules with no upstream inflow\n                if upstream_reservoir_exprs[m_key] != 0:\n                    upstream_reservoir = get_level_value(\n                        upstream_reservoir_exprs[m_key],\n                        db=model,\n                        unit=\"Mm3\",\n                        data_dim=self._data_dim,\n                        scen_dim=self._scen_dim,\n                        is_max=False,\n                    )\n                else:\n                    upstream_reservoir = 0\n                regulation_factor = upstream_reservoir / upstream_inflow if upstream_inflow &gt; 0 else 0\n\n                if regulation_factor &lt;= self._ror_threshold:\n                    ror_modules.append(m_key)\n                else:\n                    reservoir_modules.append(m_key)\n\n            if len(ror_modules) &gt; 0:  # only make run-of-river group if there are any modules\n                self._grouped_modules[ror_name] = ror_modules\n\n            if len(reservoir_modules) &gt; 0:  # only make reservoir group if there are any modules\n                self._grouped_modules[reg_name] = reservoir_modules\n\n            if len(reservoir_module_groups[area]) &gt; 0 and len(reservoir_modules) &gt; 0:  # add reservoirs to reg group\n                self._grouped_reservoirs[reg_name] = reservoir_module_groups[area]\n            elif len(reservoir_module_groups[area]) &gt; 0:  # add reservoirs to ror group if no reg group\n                self._grouped_reservoirs[ror_name] = reservoir_module_groups[area]\n                message = f\"{area} has no modules over ror_threshold ({self._ror_threshold}), so all reservoirs are put in RoR module.\"\n                self.send_warning_event(message)\n\n    def _ignore_production_capacity_modules(\n        self,\n        model: Model,\n    ) -&gt; list[str]:\n        \"\"\"\n        Return list of module names to ignore production capacity for in aggregation, because of hydraulic coupled reservoirs.\n\n        Ignore the lowest production capacity of modules that are under the same hydraulic coupled reservoirs.\n        \"\"\"\n        ignore_production_capacity_modules = []\n        data = model.get_data()\n        module_names = [key for key, component in data.items() if isinstance(component, HydroModule)]\n\n        for m in module_names:\n            if data[m].get_hydraulic_coupling() != 0:\n                under_hydraulic = [\n                    (\n                        mm,\n                        get_level_value(\n                            data[mm].get_generator().get_energy_equivalent().get_level() * data[mm].get_release_capacity().get_level(),\n                            model,\n                            \"MW\",\n                            self._data_dim,\n                            self._scen_dim,\n                            is_max=False,\n                        ),\n                    )\n                    for mm in module_names\n                    if data[mm].get_release_to() == m\n                ]\n                assert len(under_hydraulic) &gt; 1\n                ignore_production_capacity_modules.append(min(under_hydraulic, key=lambda x: x[1])[0])\n\n        return ignore_production_capacity_modules\n\n    def _aggregate_groups(  # noqa: C901, PLR0915\n        self,\n        model: Model,\n        upstream_topology: dict[str, list[str]],\n        ignore_capacity: list[str],\n    ) -&gt; None:\n        \"\"\"Aggregate each group of modules into one HydroModule.\"\"\"\n        data = model.get_data()\n        for new_id, module_names in self._grouped_modules.items():\n            num_reservoirs = 0\n            if new_id in self._grouped_reservoirs:\n                num_reservoirs = len(self._grouped_reservoirs[new_id])\n            self.send_info_event(f\"{new_id} from {len(module_names)} generator modules and {num_reservoirs} reservoirs.\")\n\n            # Generator and production\n            generator_module_names = [m for m in module_names if data[m].get_generator()]\n            productions = [data[m].get_generator().get_production() for m in generator_module_names]\n            sum_production = _aggregate_result_volumes(model, productions, \"MW\", self._data_dim, self._scen_dim, new_id, generator_module_names)\n\n            generator = HydroGenerator(\n                power_node=data[generator_module_names[0]].get_generator().get_power_node(),\n                energy_equivalent=Conversion(level=ConstantTimeVector(1.0, \"kWh/m3\", is_max_level=True)),\n                production=sum_production,\n            )\n            energy_eq = generator.get_energy_equivalent().get_level()\n\n            # Release capacity\n            release_capacities = [data[m].get_release_capacity() for m in generator_module_names if m not in ignore_capacity]\n            if self._release_capacity_profile:\n                if not all([rc.get_profile() is None for rc in release_capacities]):\n                    message = f\"Some release capacities in {new_id} have profiles, using provided profile for all.\"\n                    self.send_warning_event(message)\n                release_capacities = deepcopy(release_capacities)\n                for rc in release_capacities:\n                    rc.set_profile(self._release_capacity_profile)\n            generator_energy_eqs = [data[m].get_generator().get_energy_equivalent() for m in generator_module_names if m not in ignore_capacity]\n            release_capacity_levels = [rc.get_level() * ee.get_level() for rc, ee in zip(release_capacities, generator_energy_eqs, strict=True)]\n\n            release_capacity_profile = None\n            if any(rc.get_profile() for rc in release_capacities):\n                one_profile_max = Expr(src=ConstantTimeVector(1.0, is_zero_one_profile=False), is_profile=True)\n                weights = [get_level_value(rcl, model, \"MW\", self._data_dim, self._scen_dim, is_max=True) for rcl in release_capacity_levels]\n                profiles = [rc.get_profile() if rc.get_profile() else one_profile_max for rc in release_capacities]\n                release_capacity_profile = _aggregate_weighted_expressions(profiles, weights)\n            release_capacity = MaxFlowVolume(level=sum(release_capacity_levels) / energy_eq, profile=release_capacity_profile)\n\n            # Inflow level\n            upstream_inflow_levels = defaultdict(list)\n            for m in generator_module_names:\n                for mm in upstream_topology[m]:\n                    inflow = data[mm].get_inflow()\n                    if inflow:\n                        upstream_inflow_levels[m].append(inflow.get_level())\n            inflow_level_energy = sum(\n                sum(upstream_inflow_levels[m]) * data[m].get_generator().get_energy_equivalent().get_level()\n                for m in generator_module_names\n                if len(upstream_inflow_levels[m]) &gt; 0\n            )\n            inflow_level = inflow_level_energy / energy_eq\n\n            # Inflow profile\n            one_profile = Expr(src=ConstantTimeVector(1.0, is_zero_one_profile=False), is_profile=True)\n            inflow_profile_to_energyinflow = defaultdict(list)\n            inflow_level_to_value = dict()\n            for m in generator_module_names:\n                m_energy_eq = data[m].get_generator().get_energy_equivalent().get_level()\n                m_energy_eq_value = get_level_value(\n                    m_energy_eq,\n                    db=model,\n                    unit=\"kWh/m3\",\n                    data_dim=self._data_dim,\n                    scen_dim=self._scen_dim,\n                    is_max=False,\n                )\n                for upstream_module in upstream_topology[m]:\n                    inflow = data[upstream_module].get_inflow()\n                    if inflow:\n                        if inflow not in inflow_level_to_value:\n                            inflow_level_to_value[inflow] = get_level_value(\n                                inflow.get_level(),\n                                db=model,\n                                unit=\"m3/s\",\n                                data_dim=self._data_dim,\n                                scen_dim=self._scen_dim,\n                                is_max=False,\n                            )\n                        upstream_energy_inflow = inflow_level_to_value[inflow] * m_energy_eq_value\n                        upstream_profile = inflow.get_profile() if inflow.get_profile() else one_profile\n                        inflow_profile_to_energyinflow[upstream_profile].append(upstream_energy_inflow)\n\n            profile_weights = [sum(energyinflows) for energyinflows in inflow_profile_to_energyinflow.values()]\n            inflow_profile = _aggregate_weighted_expressions(list(inflow_profile_to_energyinflow.keys()), profile_weights)\n            inflow = AvgFlowVolume(level=inflow_level, profile=inflow_profile)\n\n            # Reservoir capacity and filling\n            if new_id in self._grouped_reservoirs and len(self._grouped_reservoirs[new_id]) &gt; 0:\n                reservoir_levels = [\n                    data[m].get_reservoir().get_capacity().get_level() * data[m].get_meta(self._metakey_energy_eq_downstream).get_value()\n                    for m in self._grouped_reservoirs[new_id]\n                ]\n                reservoir_level = sum(reservoir_levels) / energy_eq\n                reservoir_capacity = StockVolume(level=reservoir_level)\n\n                fillings = [data[m].get_reservoir().get_volume() for m in self._grouped_reservoirs[new_id]]\n                energy_eq_downstreams = [data[m].get_meta(self._metakey_energy_eq_downstream).get_value() for m in self._grouped_reservoirs[new_id]]\n                sum_filling = self._aggregate_fillings(fillings, energy_eq_downstreams, energy_eq, model, \"GWh\", new_id, self._grouped_reservoirs[new_id])\n                reservoir = HydroReservoir(capacity=reservoir_capacity, volume=sum_filling)\n            else:\n                reservoir = None\n\n            new_hydro = HydroModule(\n                generator=generator,\n                reservoir=reservoir,\n                inflow=inflow,\n                release_capacity=release_capacity,\n            )\n            new_hydro.add_meta(key=self._metakey_energy_eq_downstream, value=LevelExprMeta(energy_eq))\n\n            data[new_id] = new_hydro\n\n    def _aggregate_fillings(\n        self,\n        fillings: list[StockVolume],\n        energy_eq_downstreams: list[Expr],\n        energy_eq: Expr,\n        model: Model,\n        weight_unit: str,\n        group_id: str,\n        members: list[str],\n    ) -&gt; StockVolume | None:\n        \"\"\"Aggregate reservoir fillings if all fillings are not None.\"\"\"\n        sum_filling = None\n        if all(filling.get_level() for filling in fillings):\n            if any(not filling.get_profile() for filling in fillings):\n                missing = [member for member, filling in zip(members, fillings, strict=False) if not filling.get_profile()]\n                message = (\n                    \"Some reservoir fillings in grouped modules have no profile. Cannot aggregate profiles.\",\n                    f\"Group: '{group_id}', missing profile for {missing}.\",\n                )\n                raise ValueError(message)\n            level, profiles, weights = self._get_level_profiles_weights_fillings(model, fillings, energy_eq_downstreams, energy_eq, weight_unit)\n            profile = _aggregate_weighted_expressions(profiles, weights)\n            sum_filling = StockVolume(level=level, profile=profile)\n        elif any(filling.get_level() for filling in fillings):\n            missing = [member for member, filling in zip(members, fillings, strict=False) if not filling.get_level()]\n            message = (\n                \"Some but not all grouped modules have reservoir filling defined, reservoir filling not aggregated. \"\n                f\"Group: {group_id}, missing filling for {missing}.\"\n            )\n            self.send_warning_event(message)\n        return sum_filling\n\n    def _get_level_profiles_weights_fillings(\n        self,\n        model: Model,\n        fillings: list[StockVolume],\n        energy_eq_downstreams: list[Expr],\n        energy_eq: Expr,\n        weight_unit: str,\n    ) -&gt; tuple[Expr, list[Expr], list[float]]:\n        \"\"\"\n        Get aggregated filling level, and profiles with weights from list of fillings.\n\n        Two cases:\n        1) All fillings are expressions from previous disaggregation. Can be aggregated more efficiently.\n        2) Default case, where we weight fillings based on energy equivalent inflow.\n        \"\"\"\n        levels = [filling.get_level() for filling in fillings]\n        if all(self._is_disagg_filling_expr(level) for level in levels):\n            return _get_level_profile_weights_from_disagg_levelprofiles(model, fillings, self._data_dim, self._scen_dim)\n        levels_energy = [filling * ee for filling, ee in zip(levels, energy_eq_downstreams, strict=True)]\n        level = sum(levels_energy) / energy_eq\n        profiles = [filling.get_profile() for filling in fillings]\n        weights = [get_level_value(level_energy, model, weight_unit, self._data_dim, self._scen_dim, False) for level_energy in levels_energy]\n        return level, profiles, weights\n\n    def _is_disagg_filling_expr(self, expr: Expr) -&gt; bool:\n        \"\"\"Check if expr is ((weight * agg_level * energy_eq_downstream) / energy_eq_agg) which indicates it comes from disaggregation.\"\"\"\n        if expr.is_leaf():\n            return False\n        ops, args = expr.get_operations(expect_ops=True, copy_list=False)\n        if not (\n            ops == \"**/\"\n            and len(args) == 4  # noqa E501\n            and all([args[0].is_leaf(), args[3].is_leaf()])\n            and not args[0].is_level()\n            and not args[0].is_flow()\n            and not args[0].is_stock()\n            and args[1].is_stock()\n            and args[2].is_level()\n            and not args[2].is_flow()\n            and not args[2].is_stock()\n            and args[3].is_level()\n            and not args[3].is_flow()\n            and not args[3].is_stock()\n        ):\n            return False\n        return args[2].is_leaf() or args[2].get_operations(expect_ops=True, copy_list=False)[0] == \"+\"\n\n    def _disaggregate(  # noqa: C901\n        self,\n        model: Model,\n        original_data: dict[str, Component | TimeVector | Curve | Expr],\n    ) -&gt; None:\n        \"\"\"Disaggregate HydroAggregator.\"\"\"\n        new_data = model.get_data()\n\n        deleted_group_names = self._get_deleted_group_modules(new_data)  # find agg groups that have been deleted\n        agg_modules = {key: new_data.pop(key) for key in self._grouped_modules if key not in deleted_group_names}  # isolate agg modules out of new_data\n\n        # Reinstate original detailed modules that are not fully deleted\n        for detailed_key, agg_keys in self._aggregation_map.items():\n            if agg_keys and all(key in deleted_group_names for key in agg_keys):\n                continue\n            new_data[detailed_key] = original_data[detailed_key]\n\n        # Set production results in detailed modules\n        for agg_key, detailed_keys in self._grouped_modules.items():\n            if agg_key in deleted_group_names:\n                continue\n\n            agg_production_level = agg_modules[agg_key].get_generator().get_production().get_level()\n            if agg_production_level is None:  # keep original production if agg has no production defined\n                continue\n            if len(detailed_keys) == 1:  # only one detailed module, set production directly\n                new_data[detailed_key].get_generator().get_production().set_level(agg_production_level)\n                continue\n            detailed_production_levels = [new_data[detailed_key].get_generator().get_production().get_level() for detailed_key in detailed_keys]\n            if any(detailed_production_levels) and not all(\n                detailed_production_levels,\n            ):  # if some but not all detailed modules have production defined, skip setting productio\n                missing = [detailed_key for detailed_key, level in zip(detailed_keys, detailed_production_levels, strict=False) if not level]\n                message = f\"Some but not all grouped modules have production defined. Production not disaggregated for {agg_key}, missing for {missing}.\"\n                self.send_warning_event(message)\n                continue\n            if _all_detailed_exprs_in_sum_expr(agg_production_level, detailed_production_levels):  # if agg production is sum of detailed levels,  keep original\n                continue\n            production_weights = self._get_disaggregation_production_weights(model, detailed_keys)  # default method\n            for detailed_key in detailed_keys:\n                self._set_weighted_production(new_data[detailed_key], agg_modules[agg_key], production_weights[detailed_key])\n\n        # Set filling results in detailed modules\n        for agg_key, detailed_keys in self._grouped_reservoirs.items():\n            if agg_key in deleted_group_names:\n                continue\n\n            agg_filling_level = agg_modules[agg_key].get_reservoir().get_volume().get_level()\n            if agg_filling_level is None:  # keep original filling if agg has no filling defined\n                continue\n            if len(detailed_keys) == 1:  # only one detailed module, set filling directly\n                new_data[detailed_key].get_reservoir().get_volume().set_level(agg_filling_level)\n                continue\n            detailed_filling_levels = [new_data[detailed_key].get_reservoir().get_volume().get_level() for detailed_key in detailed_keys]\n            if any(detailed_filling_levels) and not all(\n                detailed_filling_levels,\n            ):  # if some but not all detailed modules have filling defined, skip setting filling\n                missing = [detailed_key for detailed_key, level in zip(detailed_keys, detailed_filling_levels, strict=False) if not level]\n                message = f\"Some but not all grouped modules have filling defined. Filling not disaggregated for {agg_key}, missing for {missing}.\"\n                self.send_warning_event(message)\n                continue\n            detailed_energy_eq_downstreams = [new_data[detailed_key].get_meta(self._metakey_energy_eq_downstream).get_value() for detailed_key in detailed_keys]\n            agg_energy_eq_downstream = agg_modules[agg_key].get_meta(self._metakey_energy_eq_downstream).get_value()\n            agg_detailed_fillings = [\n                detailed_filling * detailed_energy_eq\n                for detailed_filling, detailed_energy_eq in zip(detailed_filling_levels, detailed_energy_eq_downstreams, strict=True)\n                if detailed_filling and detailed_energy_eq\n            ]\n            if self._is_sum_filling_expr(\n                agg_filling_level,\n                agg_detailed_fillings,\n                agg_energy_eq_downstream,\n            ):  # if agg filling is sum of detailed levels, keep original\n                continue\n            reservoir_weights = self._get_disaggregation_filling_weights(model, detailed_keys)  # default method\n            for detailed_key in detailed_keys:\n                self._set_weighted_filling(new_data[detailed_key], agg_modules[agg_key], reservoir_weights[detailed_key])\n\n        self._grouped_modules.clear()\n        self._grouped_reservoirs.clear()\n\n    def _get_deleted_group_modules(self, new_data: dict[str, Component | TimeVector | Curve | Expr]) -&gt; set[str]:\n        deleted_group_names: set[str] = set()\n\n        for group_name in self._grouped_modules:\n            if group_name not in new_data:\n                deleted_group_names.add(group_name)\n                continue\n\n        return deleted_group_names\n\n    def _get_disaggregation_production_weights(\n        self,\n        model: Model,\n        detailed_keys: list[str],\n    ) -&gt; dict[str, float]:\n        \"\"\"Get weights to disaggregate production based on production capacity.\"\"\"\n        # Calculate production capacity for each detailed module\n        data = model.get_data()\n        production_weights = dict()  # detailed_key -&gt; production_weight\n        production_weight_factors = dict()  # detailed_key -&gt; production_weight_factor\n        for det in detailed_keys:\n            det_module = data[det]\n            release_capacity_level = det_module.get_release_capacity().get_level()\n            generator_energy_eq = det_module.get_generator().get_energy_equivalent().get_level()\n            production_weight = get_level_value(\n                release_capacity_level * generator_energy_eq,\n                db=model,\n                unit=\"kW\",\n                data_dim=self._data_dim,\n                scen_dim=self._scen_dim,\n                is_max=False,\n            )\n            production_weights[det] = production_weight\n\n        # Calculate production weight for each detailed module\n        for det in detailed_keys:\n            production_weight_factors[det] = production_weights[det] / sum(production_weights.values())\n\n        return production_weight_factors\n\n    def _get_disaggregation_filling_weights(\n        self,\n        model: Model,\n        detailed_keys: list[str],\n    ) -&gt; dict[str, float]:\n        \"\"\"Get weights to disaggregate filling based on reservoir capacity.\"\"\"\n        # Calculate reservoir capacity for each detailed module\n        data = model.get_data()\n        filling_weights = dict()  # detailed_key -&gt; reservoir_weight\n        filling_weight_factors = dict()  # detailed_key -&gt; reservoir_weight_factor\n        for det in detailed_keys:\n            det_module = data[det]\n            reservoir_capacity_level = det_module.get_reservoir().get_capacity().get_level()\n            reservoir_energy_eq = det_module.get_meta(self._metakey_energy_eq_downstream).get_value()\n            reservoir_weight = get_level_value(\n                reservoir_capacity_level * reservoir_energy_eq,\n                db=model,\n                unit=\"GWh\",\n                data_dim=self._data_dim,\n                scen_dim=self._scen_dim,\n                is_max=False,\n            )\n            filling_weights[det] = reservoir_weight\n\n        # Calculate reservoir weight for each detailed module\n        for det in detailed_keys:\n            filling_weight_factors[det] = filling_weights[det] / sum(filling_weights.values())\n\n        return filling_weight_factors\n\n    def _set_weighted_production(self, detailed_module: HydroModule, agg_module: HydroModule, production_weight: float) -&gt; None:\n        \"\"\"Set production level and profile for detailed module based on aggregated module.\"\"\"\n        agg_production_level = agg_module.get_generator().get_production().get_level()\n        agg_production_profile = agg_module.get_generator().get_production().get_profile()\n        production_level = production_weight * agg_production_level\n        detailed_module.get_generator().get_production().set_level(production_level)\n        detailed_module.get_generator().get_production().set_profile(agg_production_profile)\n\n    def _is_sum_filling_expr(self, agg_filling: Expr, agg_detailed_fillings: list[Expr], agg_energy_eq_downstream: Expr) -&gt; bool:\n        \"\"\"Check if expr is (sum(filling * energy_eq_downstream)) / agg_energy_eq_downstream, indicating it comes from aggregation.\"\"\"\n        if agg_filling.is_leaf():\n            return False\n        ops, args = agg_filling.get_operations(expect_ops=True, copy_list=False)\n        if not (ops == \"/\" and len(args) == 2) and args[1] == agg_energy_eq_downstream:  # noqa E501\n            return False\n        ops_sum, args_sum = args[0].get_operations(expect_ops=True, copy_list=False)\n        if \"+\" not in ops_sum:\n            return False\n        if len(args_sum) != len(agg_detailed_fillings):\n            return False\n        return all(arg in agg_detailed_fillings for arg in args_sum)\n\n    def _set_weighted_filling(self, detailed_module: HydroModule, agg_module: HydroModule, filling_weight: float) -&gt; None:\n        \"\"\"Set filling level and profile for detailed module based on aggregated module.\"\"\"\n        agg_filling_level = agg_module.get_reservoir().get_volume().get_level()\n        agg_filling_profile = agg_module.get_reservoir().get_volume().get_profile()\n        if agg_filling_level:  # keep original filling if agg has no filling defined\n            agg_energy_eq = agg_module.get_meta(self._metakey_energy_eq_downstream).get_value()\n            detailed_energy_eq = detailed_module.get_meta(self._metakey_energy_eq_downstream).get_value()\n\n            filling_level = (filling_weight * agg_filling_level * agg_energy_eq) / detailed_energy_eq\n            detailed_module.get_reservoir().get_volume().set_level(filling_level)\n            detailed_module.get_reservoir().get_volume().set_profile(agg_filling_profile)\n</code></pre>"},{"location":"reference/#framcore.aggregators.HydroAggregator.HydroAggregator.__init__","title":"<code>__init__(metakey_energy_eq_downstream: str, data_dim: SinglePeriodTimeIndex, scen_dim: FixedFrequencyTimeIndex, ror_threshold: float = 0.5, metakey_power_node: str | None = None, power_node_members: list[str] | None = None, release_capacity_profile: TimeVector | None = None) -&gt; None</code>","text":"<p>Initialize HydroAggregator.</p> <p>Parameters:</p> Name Type Description Default <code>metakey_energy_eq_downstream</code> <code>str</code> <p>Metadata key for energy equivalent downstream. Can be calculated with framcore.utils.set_global_energy_equivalent</p> required <code>data_dim</code> <code>SinglePeriodTimeIndex</code> <p>Data dimension for eager evalutation.</p> required <code>scen_dim</code> <code>FixedFrequencyTimeIndex</code> <p>Scenario dimension for eager evalutation.</p> required <code>ror_threshold</code> <code>float</code> <p>Regulation factor (upstream reservoir capacity / yearly upstream inflow) threshold for run-of-river classification. Default is 0.5.</p> <code>0.5</code> <code>metakey_power_node</code> <code>str | None</code> <p>If given, check metadata of power nodes to check if they should be grouped.</p> <code>None</code> <code>power_node_members</code> <code>list[str] | None</code> <p>If given along with metakey_power_node, group modules only for power nodes with these metadata values. If given without metakey_power_node, only group power nodes in this list.</p> <code>None</code> <code>release_capacity_profile</code> <code>TimeVector | None</code> <p>If given, use this profile for all aggregated modules' release capacities.</p> <code>None</code> Source code in <code>framcore/aggregators/HydroAggregator.py</code> <pre><code>def __init__(\n    self,\n    metakey_energy_eq_downstream: str,\n    data_dim: SinglePeriodTimeIndex,\n    scen_dim: FixedFrequencyTimeIndex,\n    ror_threshold: float = 0.5,\n    metakey_power_node: str | None = None,\n    power_node_members: list[str] | None = None,\n    release_capacity_profile: TimeVector | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize HydroAggregator.\n\n    Args:\n        metakey_energy_eq_downstream (str): Metadata key for energy equivalent downstream.\n            Can be calculated with framcore.utils.set_global_energy_equivalent\n        data_dim (SinglePeriodTimeIndex): Data dimension for eager evalutation.\n        scen_dim (FixedFrequencyTimeIndex): Scenario dimension for eager evalutation.\n        ror_threshold (float): Regulation factor (upstream reservoir capacity / yearly upstream inflow) threshold for run-of-river classification.\n            Default is 0.5.\n        metakey_power_node (str | None): If given, check metadata of power nodes to check if they should be grouped.\n        power_node_members (list[str] | None): If given along with metakey_power_node, group modules only for power nodes with these metadata values.\n            If given without metakey_power_node, only group power nodes in this list.\n        release_capacity_profile (TimeVector | None): If given, use this profile for all aggregated modules' release capacities.\n\n    \"\"\"\n    super().__init__()\n    self._check_type(metakey_energy_eq_downstream, str)\n    self._check_type(ror_threshold, float)\n    self._check_type(data_dim, SinglePeriodTimeIndex)\n    self._check_type(scen_dim, FixedFrequencyTimeIndex)\n    self._check_type(metakey_power_node, (str, type(None)))\n    self._check_type(power_node_members, (list, type(None)))\n    if ror_threshold &lt; 0:\n        msg = f\"ror_threshold must be non-negative, got {ror_threshold}.\"\n        raise ValueError(msg)\n    if metakey_power_node is not None and len(power_node_members) &lt;= 0:\n        raise ValueError(\"If metakey_power_node is given, power_node_members must also be given.\")\n\n    self._metakey_energy_eq_downstream = metakey_energy_eq_downstream\n    self._ror_threshold = ror_threshold\n    self._metakey_power_node = metakey_power_node\n    self._power_node_members = power_node_members\n    self._release_capacity_profile = release_capacity_profile\n\n    self._data_dim = data_dim\n    self._scen_dim = scen_dim\n\n    self._grouped_modules: dict[str, set[str]] = defaultdict(list)  # agg to detailed\n    self._grouped_reservoirs: dict[str, set[str]] = defaultdict(list)  # agg to detailed\n</code></pre>"},{"location":"reference/#framcore.aggregators.NodeAggregator","title":"<code>NodeAggregator</code>","text":""},{"location":"reference/#framcore.aggregators.NodeAggregator.NodeAggregator","title":"<code>NodeAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> <p>Aggregate groups of Nodes for a commodity. Subclass of Aggregator.</p> <p>Aggregation steps (self._aggregate):</p> <ol> <li>Map all Components to their Nodes of the correct commodity if they are referencing any. This is important to redirect all references to the     new Nodes after aggregation.</li> <li>Create mapping of what members the new Nodes will be aggregated from. This step also does alot of error handling and checks the validity of the     metadata and groupings. Raises error if:<ul> <li>Nodes do not have any metadata for the meta key.</li> <li>Nodes have the wrong metadata object type for the meta key (must be Member).</li> <li>Exogenous Nodes are grouped together for aggregation with endogenous Nodes.</li> </ul> </li> <li>Initialize new Node objects and set prices and exogenous status. Prices are calculated as a weighted average of all the member Node prices.</li> <li>Old Nodes are deleted from the Model data, after which the aggregated Node is added, and references in the rest of the system are updated to point to     the new Node.</li> <li>Handling of transports: All Components which transport the same commodity as the aggregated Nodes are analysed. If the two Nodes they connect is now     the same aggregated Node, the transpart is 'internal' meaning it is now operating within a Node. If the transport Component is lossy, it is replaced     by a Demand Component representing the commodity consumption caused by the loss. All internal transports are afterwards deleted.</li> </ol> <p>Disaggregation steps (self._aggregate):</p> <ol> <li>Collect set of Nodes group keys for which have been either removed from the Model data or changed to reference something other than Nodes.</li> <li>Validate that IDs of Nodes to be restored have not been used to reference something else in the meantime.</li> <li>Delete the aggregated Nodes and restore the old Nodes to the Model. Also copy shadow price results from the aggregated Nodes to the disaggregated.     NB! This will overwrite the possible previous shadow prices of the original disaggregated Nodes.</li> <li>Restore the references in all objects to the disaggregated Nodes. A mapping created during aggregation is used for this.</li> <li>Validate that no restorable internal transports has a name conflict with existing objects in the Model.     NB! an internal transport is not restorable if one or both of its referenced Nodes have been removed from the Model or is now referencing another     object. See step 1.</li> <li>Restore all the restorable internal transports from the original data.</li> <li>Delete the aggregation-created Demand objects representing internal transports.</li> </ol> <p>See Aggregator for general design notes and rules to follow when using Aggregators.</p> Source code in <code>framcore/aggregators/NodeAggregator.py</code> <pre><code>class NodeAggregator(Aggregator):\n    \"\"\"\n    Aggregate groups of Nodes for a commodity. Subclass of Aggregator.\n\n    Aggregation steps (self._aggregate):\n\n    1. Map all Components to their Nodes of the correct commodity if they are referencing any. This is important to redirect all references to the\n        new Nodes after aggregation.\n    2. Create mapping of what members the new Nodes will be aggregated from. This step also does alot of error handling and checks the validity of the\n        metadata and groupings. Raises error if:\n        - Nodes do not have any metadata for the meta key.\n        - Nodes have the wrong metadata object type for the meta key (must be Member).\n        - Exogenous Nodes are grouped together for aggregation with endogenous Nodes.\n    3. Initialize new Node objects and set prices and exogenous status. Prices are calculated as a weighted average of all the member Node prices.\n    4. Old Nodes are deleted from the Model data, after which the aggregated Node is added, and references in the rest of the system are updated to point to\n        the new Node.\n    5. Handling of transports: All Components which transport the same commodity as the aggregated Nodes are analysed. If the two Nodes they connect is now\n        the same aggregated Node, the transpart is 'internal' meaning it is now operating within a Node. If the transport Component is lossy, it is replaced\n        by a Demand Component representing the commodity consumption caused by the loss. All internal transports are afterwards deleted.\n\n\n    Disaggregation steps (self._aggregate):\n\n    1. Collect set of Nodes group keys for which have been either removed from the Model data or changed to reference something other than Nodes.\n    2. Validate that IDs of Nodes to be restored have not been used to reference something else in the meantime.\n    3. Delete the aggregated Nodes and restore the old Nodes to the Model. Also copy shadow price results from the aggregated Nodes to the disaggregated.\n        NB! This will overwrite the possible previous shadow prices of the original disaggregated Nodes.\n    4. Restore the references in all objects to the disaggregated Nodes. A mapping created during aggregation is used for this.\n    5. Validate that no restorable internal transports has a name conflict with existing objects in the Model.\n        NB! an internal transport is not restorable if one or both of its referenced Nodes have been removed from the Model or is now referencing another\n        object. See step 1.\n    6. Restore all the restorable internal transports from the original data.\n    7. Delete the aggregation-created Demand objects representing internal transports.\n\n    See Aggregator for general design notes and rules to follow when using Aggregators.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        commodity: str,\n        meta_key: str,\n        data_dim: SinglePeriodTimeIndex,\n        scen_dim: FixedFrequencyTimeIndex,\n        utilization_rate: float = 0.5,\n    ) -&gt; None:\n        \"\"\"\n        Aggregate groups of nodes (defined by metadata key) for a commodity.\n\n        Args:\n            commodity (str): Commodity of the Nodes to be aggregated.\n            meta_key (str): _description_\n            data_dim (SinglePeriodTimeIndex): Data dimension for eager evalutation of prices.\n            scen_dim (FixedFrequencyTimeIndex): Scenario dimension for eager evalutation of prices.\n            utilization_rate (float, optional): Assumed utilization rate on internal transports. Used to calculate new Demands after aggregation\n                                                          if the transport does not have a volume.\n                                                          Defaults to 0.5 (i.e. 50 percent utilization in each direction).\n\n        \"\"\"\n        super().__init__()\n        self._commodity = commodity\n        self._meta_key = meta_key\n        self._data_dim = data_dim\n        self._scen_dim = scen_dim\n        self._utilization_rate = utilization_rate\n\n        # To remember all modifications in _aggregate so we can undo them in _disaggregate\n        # Will be cleared in _init_aggregate, so that same memory can be re-used.\n        self._grouped_nodes: dict[str, set[str]] = defaultdict(set)\n        self._replaced_references: dict[str, set[tuple[str, str]]] = defaultdict(set)  # dict with controll of all nodes which have been replaced\n        self._internal_transports: set[str] = set()\n        self._internal_transport_demands: set[str] = set()\n\n        # To record error messages in _aggregate and _disaggregate\n        # Will be cleared in _init_aggregate and _init_disaggregate,\n        # so that same memory can be re-used.\n        self._errors: set[str] = set()\n\n    def _aggregate(self, model: Model) -&gt; None:\n        \"\"\"Modify model, components and data.\"\"\"\n        t0 = time()\n        # Will be modified by upcoming code by adding group_nodes\n        # and deleting member_nodes and redundant transports.\n        data = model.get_data()\n\n        # Helper-dict to give simpler access to components in upcoming loops\n        # The components are the same instances as in data, and upcoming code\n        # will use this to modify components inplace, in self._replace_node.\n        components: dict[str, Component] = {key: c for key, c in data.items() if isinstance(c, Component)}\n\n        # This is just a helper-dict to give fast access\n        component_to_nodes: dict[str, set[str]] = get_component_to_nodes(components)\n\n        self._init_aggregate(components, data)\n        self.send_debug_event(f\"init time {round(time() - t0, 3)} seconds\")\n\n        # main logic\n        t = time()\n        for group_name, member_node_names in self._grouped_nodes.items():\n            member_node_names: set[str]\n            group_node = Node(commodity=self._commodity)\n            self._set_group_price(model, group_node, member_node_names, \"EUR/MWh\")\n            self._delete_members(data, member_node_names)\n\n            assert group_name not in data, f\"{group_name}\"\n            data[group_name] = group_node\n\n            self._replace_node(group_name, member_node_names, components, component_to_nodes)\n            components[group_name] = group_node\n        self.send_debug_event(f\"main logic time {round(time() - t, 3)} seconds\")\n\n        t = time()\n        transports = get_transports_by_commodity(components, self._commodity)\n        self._update_internal_transports(transports)\n        self._delete_internal_transports(data)\n        self._add_internal_transport_demands(model, components, transports)\n        self.send_debug_event(f\"handle internal transport losses time {round(time() - t, 3)} seconds\")\n\n        self.send_debug_event(f\"total time {round(time() - t0, 3)} seconds\")\n\n    def _update_internal_transports(\n        self,\n        transports: dict[str, tuple[str, str]],\n    ) -&gt; None:\n        for name, (from_node, to_node) in transports.items():\n            if from_node == to_node:\n                # if not, then invalid transport from before\n                assert to_node in self._grouped_nodes\n\n                # earlier to_node was added here, but it should be the transport name, right?\n                self._internal_transports.add(name)\n\n    def _get_demand_member_meta_keys(self, components: dict[str, Component]) -&gt; set[str]:\n        \"\"\"We find all direct_out demands via flows from get_supported_components and collect member meta keys from them.\"\"\"\n        out: set[str] = set()\n        nodes_and_flows = get_supported_components(components, supported_types=(Node, Flow), forbidden_types=tuple())\n        node_to_commodity = get_node_to_commodity(nodes_and_flows)\n        for flow in nodes_and_flows.values():\n            if not isinstance(flow, Flow):\n                continue\n            flow_infos = get_flow_infos(flow, node_to_commodity)\n            if len(flow_infos) != 1:\n                continue\n            flow_info = flow_infos[0]\n            if flow_info.category != \"direct_out\":\n                continue\n            if flow_info.commodity_out != self._commodity:\n                continue\n            demand = flow\n            for key in demand.get_meta_keys():\n                meta = demand.get_meta(key)\n                if isinstance(meta, Member):\n                    out.add(key)\n        return out\n\n    def _add_internal_transport_demands(\n        self,\n        model: Model,\n        components: dict[str, Component],\n        transports: dict[str, tuple[str, str]],\n    ) -&gt; None:\n        \"\"\"\n        Add demand representing loss on internal transmission lines being removed by aggregation.\n\n        This is done to avoid underestimation of aggregated demand.\n        \"\"\"\n        data = model.get_data()\n\n        demand_member_meta_keys = self._get_demand_member_meta_keys(components)\n\n        # TODO: Document that we rely on Transmission and Demand APIs to get loss\n        for key in self._internal_transports:\n            transport = components[key]\n            from_node, to_node = transports[key]\n            assert from_node == to_node, (\n                f\"Transport {key} added to internal transport when it should not. Source node {from_node}, and destination node {to_node} are not the same.\"\n            )\n            node = from_node\n\n            transport: Transmission\n\n            if transport.get_loss():\n                profile = None\n                loss = transport.get_loss()\n                if loss.get_level() is None:\n                    continue\n                if transport.get_outgoing_volume().get_level():\n                    level = transport.get_outgoing_volume().get_level() * loss.get_level()\n\n                    # could multiply by loss profile here, but profile * profile is not yet supported so we wait.\n                    profile = transport.get_outgoing_volume().get_profile()\n\n                # elif exploitation factor at individual level. How to best access this?\n                else:\n                    level = transport.get_max_capacity().get_level() * self._utilization_rate * loss.get_level()\n                    profile = loss.get_profile()\n\n                internal_losses_demand = Demand(\n                    node=node,\n                    capacity=MaxFlowVolume(\n                        level=level,\n                        profile=profile,\n                    ),\n                )\n\n                for meta_key in demand_member_meta_keys:  # transfer member metadata to internal loss Demand\n                    internal_losses_demand.add_meta(meta_key, Member(\"InternalTransportLossFromNodeAggregator\"))\n\n                demand_key = key + \"_InternalTransportLossDemand_\" + node\n\n                self._internal_transport_demands.add(demand_key)\n                if demand_key in data:\n                    msg = f\"Could not use key {demand_key} for internal transport demand because it already exists in the Model.\"\n                    raise KeyError(msg)\n                data[demand_key] = internal_losses_demand\n\n    def _delete_internal_transports(\n        self,\n        data: dict[str, Component | TimeVector | Curve | Expr],\n    ) -&gt; None:\n        for key in self._internal_transports:\n            self._aggregation_map[key] = set()\n            del data[key]\n\n    def _delete_members(\n        self,\n        data: dict[str, Component | TimeVector | Curve | Expr],\n        member_node_names: set[str],\n    ) -&gt; None:\n        for member in member_node_names:\n            del data[member]\n\n    def _set_group_price(\n        self,\n        model: Model,\n        group_node: Node,\n        member_node_names: set[str],\n        weight_unit: str,\n    ) -&gt; None:\n        data = model.get_data()\n        weights = [1.0 / len(member_node_names)] * len(member_node_names)\n        prices = [data[key].get_price() for key in member_node_names]\n\n        exogenous = [data[key].is_exogenous() for key in member_node_names]\n        if all(exogenous):\n            group_node.set_exogenous()\n        elif any(exogenous):\n            message = f\"Only some member Nodes of group {group_node} are exogenous. This is ambiguous. Either all or none must be exogenous.\"\n            raise ValueError(message)\n        if all(prices):\n            level, profile, intercept = _aggregate_costs(\n                model=model,\n                costs=prices,\n                weights=weights,\n                weight_unit=weight_unit,\n                data_dim=self._data_dim,\n                scen_dim=self._scen_dim,\n            )\n            group_node.get_price().set_level(level)\n            group_node.get_price().set_profile(profile)\n            group_node.get_price().set_intercept(intercept)\n        elif any(prices):\n            missing = [key for key in member_node_names if data[key].get_price() is None]\n            self.send_warning_event(f\"Only some member Nodes of group {group_node} have a Price, skip aggregate prices. Missing: {missing}\")\n\n    def _replace_node(\n        self,\n        group_name: str,\n        member_node_names: set[str],\n        components: dict[str, Component],\n        component_to_nodes: dict[str, set[str]],\n    ) -&gt; None:\n        for name, component in components.items():\n            replace_keys = component_to_nodes[name]\n            for key in member_node_names:\n                if key in replace_keys:\n                    component.replace_node(key, group_name)\n                    self._replaced_references[name].add((key, group_name))\n\n    def _init_aggregate(  # noqa C901\n        self,\n        components: dict[str, Component],\n        data: dict[str, Component | TimeVector | Curve | Expr],\n    ) -&gt; None:\n        self._grouped_nodes.clear()\n        self._internal_transports.clear()\n        self._internal_transport_demands.clear()\n        self._errors.clear()\n\n        self._aggregation_map = defaultdict(set)\n\n        exogenous_groups = set()\n\n        meta_key = self._meta_key\n\n        for key, component in components.items():\n            if not isinstance(component, Node):\n                self._aggregation_map[key].add(key)\n                continue\n\n            node: Node = component\n\n            commodity = node.get_commodity()\n\n            if self._commodity != commodity:\n                self._aggregation_map[key].add(key)\n                continue\n\n            meta: Meta | None = node.get_meta(meta_key)\n\n            if meta is None:\n                self._errors.add(f\"Node {key} had no metadata behind key {meta_key}.\")\n                continue\n\n            meta: Meta\n\n            if not isinstance(meta, Member):\n                got = type(meta).__name__\n                message = f\"Node {key} has metadata behind key {meta_key} with wrong type. Expected Member, got {got}.\"\n                self._errors.add(message)\n                continue\n\n            meta: Member\n\n            group_name: str = meta.get_value()\n\n            if node.is_exogenous():\n                # register groups with exogenous Nodes to validate later.\n                exogenous_groups.add(group_name)\n\n            if not self._errors:\n                self._aggregation_map[key].add(group_name)\n                self._grouped_nodes[group_name].add(key)\n\n        grouped_nodes = self._grouped_nodes.copy()\n\n        for group_name in exogenous_groups:  # Check exogenous groups.\n            node_keys = grouped_nodes[group_name]\n            if len(node_keys) &gt; 1:  # allow unchanged or renamed exogenous Nodes.\n                # We allow pure exogenous groups.\n                exogenous = [components[node_key].is_exogenous() for node_key in node_keys]\n                if (not all(exogenous)) and any(exogenous):\n                    self._errors.add(f\"Group {group_name} contains both exogenous and endogenous Nodes. This is ambiguous and therefore not allowed.\")\n\n        # remove single groups with unchanged names and check for duplicated names\n        for group_name, node_keys in grouped_nodes.items():\n            if len(node_keys) == 1 and group_name == next(iter(node_keys)):\n                del self._grouped_nodes[group_name]\n            try:  # If group name already exists for a node and the existing node is not aggregated to a new one.\n                meta = data[group_name].get_meta(meta_key)\n                if meta is None or meta.get_value() is None:\n                    self._errors.add(\n                        f\"Metadata name for aggregated node ({group_name}) already exists in the model: {data[group_name]}\",\n                    )\n            except KeyError:\n                pass\n\n        self._check_uniqueness()\n        self._report_errors(self._errors)\n\n    def _report_errors(self, errors: set[str]) -&gt; None:\n        if errors:\n            n = len(errors)\n            s = \"s\" if n &gt; 1 else \"\"\n            error_str = \"\\n\".join(errors)\n            message = f\"Found {n} error{s}:\\n{error_str}\"\n            raise RuntimeError(message)\n\n    def _check_uniqueness(self) -&gt; None:\n        flipped = defaultdict(set)\n        for group, members in self._grouped_nodes.items():\n            for member in members:\n                flipped[member].add(group)\n        for k, v in flipped.items():\n            if len(v) &gt; 1:\n                self._errors.add(f\"Node {k} belongs to more than one group {v}\")\n\n    def _disaggregate(\n        self,\n        model: Model,\n        original_data: dict[str, Component | TimeVector | Curve | Expr],\n    ) -&gt; None:\n        new_data = model.get_data()\n\n        deleted_group_names: set[str] = self._init_disaggregate(new_data)\n\n        self._validate_restore_nodes(new_data, deleted_group_names)\n        self._restore_nodes(new_data, original_data, deleted_group_names)\n        self._restore_references(new_data)\n\n        restorable_transports = self._validate_restore_internal_transports(new_data, original_data, deleted_group_names)\n        self._restore_internal_transports(new_data, original_data, restorable_transports)\n\n        self._delete_internal_transport_demands(new_data)\n\n    def _init_disaggregate(\n        self,\n        new_data: dict[str, Component | TimeVector | Curve | Expr],\n    ) -&gt; set[str]:\n        self._errors.clear()\n        deleted_group_names: set[str] = set()\n\n        for group_name in self._grouped_nodes:\n            if group_name not in new_data:\n                deleted_group_names.add(group_name)\n                continue\n\n            group_node = new_data[group_name]\n\n            if not (isinstance(group_node, Node) and group_node.get_commodity() == self._commodity):\n                deleted_group_names.add(group_name)\n\n        return deleted_group_names\n\n    def _validate_restore_nodes(\n        self,\n        new_data: dict[str, Component | TimeVector | Curve | Expr],\n        deleted_group_names: set[str],\n    ) -&gt; None:\n        for group_name, member_node_names in self._grouped_nodes.items():\n            if group_name in deleted_group_names:\n                continue\n            for key in member_node_names:\n                if key in new_data:\n                    obj = new_data[key]\n                    if not (isinstance(obj, Node) and obj.get_commodity() == self._commodity):\n                        typ = type(obj).__name__\n                        message = f\"Restoring node {key} from group node {group_name} failed because model already stores object of {typ} with that name.\"\n                        self._errors.add(message)\n        self._report_errors(self._errors)\n\n    def _restore_nodes(\n        self,\n        new_data: dict[str, Component | TimeVector | Curve | Expr],\n        original_data: dict[str, Component | TimeVector | Curve | Expr],\n        deleted_group_names: set[str],\n    ) -&gt; None:\n        for group_name, member_node_names in self._grouped_nodes.items():\n            if group_name in deleted_group_names:\n                continue\n\n            group_node: Node = new_data.pop(group_name)\n\n            group_price: Price | None = group_node.get_price()\n\n            for key in member_node_names:\n                original_node: Node = original_data[key]\n                if group_price is not None:\n                    original_price = original_node.get_price()\n                    original_price.copy_from(group_price)\n                new_data[key] = original_node\n\n    def _validate_restore_internal_transports(\n        self,\n        new_data: dict[str, Component | TimeVector | Curve | Expr],\n        original_data: dict[str, Component | TimeVector | Curve | Expr],\n        deleted_group_names: set[str],\n    ) -&gt; set[str]:\n        nodes_not_added_back: set[str] = set()\n        restorable_transports: set[str] = set()\n\n        components = {k: v for k, v in original_data.items() if isinstance(v, Component)}\n        transports = get_transports_by_commodity(components, self._commodity)\n\n        for group_name, member_node_names in self._grouped_nodes.items():\n            if group_name in deleted_group_names:\n                nodes_not_added_back.update(member_node_names)\n                continue\n\n        for key in self._internal_transports:\n            from_node, to_node = transports[key]\n\n            if (from_node in nodes_not_added_back) and (to_node in nodes_not_added_back):\n                continue\n\n            restorable_transports.add(key)\n            if key in new_data:\n                obj = new_data[key]\n                typ = type(obj).__name__\n                message = f\"Restoring deleted transport {key} from group node {group_name} failed because model already stores object of {typ} with that name.\"\n                self._errors.add(message)\n\n        self._report_errors(self._errors)\n\n        return restorable_transports\n\n    def _restore_internal_transports(\n        self,\n        new_data: dict[str, Component | TimeVector | Curve | Expr],\n        original_data: dict[str, Component | TimeVector | Curve | Expr],\n        restorable_transports: set[str],\n    ) -&gt; None:\n        for key in self._internal_transports:\n            if key not in restorable_transports:\n                continue\n            transport = original_data[key]\n            new_data[key] = transport\n\n    def _delete_internal_transport_demands(self, new_data: dict[str, Component | TimeVector | Curve | Expr]) -&gt; None:\n        for key in self._internal_transport_demands:\n            new_data.pop(key, None)\n\n    def _restore_references(self, new_data: dict[str, Component | TimeVector | Curve | Expr]) -&gt; None:\n        for component_name, replacements in self._replaced_references.items():\n            # internal transports are handled by themselves.\n            if component_name in new_data and component_name not in self._internal_transports and isinstance(new_data[component_name], Component):\n                for replacement in replacements:\n                    disaggregated, group_name = replacement\n                    new_data[component_name].replace_node(old=group_name, new=disaggregated)  # set the disaggregated node back in the component.\n</code></pre>"},{"location":"reference/#framcore.aggregators.NodeAggregator.NodeAggregator.__init__","title":"<code>__init__(commodity: str, meta_key: str, data_dim: SinglePeriodTimeIndex, scen_dim: FixedFrequencyTimeIndex, utilization_rate: float = 0.5) -&gt; None</code>","text":"<p>Aggregate groups of nodes (defined by metadata key) for a commodity.</p> <p>Parameters:</p> Name Type Description Default <code>commodity</code> <code>str</code> <p>Commodity of the Nodes to be aggregated.</p> required <code>meta_key</code> <code>str</code> <p>description</p> required <code>data_dim</code> <code>SinglePeriodTimeIndex</code> <p>Data dimension for eager evalutation of prices.</p> required <code>scen_dim</code> <code>FixedFrequencyTimeIndex</code> <p>Scenario dimension for eager evalutation of prices.</p> required <code>utilization_rate</code> <code>float</code> <p>Assumed utilization rate on internal transports. Used to calculate new Demands after aggregation                                           if the transport does not have a volume.                                           Defaults to 0.5 (i.e. 50 percent utilization in each direction).</p> <code>0.5</code> Source code in <code>framcore/aggregators/NodeAggregator.py</code> <pre><code>def __init__(\n    self,\n    commodity: str,\n    meta_key: str,\n    data_dim: SinglePeriodTimeIndex,\n    scen_dim: FixedFrequencyTimeIndex,\n    utilization_rate: float = 0.5,\n) -&gt; None:\n    \"\"\"\n    Aggregate groups of nodes (defined by metadata key) for a commodity.\n\n    Args:\n        commodity (str): Commodity of the Nodes to be aggregated.\n        meta_key (str): _description_\n        data_dim (SinglePeriodTimeIndex): Data dimension for eager evalutation of prices.\n        scen_dim (FixedFrequencyTimeIndex): Scenario dimension for eager evalutation of prices.\n        utilization_rate (float, optional): Assumed utilization rate on internal transports. Used to calculate new Demands after aggregation\n                                                      if the transport does not have a volume.\n                                                      Defaults to 0.5 (i.e. 50 percent utilization in each direction).\n\n    \"\"\"\n    super().__init__()\n    self._commodity = commodity\n    self._meta_key = meta_key\n    self._data_dim = data_dim\n    self._scen_dim = scen_dim\n    self._utilization_rate = utilization_rate\n\n    # To remember all modifications in _aggregate so we can undo them in _disaggregate\n    # Will be cleared in _init_aggregate, so that same memory can be re-used.\n    self._grouped_nodes: dict[str, set[str]] = defaultdict(set)\n    self._replaced_references: dict[str, set[tuple[str, str]]] = defaultdict(set)  # dict with controll of all nodes which have been replaced\n    self._internal_transports: set[str] = set()\n    self._internal_transport_demands: set[str] = set()\n\n    # To record error messages in _aggregate and _disaggregate\n    # Will be cleared in _init_aggregate and _init_disaggregate,\n    # so that same memory can be re-used.\n    self._errors: set[str] = set()\n</code></pre>"},{"location":"reference/#framcore.aggregators.WindSolarAggregator","title":"<code>WindSolarAggregator</code>","text":""},{"location":"reference/#framcore.aggregators.WindSolarAggregator.SolarAggregator","title":"<code>SolarAggregator</code>","text":"<p>               Bases: <code>_WindSolarAggregator</code></p> <p>Aggregate Solar components into groups based on their power nodes.</p> <p>Aggregation steps (self._aggregate):</p> <ol> <li>Group components based on their power nodes (self._group_by_power_node):</li> <li>Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):<ul> <li>Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.</li> <li>Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).</li> <li>TODO: Add support for additional weighting methods (e.g. production instead of capacity).</li> <li>Production is aggregated as the sum of production levels with weighted profiles. 2a. Make new hydro module and delete original components from model data.</li> </ul> </li> <li>Add mapping from detailed to aggregated components to self._aggregation_map.</li> </ol> <p>Disaggregation steps (self._disaggregate):</p> <ol> <li>Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.</li> <li>Distribute production from aggregated components back to the original components:<ul> <li>Results are weighted based on the weighting method (now ony max_capacity supported).</li> </ul> </li> <li>Delete aggregated components from the model.</li> </ol> <p>See Aggregator for general design notes and rules to follow when using Aggregators.</p> <p>Attributes:</p> Name Type Description <code>_data_dim</code> <code>SinglePeriodTimeIndex | None</code> <p>Data dimension for eager evaluation.</p> <code>_scen_dim</code> <code>FixedFrequencyTimeIndex | None</code> <p>Scenario dimension for eager evaluation.</p> <code>_grouped_components</code> <code>dict[str, set[str]]</code> <p>Mapping of aggregated components to their detailed components.  agg to detailed</p> <p>Parent Attributes (see framcore.aggregators.Aggregator):</p> <pre><code>_is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n_original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n_aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n</code></pre> Source code in <code>framcore/aggregators/WindSolarAggregator.py</code> <pre><code>class SolarAggregator(_WindSolarAggregator):\n    \"\"\"\n    Aggregate Solar components into groups based on their power nodes.\n\n    Aggregation steps (self._aggregate):\n\n    1. Group components based on their power nodes (self._group_by_power_node):\n    2. Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):\n        - Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.\n        - Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).\n        - TODO: Add support for additional weighting methods (e.g. production instead of capacity).\n        - Production is aggregated as the sum of production levels with weighted profiles.\n    2a. Make new hydro module and delete original components from model data.\n    3. Add mapping from detailed to aggregated components to self._aggregation_map.\n\n\n    Disaggregation steps (self._disaggregate):\n\n    1. Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.\n    2. Distribute production from aggregated components back to the original components:\n        - Results are weighted based on the weighting method (now ony max_capacity supported).\n    3. Delete aggregated components from the model.\n\n\n    See Aggregator for general design notes and rules to follow when using Aggregators.\n\n    Attributes:\n        _data_dim (SinglePeriodTimeIndex | None): Data dimension for eager evaluation.\n        _scen_dim (FixedFrequencyTimeIndex | None): Scenario dimension for eager evaluation.\n        _grouped_components (dict[str, set[str]]): Mapping of aggregated components to their detailed components.  agg to detailed\n\n\n    Parent Attributes (see framcore.aggregators.Aggregator):\n\n        _is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n        _original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n        _aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n\n    \"\"\"\n\n    _component_type = Solar\n</code></pre>"},{"location":"reference/#framcore.aggregators.WindSolarAggregator.WindAggregator","title":"<code>WindAggregator</code>","text":"<p>               Bases: <code>_WindSolarAggregator</code></p> <p>Aggregate Wind components into groups based on their power nodes.</p> <p>Aggregation steps (self._aggregate):</p> <ol> <li>Group components based on their power nodes (self._group_by_power_node):</li> <li>Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):<ul> <li>Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.</li> <li>Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).</li> <li>TODO: Add support for additional weighting methods (e.g. production instead of capacity).</li> <li>Production is aggregated as the sum of production levels with weighted profiles. 2a. Make new hydro module and delete original components from model data.</li> </ul> </li> <li>Add mapping from detailed to aggregated components to self._aggregation_map.</li> </ol> <p>Disaggregation steps (self._disaggregate):</p> <ol> <li>Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.</li> <li>Distribute production from aggregated components back to the original components:<ul> <li>Results are weighted based on the weighting method (now ony max_capacity supported).</li> </ul> </li> <li>Delete aggregated components from the model.</li> </ol> <p>See Aggregator for general design notes and rules to follow when using Aggregators.</p> <p>Attributes:</p> Name Type Description <code>_data_dim</code> <code>SinglePeriodTimeIndex | None</code> <p>Data dimension for eager evaluation.</p> <code>_scen_dim</code> <code>FixedFrequencyTimeIndex | None</code> <p>Scenario dimension for eager evaluation.</p> <code>_grouped_components</code> <code>dict[str, set[str]]</code> <p>Mapping of aggregated components to their detailed components.  agg to detailed</p> <p>Parent Attributes (see framcore.aggregators.Aggregator):</p> <pre><code>_is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n_original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n_aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n</code></pre> Source code in <code>framcore/aggregators/WindSolarAggregator.py</code> <pre><code>class WindAggregator(_WindSolarAggregator):\n    \"\"\"\n    Aggregate Wind components into groups based on their power nodes.\n\n    Aggregation steps (self._aggregate):\n\n    1. Group components based on their power nodes (self._group_by_power_node):\n    2. Aggregate grouped components into a single aggregated component for each group (self._aggregate_groups):\n        - Max_capacity is calculated as the sum of the maximum capacity levels with weighted profiles.\n        - Variable operation costs (voc) are aggregated using weighted averages based on the weighting method (now ony max_capacity supported).\n        - TODO: Add support for additional weighting methods (e.g. production instead of capacity).\n        - Production is aggregated as the sum of production levels with weighted profiles.\n    2a. Make new hydro module and delete original components from model data.\n    3. Add mapping from detailed to aggregated components to self._aggregation_map.\n\n\n    Disaggregation steps (self._disaggregate):\n\n    1. Restore original components from self._original_data. NB! Changes to aggregated modules are lost except for results.\n    2. Distribute production from aggregated components back to the original components:\n        - Results are weighted based on the weighting method (now ony max_capacity supported).\n    3. Delete aggregated components from the model.\n\n\n    See Aggregator for general design notes and rules to follow when using Aggregators.\n\n    Attributes:\n        _data_dim (SinglePeriodTimeIndex | None): Data dimension for eager evaluation.\n        _scen_dim (FixedFrequencyTimeIndex | None): Scenario dimension for eager evaluation.\n        _grouped_components (dict[str, set[str]]): Mapping of aggregated components to their detailed components.  agg to detailed\n\n\n    Parent Attributes (see framcore.aggregators.Aggregator):\n\n        _is_last_call_aggregate (bool | None): Tracks whether the last operation was an aggregation.\n        _original_data (dict[str, Component | TimeVector | Curve | Expr] | None): Original detailed data before aggregation.\n        _aggregation_map (dict[str, set[str]] | None): Maps aggregated components to their detailed components. detailed to agg\n\n    \"\"\"\n\n    _component_type = Wind\n</code></pre>"},{"location":"reference/#framcore.attributes","title":"<code>attributes</code>","text":""},{"location":"reference/#framcore.attributes.AvgFlowVolume","title":"<code>AvgFlowVolume</code>","text":"<p>               Bases: <code>FlowVolume</code></p> <p>Concrete class representing an average flow volume attribute, indicating a flow variable with average values.</p> <p>Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class AvgFlowVolume(FlowVolume):\n    \"\"\"\n    Concrete class representing an average flow volume attribute, indicating a flow variable with average values.\n\n    Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.Coefficient","title":"<code>Coefficient</code>","text":"<p>               Bases: <code>LevelProfile</code></p> <p>Abstract class representing a coefficient attribute, used as a base class for various coefficient types.</p> <p>Subclass of LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Coefficient(LevelProfile):\n    \"\"\"\n    Abstract class representing a coefficient attribute, used as a base class for various coefficient types.\n\n    Subclass of LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#framcore.attributes.Conversion","title":"<code>Conversion</code>","text":"<p>               Bases: <code>ArrowCoefficient</code></p> <p>Concrete class representing a conversion coefficient attribute, used for conversion factors in the model.</p> <p>Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Conversion(ArrowCoefficient):\n    \"\"\"\n    Concrete class representing a conversion coefficient attribute, used for conversion factors in the model.\n\n    Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.Cost","title":"<code>Cost</code>","text":"<p>               Bases: <code>ObjectiveCoefficient</code></p> <p>Concrete class representing a cost attribute, indicating cost coefficients in the objective function.</p> <p>Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Cost(ObjectiveCoefficient):\n    \"\"\"\n    Concrete class representing a cost attribute, indicating cost coefficients in the objective function.\n\n    Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_COST = True\n</code></pre>"},{"location":"reference/#framcore.attributes.Efficiency","title":"<code>Efficiency</code>","text":"<p>               Bases: <code>ArrowCoefficient</code></p> <p>Concrete class representing an efficiency coefficient attribute, indicating a unitless coefficient.</p> <p>Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Efficiency(ArrowCoefficient):\n    \"\"\"\n    Concrete class representing an efficiency coefficient attribute, indicating a unitless coefficient.\n\n    Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.Elasticity","title":"<code>Elasticity</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Concrete class representing an elasticity coefficient attribute, indicating a unitless coefficient.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Elasticity(Coefficient):  # TODO: How do this work?\n    \"\"\"\n    Concrete class representing an elasticity coefficient attribute, indicating a unitless coefficient.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.FlowVolume","title":"<code>FlowVolume</code>","text":"<p>               Bases: <code>LevelProfile</code></p> <p>Abstract class representing a flow volume attribute, indicating that the attribute is a flow variable.</p> <p>Subclass of LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class FlowVolume(LevelProfile):\n    \"\"\"\n    Abstract class representing a flow volume attribute, indicating that the attribute is a flow variable.\n\n    Subclass of LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_FLOW = True\n</code></pre>"},{"location":"reference/#framcore.attributes.Hours","title":"<code>Hours</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Concrete class representing an hours coefficient attribute, indicating a time-related coefficient.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Hours(Coefficient):  # TODO: How do this work?\n    \"\"\"\n    Concrete class representing an hours coefficient attribute, indicating a time-related coefficient.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroBypass","title":"<code>HydroBypass</code>","text":"<p>               Bases: <code>Base</code></p> <p>HydroBypass represents a controlled water way from a HydroModule. Used to bypass main release of the HydroModule.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>class HydroBypass(Base):\n    \"\"\"HydroBypass represents a controlled water way from a HydroModule. Used to bypass main release of the HydroModule.\"\"\"\n\n    def __init__(\n        self,\n        to_module: str | None,\n        capacity: FlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize object.\n\n        Args:\n            to_module (str | None): Name of the HydroModule the water is released to.\n            capacity (FlowVolume | None, optional): Restrictions on the volume of water which can pass through the bypass at a given moment. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n\n        self._check_type(to_module, (str, type(None)))\n        self._check_type(capacity, (FlowVolume, type(None)))\n\n        self._to_module = to_module\n        self._capacity = capacity\n        self._volume = AvgFlowVolume()\n\n    def get_to_module(self) -&gt; str | None:\n        \"\"\"Get the name of the module to which the bypass leads.\"\"\"\n        return self._to_module\n\n    def set_to_module(self, to_module: str) -&gt; None:\n        \"\"\"Set the name of the module to which the bypass leads.\"\"\"\n        self._check_type(to_module, str)\n        self._to_module = to_module\n\n    def get_capacity(self) -&gt; FlowVolume | None:\n        \"\"\"Get the capacity of the bypass.\"\"\"\n        return self._capacity\n\n    def get_volume(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the volume of the bypass.\"\"\"\n        return self._volume\n\n    def _get_fingerprint(self) -&gt; Fingerprint:\n        return self.get_fingerprint_default(refs={\"to_module\": self._to_module})\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroBypass.__init__","title":"<code>__init__(to_module: str | None, capacity: FlowVolume | None = None) -&gt; None</code>","text":"<p>Initialize object.</p> <p>Parameters:</p> Name Type Description Default <code>to_module</code> <code>str | None</code> <p>Name of the HydroModule the water is released to.</p> required <code>capacity</code> <code>FlowVolume | None</code> <p>Restrictions on the volume of water which can pass through the bypass at a given moment. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def __init__(\n    self,\n    to_module: str | None,\n    capacity: FlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize object.\n\n    Args:\n        to_module (str | None): Name of the HydroModule the water is released to.\n        capacity (FlowVolume | None, optional): Restrictions on the volume of water which can pass through the bypass at a given moment. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n\n    self._check_type(to_module, (str, type(None)))\n    self._check_type(capacity, (FlowVolume, type(None)))\n\n    self._to_module = to_module\n    self._capacity = capacity\n    self._volume = AvgFlowVolume()\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroBypass.get_capacity","title":"<code>get_capacity() -&gt; FlowVolume | None</code>","text":"<p>Get the capacity of the bypass.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def get_capacity(self) -&gt; FlowVolume | None:\n    \"\"\"Get the capacity of the bypass.\"\"\"\n    return self._capacity\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroBypass.get_to_module","title":"<code>get_to_module() -&gt; str | None</code>","text":"<p>Get the name of the module to which the bypass leads.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def get_to_module(self) -&gt; str | None:\n    \"\"\"Get the name of the module to which the bypass leads.\"\"\"\n    return self._to_module\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroBypass.get_volume","title":"<code>get_volume() -&gt; AvgFlowVolume</code>","text":"<p>Get the volume of the bypass.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def get_volume(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the volume of the bypass.\"\"\"\n    return self._volume\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroBypass.set_to_module","title":"<code>set_to_module(to_module: str) -&gt; None</code>","text":"<p>Set the name of the module to which the bypass leads.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def set_to_module(self, to_module: str) -&gt; None:\n    \"\"\"Set the name of the module to which the bypass leads.\"\"\"\n    self._check_type(to_module, str)\n    self._to_module = to_module\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator","title":"<code>HydroGenerator</code>","text":"<p>               Bases: <code>Base</code></p> <p>Produces power from the main release of a HydroModule.</p> <p>Produces to a power node, and can have variable costs associated with operation. Other attributes are energy equivalent, PQ curve, nominal head and tailwater elevation.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>class HydroGenerator(Base):\n    \"\"\"\n    Produces power from the main release of a HydroModule.\n\n    Produces to a power node, and can have variable costs associated with operation. Other attributes are energy equivalent, PQ curve, nominal head\n    and tailwater elevation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        power_node: str,\n        energy_equivalent: Conversion,  # energy equivalent\n        pq_curve: Expr | str | Curve | None = None,\n        nominal_head: Expr | str | TimeVector | None = None,\n        tailwater_elevation: Expr | str | TimeVector | None = None,\n        voc: Cost | None = None,\n        production: AvgFlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a HydroGenerator with parameters.\n\n        Args:\n            power_node (str): Node to supply power to.\n            energy_equivalent (Conversion): Conversion factor of power produced to water released.\n            pq_curve (Expr | str | Curve | None, optional): Expression or curve describing the relationship produced power and water released. Defaults to None.\n            nominal_head (Expr | str | TimeVector | None, optional): Vertical distance between upstream and dowstream water level. Defaults to None.\n            tailwater_elevation (Expr | str | TimeVector | None, optional): Elevation at the surface where the water exits the turbine. Defaults to None.\n            voc (Cost | None, optional): Variable operational costs. Defaults to None.\n            production (AvgFlowVolume | None, optional): Result of power volume produced. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n\n        self._check_type(power_node, str)\n        self._check_type(energy_equivalent, Conversion)\n        self._check_type(pq_curve, (Expr, str, Curve, type(None)))\n        self._check_type(nominal_head, (Expr, str, TimeVector, type(None)))\n        self._check_type(tailwater_elevation, (Expr, str, TimeVector, type(None)))\n        self._check_type(voc, (Cost, type(None)))\n\n        self._power_node = power_node\n        self._energy_eq = energy_equivalent\n        self._pq_curve = ensure_expr(pq_curve)\n        self._nominal_head = ensure_expr(nominal_head, is_level=True)\n        self._tailwater_elevation = ensure_expr(tailwater_elevation, is_level=True)\n        self._voc = voc\n\n        if production is None:\n            production = AvgFlowVolume()\n        self._production: AvgFlowVolume = production\n\n    def get_power_node(self) -&gt; str:\n        \"\"\"Get the power node of the hydro generator.\"\"\"\n        return self._power_node\n\n    def set_power_node(self, power_node: str) -&gt; None:\n        \"\"\"Set the power node of the pump unit.\"\"\"\n        self._check_type(power_node, str)\n        self._power_node = power_node\n\n    def get_energy_equivalent(self) -&gt; Conversion:\n        \"\"\"Get the energy equivalent of the hydro generator.\"\"\"\n        return self._energy_eq\n\n    def get_pq_curve(self) -&gt; Expr | None:\n        \"\"\"Get the PQ curve of the hydro generator.\"\"\"\n        return self._pq_curve\n\n    def get_nominal_head(self) -&gt; Expr | None:\n        \"\"\"Get the nominal head of the hydro generator.\"\"\"\n        return self._nominal_head\n\n    def get_tailwater_elevation(self) -&gt; Expr | None:\n        \"\"\"Get the tailwater elevation of the hydro generator.\"\"\"\n        return self._tailwater_elevation\n\n    def get_voc(self) -&gt; Cost | None:\n        \"\"\"Get the variable operation and maintenance cost of the hydro generator.\"\"\"\n        return self._voc\n\n    def set_voc(self, voc: Cost) -&gt; None:\n        \"\"\"Set the variable operation and maintenance cost of the hydro generator.\"\"\"\n        self._check_type(voc, Cost)\n        self._voc = voc\n\n    def get_production(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the generation of the hydro generator.\"\"\"\n        return self._production\n\n    def _get_fingerprint(self) -&gt; Fingerprint:\n        raise self.get_fingerprint_default(refs={\"power_node\": self._power_node})\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.__init__","title":"<code>__init__(power_node: str, energy_equivalent: Conversion, pq_curve: Expr | str | Curve | None = None, nominal_head: Expr | str | TimeVector | None = None, tailwater_elevation: Expr | str | TimeVector | None = None, voc: Cost | None = None, production: AvgFlowVolume | None = None) -&gt; None</code>","text":"<p>Initialize a HydroGenerator with parameters.</p> <p>Parameters:</p> Name Type Description Default <code>power_node</code> <code>str</code> <p>Node to supply power to.</p> required <code>energy_equivalent</code> <code>Conversion</code> <p>Conversion factor of power produced to water released.</p> required <code>pq_curve</code> <code>Expr | str | Curve | None</code> <p>Expression or curve describing the relationship produced power and water released. Defaults to None.</p> <code>None</code> <code>nominal_head</code> <code>Expr | str | TimeVector | None</code> <p>Vertical distance between upstream and dowstream water level. Defaults to None.</p> <code>None</code> <code>tailwater_elevation</code> <code>Expr | str | TimeVector | None</code> <p>Elevation at the surface where the water exits the turbine. Defaults to None.</p> <code>None</code> <code>voc</code> <code>Cost | None</code> <p>Variable operational costs. Defaults to None.</p> <code>None</code> <code>production</code> <code>AvgFlowVolume | None</code> <p>Result of power volume produced. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def __init__(\n    self,\n    power_node: str,\n    energy_equivalent: Conversion,  # energy equivalent\n    pq_curve: Expr | str | Curve | None = None,\n    nominal_head: Expr | str | TimeVector | None = None,\n    tailwater_elevation: Expr | str | TimeVector | None = None,\n    voc: Cost | None = None,\n    production: AvgFlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a HydroGenerator with parameters.\n\n    Args:\n        power_node (str): Node to supply power to.\n        energy_equivalent (Conversion): Conversion factor of power produced to water released.\n        pq_curve (Expr | str | Curve | None, optional): Expression or curve describing the relationship produced power and water released. Defaults to None.\n        nominal_head (Expr | str | TimeVector | None, optional): Vertical distance between upstream and dowstream water level. Defaults to None.\n        tailwater_elevation (Expr | str | TimeVector | None, optional): Elevation at the surface where the water exits the turbine. Defaults to None.\n        voc (Cost | None, optional): Variable operational costs. Defaults to None.\n        production (AvgFlowVolume | None, optional): Result of power volume produced. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n\n    self._check_type(power_node, str)\n    self._check_type(energy_equivalent, Conversion)\n    self._check_type(pq_curve, (Expr, str, Curve, type(None)))\n    self._check_type(nominal_head, (Expr, str, TimeVector, type(None)))\n    self._check_type(tailwater_elevation, (Expr, str, TimeVector, type(None)))\n    self._check_type(voc, (Cost, type(None)))\n\n    self._power_node = power_node\n    self._energy_eq = energy_equivalent\n    self._pq_curve = ensure_expr(pq_curve)\n    self._nominal_head = ensure_expr(nominal_head, is_level=True)\n    self._tailwater_elevation = ensure_expr(tailwater_elevation, is_level=True)\n    self._voc = voc\n\n    if production is None:\n        production = AvgFlowVolume()\n    self._production: AvgFlowVolume = production\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.get_energy_equivalent","title":"<code>get_energy_equivalent() -&gt; Conversion</code>","text":"<p>Get the energy equivalent of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_energy_equivalent(self) -&gt; Conversion:\n    \"\"\"Get the energy equivalent of the hydro generator.\"\"\"\n    return self._energy_eq\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.get_nominal_head","title":"<code>get_nominal_head() -&gt; Expr | None</code>","text":"<p>Get the nominal head of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_nominal_head(self) -&gt; Expr | None:\n    \"\"\"Get the nominal head of the hydro generator.\"\"\"\n    return self._nominal_head\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.get_power_node","title":"<code>get_power_node() -&gt; str</code>","text":"<p>Get the power node of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_power_node(self) -&gt; str:\n    \"\"\"Get the power node of the hydro generator.\"\"\"\n    return self._power_node\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.get_pq_curve","title":"<code>get_pq_curve() -&gt; Expr | None</code>","text":"<p>Get the PQ curve of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_pq_curve(self) -&gt; Expr | None:\n    \"\"\"Get the PQ curve of the hydro generator.\"\"\"\n    return self._pq_curve\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.get_production","title":"<code>get_production() -&gt; AvgFlowVolume</code>","text":"<p>Get the generation of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_production(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the generation of the hydro generator.\"\"\"\n    return self._production\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.get_tailwater_elevation","title":"<code>get_tailwater_elevation() -&gt; Expr | None</code>","text":"<p>Get the tailwater elevation of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_tailwater_elevation(self) -&gt; Expr | None:\n    \"\"\"Get the tailwater elevation of the hydro generator.\"\"\"\n    return self._tailwater_elevation\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.get_voc","title":"<code>get_voc() -&gt; Cost | None</code>","text":"<p>Get the variable operation and maintenance cost of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_voc(self) -&gt; Cost | None:\n    \"\"\"Get the variable operation and maintenance cost of the hydro generator.\"\"\"\n    return self._voc\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.set_power_node","title":"<code>set_power_node(power_node: str) -&gt; None</code>","text":"<p>Set the power node of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def set_power_node(self, power_node: str) -&gt; None:\n    \"\"\"Set the power node of the pump unit.\"\"\"\n    self._check_type(power_node, str)\n    self._power_node = power_node\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroGenerator.set_voc","title":"<code>set_voc(voc: Cost) -&gt; None</code>","text":"<p>Set the variable operation and maintenance cost of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def set_voc(self, voc: Cost) -&gt; None:\n    \"\"\"Set the variable operation and maintenance cost of the hydro generator.\"\"\"\n    self._check_type(voc, Cost)\n    self._voc = voc\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump","title":"<code>HydroPump</code>","text":"<p>               Bases: <code>Base</code></p> <p>Represent a pump associated with a HydroModule.</p> <p>The HydroPump can consume power from a power Node to move water upstream between two HydroModules. It has a max power capacity, and mean energy equivalent and water capacity. It can also describe the relationship between head and flow (Q), with min and max head and flow.</p> <p>Results for water and power consumption are stored as AvgFlowVolume attributes.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>class HydroPump(Base):\n    \"\"\"\n    Represent a pump associated with a HydroModule.\n\n    The HydroPump can consume power from a power Node to move water upstream between two HydroModules. It has a max power capacity, and mean energy\n    equivalent and water capacity. It can also describe the relationship between head and flow (Q), with min and max head and flow.\n\n    Results for water and power consumption are stored as AvgFlowVolume attributes.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        power_node: str,\n        from_module: str,\n        to_module: str,\n        water_capacity: FlowVolume,\n        energy_equivalent: Conversion,\n        power_capacity: FlowVolume | None = None,\n        head_min: Expr | str | TimeVector | None = None,\n        head_max: Expr | str | TimeVector | None = None,\n        q_min: Expr | str | TimeVector | None = None,\n        q_max: Expr | str | TimeVector | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a HydroPump object parameters.\n\n        Args:\n            power_node (str): Node to take power from when operating.\n            from_module (str): Source HydroModule to move water from.\n            to_module (str): Destination HydroModule to move water to.\n            water_capacity (FlowVolume): Max pumped water volume given the mean energy equivalent and power capacity.\n            energy_equivalent (Conversion): Mean conversion factor between power consumed and volume of water moved.\n            power_capacity (FlowVolume | None, optional): Max power consumed. Defaults to None.\n            head_min (Expr | str | TimeVector | None, optional): Minimum elevation difference between upstream and downstream water level. Defaults to None.\n            head_max (Expr | str | TimeVector | None, optional): Maximum elevation difference between upstream and downstream water level. Defaults to None.\n            q_min (Expr | str | TimeVector | None, optional): Maximum water flow at head_min. Defaults to None.\n            q_max (Expr | str | TimeVector | None, optional): Maximum water flow at head_max. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n        self._check_type(power_node, str)\n        self._check_modules(from_module, to_module)  # checks types and that they are not the same.\n        self._check_type(water_capacity, FlowVolume)\n        self._check_type(power_capacity, (FlowVolume, type(None)))\n        self._check_type(energy_equivalent, Conversion)\n        self._check_type(head_min, (Expr, str, TimeVector, type(None)))\n        self._check_type(head_max, (Expr, str, TimeVector, type(None)))\n        self._check_type(q_min, (Expr, str, TimeVector, type(None)))\n        self._check_type(q_max, (Expr, str, TimeVector, type(None)))\n\n        self._power_node = power_node\n        self._from_module = from_module\n        self._to_module = to_module\n        self._water_capacity = water_capacity\n        self._energy_eq = energy_equivalent\n        self._power_capacity = power_capacity\n\n        self._hmin = ensure_expr(head_min, is_level=True)\n        self._hmax = ensure_expr(head_max, is_level=True)\n        self._qmin = ensure_expr(q_min, is_flow=True, is_level=True)\n        self._qmax = ensure_expr(q_max, is_flow=True, is_level=True)\n\n        self._water_consumption = AvgFlowVolume()\n        self._power_consumption = AvgFlowVolume()\n\n    def get_water_capacity(self) -&gt; FlowVolume:\n        \"\"\"Get the capacity of the pump unit.\"\"\"\n        return self._water_capacity\n\n    def get_power_capacity(self) -&gt; FlowVolume:\n        \"\"\"Get the capacity of the pump unit.\"\"\"\n        return self._power_capacity\n\n    def get_power_node(self) -&gt; str:\n        \"\"\"Get the power node of the pump unit.\"\"\"\n        return self._power_node\n\n    def set_power_node(self, power_node: str) -&gt; None:\n        \"\"\"Set the power node of the pump unit.\"\"\"\n        self._check_type(power_node, str)\n        self._power_node = power_node\n\n    def get_from_module(self) -&gt; str:\n        \"\"\"Get the module from which the pump unit is pumping.\"\"\"\n        return self._from_module\n\n    def get_to_module(self) -&gt; str:\n        \"\"\"Get the module to which the pump unit is pumping.\"\"\"\n        return self._to_module\n\n    # TODO: should be split in two? Keep in mind we check that the to and from modules are not the same. So if we split this user might run into issues if\n    # trying to first set from_module to to_module then change to_module.\n    def set_modules(self, from_module: str, to_module: str) -&gt; None:\n        \"\"\"Set the modules for the pump unit.\"\"\"\n        self._check_modules(from_module, to_module)\n        self._from_module = from_module\n        self._to_module = to_module\n\n    def get_water_consumption(self) -&gt; FlowVolume:\n        \"\"\"Get the water consumption of the pump unit.\"\"\"\n        return self._water_consumption\n\n    def get_power_consumption(self) -&gt; FlowVolume:\n        \"\"\"Get the power consumption of the pump unit.\"\"\"\n        return self._power_consumption\n\n    def _check_modules(self, from_module: str, to_module: str) -&gt; None:\n        self._check_type(from_module, str)\n        self._check_type(to_module, str)\n        if from_module == to_module:\n            message = f\"{self} cannot pump to and from the same module. Got {from_module} for both from_module and to_module.\"\n            raise ValueError(message)\n\n    def _check_base_module_name(self, base_name: str) -&gt; None:\n        if base_name not in (self._from_module, self._to_module):\n            message = (\n                f\"Module {base_name} has not been coupled correctly to its pump {self}. Pump is coupled to modules {self._from_module} and {self._to_module}\"\n            )\n            raise RuntimeError(message)\n\n    # other parameters\n    def get_energy_equivalent(self) -&gt; Conversion:\n        \"\"\"Get the energy equivalent of hydro pump.\"\"\"\n        return self._energy_eq\n\n    def set_energy_eq(self, energy_eq: Conversion) -&gt; None:\n        \"\"\"Set the energy equivalent.\"\"\"\n        self._check_type(energy_eq, Conversion)\n        self._energy_eq = energy_eq\n\n    def get_head_min(self) -&gt; Expr:\n        \"\"\"Get min fall height of hydro pump.\"\"\"\n        return self._head_min\n\n    def set_head_min(self, head_min: Expr | str | None) -&gt; None:\n        \"\"\"Set min fall height.\"\"\"\n        self._head_min = ensure_expr(head_min)\n\n    def get_head_max(self) -&gt; Expr:\n        \"\"\"Get max fall height of hydro pump.\"\"\"\n        return self._hmax\n\n    def set_head_max(self, hmax: Expr | str | None) -&gt; None:\n        \"\"\"Set max fall height.\"\"\"\n        self._hmax = ensure_expr(hmax)\n\n    def get_q_min(self) -&gt; Expr:\n        \"\"\"Get Q min of hydro pump.\"\"\"\n        return self._q_min\n\n    def set_qmin(self, q_min: Expr | str | None) -&gt; None:\n        \"\"\"Set Q min.\"\"\"\n        self._q_min = ensure_expr(q_min)\n\n    def get_q_max(self) -&gt; Expr:\n        \"\"\"Get Q max of hydro pump.\"\"\"\n        return self._q_max\n\n    def set_qmax(self, q_max: Expr | str | None) -&gt; None:\n        \"\"\"Set Q max.\"\"\"\n        self._q_max = ensure_expr(q_max)\n\n    def _get_fingerprint(self) -&gt; Fingerprint:\n        return self.get_fingerprint_default(\n            refs={\n                \"power_node\": self._power_node,\n                \"from_module\": self._from_module,\n                \"to_module\": self._to_module,\n            },\n        )\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.__init__","title":"<code>__init__(power_node: str, from_module: str, to_module: str, water_capacity: FlowVolume, energy_equivalent: Conversion, power_capacity: FlowVolume | None = None, head_min: Expr | str | TimeVector | None = None, head_max: Expr | str | TimeVector | None = None, q_min: Expr | str | TimeVector | None = None, q_max: Expr | str | TimeVector | None = None) -&gt; None</code>","text":"<p>Initialize a HydroPump object parameters.</p> <p>Parameters:</p> Name Type Description Default <code>power_node</code> <code>str</code> <p>Node to take power from when operating.</p> required <code>from_module</code> <code>str</code> <p>Source HydroModule to move water from.</p> required <code>to_module</code> <code>str</code> <p>Destination HydroModule to move water to.</p> required <code>water_capacity</code> <code>FlowVolume</code> <p>Max pumped water volume given the mean energy equivalent and power capacity.</p> required <code>energy_equivalent</code> <code>Conversion</code> <p>Mean conversion factor between power consumed and volume of water moved.</p> required <code>power_capacity</code> <code>FlowVolume | None</code> <p>Max power consumed. Defaults to None.</p> <code>None</code> <code>head_min</code> <code>Expr | str | TimeVector | None</code> <p>Minimum elevation difference between upstream and downstream water level. Defaults to None.</p> <code>None</code> <code>head_max</code> <code>Expr | str | TimeVector | None</code> <p>Maximum elevation difference between upstream and downstream water level. Defaults to None.</p> <code>None</code> <code>q_min</code> <code>Expr | str | TimeVector | None</code> <p>Maximum water flow at head_min. Defaults to None.</p> <code>None</code> <code>q_max</code> <code>Expr | str | TimeVector | None</code> <p>Maximum water flow at head_max. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def __init__(\n    self,\n    power_node: str,\n    from_module: str,\n    to_module: str,\n    water_capacity: FlowVolume,\n    energy_equivalent: Conversion,\n    power_capacity: FlowVolume | None = None,\n    head_min: Expr | str | TimeVector | None = None,\n    head_max: Expr | str | TimeVector | None = None,\n    q_min: Expr | str | TimeVector | None = None,\n    q_max: Expr | str | TimeVector | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a HydroPump object parameters.\n\n    Args:\n        power_node (str): Node to take power from when operating.\n        from_module (str): Source HydroModule to move water from.\n        to_module (str): Destination HydroModule to move water to.\n        water_capacity (FlowVolume): Max pumped water volume given the mean energy equivalent and power capacity.\n        energy_equivalent (Conversion): Mean conversion factor between power consumed and volume of water moved.\n        power_capacity (FlowVolume | None, optional): Max power consumed. Defaults to None.\n        head_min (Expr | str | TimeVector | None, optional): Minimum elevation difference between upstream and downstream water level. Defaults to None.\n        head_max (Expr | str | TimeVector | None, optional): Maximum elevation difference between upstream and downstream water level. Defaults to None.\n        q_min (Expr | str | TimeVector | None, optional): Maximum water flow at head_min. Defaults to None.\n        q_max (Expr | str | TimeVector | None, optional): Maximum water flow at head_max. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self._check_type(power_node, str)\n    self._check_modules(from_module, to_module)  # checks types and that they are not the same.\n    self._check_type(water_capacity, FlowVolume)\n    self._check_type(power_capacity, (FlowVolume, type(None)))\n    self._check_type(energy_equivalent, Conversion)\n    self._check_type(head_min, (Expr, str, TimeVector, type(None)))\n    self._check_type(head_max, (Expr, str, TimeVector, type(None)))\n    self._check_type(q_min, (Expr, str, TimeVector, type(None)))\n    self._check_type(q_max, (Expr, str, TimeVector, type(None)))\n\n    self._power_node = power_node\n    self._from_module = from_module\n    self._to_module = to_module\n    self._water_capacity = water_capacity\n    self._energy_eq = energy_equivalent\n    self._power_capacity = power_capacity\n\n    self._hmin = ensure_expr(head_min, is_level=True)\n    self._hmax = ensure_expr(head_max, is_level=True)\n    self._qmin = ensure_expr(q_min, is_flow=True, is_level=True)\n    self._qmax = ensure_expr(q_max, is_flow=True, is_level=True)\n\n    self._water_consumption = AvgFlowVolume()\n    self._power_consumption = AvgFlowVolume()\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_energy_equivalent","title":"<code>get_energy_equivalent() -&gt; Conversion</code>","text":"<p>Get the energy equivalent of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_energy_equivalent(self) -&gt; Conversion:\n    \"\"\"Get the energy equivalent of hydro pump.\"\"\"\n    return self._energy_eq\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_from_module","title":"<code>get_from_module() -&gt; str</code>","text":"<p>Get the module from which the pump unit is pumping.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_from_module(self) -&gt; str:\n    \"\"\"Get the module from which the pump unit is pumping.\"\"\"\n    return self._from_module\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_head_max","title":"<code>get_head_max() -&gt; Expr</code>","text":"<p>Get max fall height of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_head_max(self) -&gt; Expr:\n    \"\"\"Get max fall height of hydro pump.\"\"\"\n    return self._hmax\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_head_min","title":"<code>get_head_min() -&gt; Expr</code>","text":"<p>Get min fall height of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_head_min(self) -&gt; Expr:\n    \"\"\"Get min fall height of hydro pump.\"\"\"\n    return self._head_min\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_power_capacity","title":"<code>get_power_capacity() -&gt; FlowVolume</code>","text":"<p>Get the capacity of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_power_capacity(self) -&gt; FlowVolume:\n    \"\"\"Get the capacity of the pump unit.\"\"\"\n    return self._power_capacity\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_power_consumption","title":"<code>get_power_consumption() -&gt; FlowVolume</code>","text":"<p>Get the power consumption of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_power_consumption(self) -&gt; FlowVolume:\n    \"\"\"Get the power consumption of the pump unit.\"\"\"\n    return self._power_consumption\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_power_node","title":"<code>get_power_node() -&gt; str</code>","text":"<p>Get the power node of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_power_node(self) -&gt; str:\n    \"\"\"Get the power node of the pump unit.\"\"\"\n    return self._power_node\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_q_max","title":"<code>get_q_max() -&gt; Expr</code>","text":"<p>Get Q max of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_q_max(self) -&gt; Expr:\n    \"\"\"Get Q max of hydro pump.\"\"\"\n    return self._q_max\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_q_min","title":"<code>get_q_min() -&gt; Expr</code>","text":"<p>Get Q min of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_q_min(self) -&gt; Expr:\n    \"\"\"Get Q min of hydro pump.\"\"\"\n    return self._q_min\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_to_module","title":"<code>get_to_module() -&gt; str</code>","text":"<p>Get the module to which the pump unit is pumping.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_to_module(self) -&gt; str:\n    \"\"\"Get the module to which the pump unit is pumping.\"\"\"\n    return self._to_module\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_water_capacity","title":"<code>get_water_capacity() -&gt; FlowVolume</code>","text":"<p>Get the capacity of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_water_capacity(self) -&gt; FlowVolume:\n    \"\"\"Get the capacity of the pump unit.\"\"\"\n    return self._water_capacity\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.get_water_consumption","title":"<code>get_water_consumption() -&gt; FlowVolume</code>","text":"<p>Get the water consumption of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_water_consumption(self) -&gt; FlowVolume:\n    \"\"\"Get the water consumption of the pump unit.\"\"\"\n    return self._water_consumption\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.set_energy_eq","title":"<code>set_energy_eq(energy_eq: Conversion) -&gt; None</code>","text":"<p>Set the energy equivalent.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_energy_eq(self, energy_eq: Conversion) -&gt; None:\n    \"\"\"Set the energy equivalent.\"\"\"\n    self._check_type(energy_eq, Conversion)\n    self._energy_eq = energy_eq\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.set_head_max","title":"<code>set_head_max(hmax: Expr | str | None) -&gt; None</code>","text":"<p>Set max fall height.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_head_max(self, hmax: Expr | str | None) -&gt; None:\n    \"\"\"Set max fall height.\"\"\"\n    self._hmax = ensure_expr(hmax)\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.set_head_min","title":"<code>set_head_min(head_min: Expr | str | None) -&gt; None</code>","text":"<p>Set min fall height.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_head_min(self, head_min: Expr | str | None) -&gt; None:\n    \"\"\"Set min fall height.\"\"\"\n    self._head_min = ensure_expr(head_min)\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.set_modules","title":"<code>set_modules(from_module: str, to_module: str) -&gt; None</code>","text":"<p>Set the modules for the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_modules(self, from_module: str, to_module: str) -&gt; None:\n    \"\"\"Set the modules for the pump unit.\"\"\"\n    self._check_modules(from_module, to_module)\n    self._from_module = from_module\n    self._to_module = to_module\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.set_power_node","title":"<code>set_power_node(power_node: str) -&gt; None</code>","text":"<p>Set the power node of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_power_node(self, power_node: str) -&gt; None:\n    \"\"\"Set the power node of the pump unit.\"\"\"\n    self._check_type(power_node, str)\n    self._power_node = power_node\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.set_qmax","title":"<code>set_qmax(q_max: Expr | str | None) -&gt; None</code>","text":"<p>Set Q max.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_qmax(self, q_max: Expr | str | None) -&gt; None:\n    \"\"\"Set Q max.\"\"\"\n    self._q_max = ensure_expr(q_max)\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroPump.set_qmin","title":"<code>set_qmin(q_min: Expr | str | None) -&gt; None</code>","text":"<p>Set Q min.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_qmin(self, q_min: Expr | str | None) -&gt; None:\n    \"\"\"Set Q min.\"\"\"\n    self._q_min = ensure_expr(q_min)\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroReservoir","title":"<code>HydroReservoir</code>","text":"<p>               Bases: <code>Storage</code></p> <p>Represent a hydro reservoir of a HydroModule.</p> Source code in <code>framcore/attributes/hydro/HydroReservoir.py</code> <pre><code>class HydroReservoir(Storage):\n    \"\"\"Represent a hydro reservoir of a HydroModule.\"\"\"\n\n    def __init__(\n        self,\n        capacity: StockVolume,\n        reservoir_curve: ReservoirCurve = None,\n        volume: StockVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a HydroReservoir instance.\n\n        Args:\n            capacity (StockVolume): The maximum storage capacity of the reservoir.\n            reservoir_curve (ReservoirCurve, optional): The curve describing water level elevation to volume characteristics.\n            volume (StockVolume, optional): Volume of water in the reservoir.\n\n        \"\"\"\n        super().__init__(\n            capacity=capacity,\n            reservoir_curve=reservoir_curve,\n            volume=volume,\n        )\n</code></pre>"},{"location":"reference/#framcore.attributes.HydroReservoir.__init__","title":"<code>__init__(capacity: StockVolume, reservoir_curve: ReservoirCurve = None, volume: StockVolume | None = None) -&gt; None</code>","text":"<p>Initialize a HydroReservoir instance.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>StockVolume</code> <p>The maximum storage capacity of the reservoir.</p> required <code>reservoir_curve</code> <code>ReservoirCurve</code> <p>The curve describing water level elevation to volume characteristics.</p> <code>None</code> <code>volume</code> <code>StockVolume</code> <p>Volume of water in the reservoir.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroReservoir.py</code> <pre><code>def __init__(\n    self,\n    capacity: StockVolume,\n    reservoir_curve: ReservoirCurve = None,\n    volume: StockVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a HydroReservoir instance.\n\n    Args:\n        capacity (StockVolume): The maximum storage capacity of the reservoir.\n        reservoir_curve (ReservoirCurve, optional): The curve describing water level elevation to volume characteristics.\n        volume (StockVolume, optional): Volume of water in the reservoir.\n\n    \"\"\"\n    super().__init__(\n        capacity=capacity,\n        reservoir_curve=reservoir_curve,\n        volume=volume,\n    )\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile","title":"<code>LevelProfile</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Attributes representing timeseries data for Components. Mostly as Level * Profile, where both Level and Profile are Expr (expressions).</p> <p>Level and Profile represent two distinct dimensions of time. This is because we want to simulate future system states with historical weather patterns. Therefore, Level represents the system state at a given time (data_dim), while Profile represents the scenario dimension (scen_dim). A Level would for example represent the installed capacity of solar plants towards 2030, while the Profile would represent the historical variation between 1991-2020.</p> <p>Level and Profile can have two main formats: A maximum Level with a Profile that varies between 0-1, and an average Level with a Profile with a mean of 1 (the latter can have a ReferencePeriod). The max format is, for example, used for capacities, while the mean format can be used for prices and flows. The system needs to be able to convert between the two formats. This is especially important for aggregations (for example weighted averages) where all the TimeVectors need to be on the same format for a correct result. One simple example of conversion is pairing a max Level of 100 MW with a mean_one Profile [0, 1, 2]. Asking for this on the max format will return the series 100[0, 0.5, 1] MW, while on the avg format it will return 50[0, 1, 2] MW.</p> <p>Queries to LevelProfile need to provide a database, the desired target TimeIndex for both dimensions, the target unit and the desired format. At the moment we support these queries for LevelProfile: - self.get_data_value(db, scen_dim, data_dim, unit, is_max_level) - self.get_scenario_vector(db, scen_dim, data_dim, unit, is_float32)</p> <p>In addition, we have the possibility to shift, scale, and change the intercept of the LevelProfiles. Then we get the full representation: Scale * (Level + Level_shift) * Profile + Intercept. - Level_shift adds a constant value to Level, has the same Profile as Level. - Scale multiplies (Level + Level_shift) by a constant value. - Intercept adds a constant value to LevelProfile, ignoring Level and Profile. This is the only way of supporting a timeseries that crosses zero     in our system. This functionality is under development and has not been properly tested.</p> <p>LevelProfiles also have additional properties that describes their behaviour. These can be used for initialization, validation, and to simplify queries. The properties are: - is_stock: True if attribute is a stock variable. Level Expr should also have is_stock=True. See Expr for details. - is_flow: True if attribute is a flow variable. Level Expr should also have is_flow=True. See Expr for details. - is_not_negative: True if attribute is not allowed to have negative values. Level Expr should also have only non-negative values. - is_max_and_zero_one: Preferred format of Level and Profile. Used for initialization and queries. - is_ingoing: True if attribute is ingoing, False if outgoing, None if neither. - is_cost: True if attribute is objective function cost coefficient. Else None. - is_unitless: True if attribute is known to be unitless. False if known to have a unit that is not None. Else None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class LevelProfile(Base, ABC):\n    \"\"\"\n    Attributes representing timeseries data for Components. Mostly as Level * Profile, where both Level and Profile are Expr (expressions).\n\n    Level and Profile represent two distinct dimensions of time. This is because we want to simulate future system states with historical weather patterns.\n    Therefore, Level represents the system state at a given time (data_dim), while Profile represents the scenario dimension (scen_dim).\n    A Level would for example represent the installed capacity of solar plants towards 2030,\n    while the Profile would represent the historical variation between 1991-2020.\n\n    Level and Profile can have two main formats: A maximum Level with a Profile that varies between 0-1,\n    and an average Level with a Profile with a mean of 1 (the latter can have a ReferencePeriod).\n    The max format is, for example, used for capacities, while the mean format can be used for prices and flows.\n    The system needs to be able to convert between the two formats. This is especially important for aggregations\n    (for example weighted averages) where all the TimeVectors need to be on the same format for a correct result.\n    One simple example of conversion is pairing a max Level of 100 MW with a mean_one Profile [0, 1, 2].\n    Asking for this on the max format will return the series 100*[0, 0.5, 1] MW, while on the avg format it will return 50*[0, 1, 2] MW.\n\n    Queries to LevelProfile need to provide a database, the desired target TimeIndex for both dimensions, the target unit and the desired format.\n    At the moment we support these queries for LevelProfile:\n    - self.get_data_value(db, scen_dim, data_dim, unit, is_max_level)\n    - self.get_scenario_vector(db, scen_dim, data_dim, unit, is_float32)\n\n    In addition, we have the possibility to shift, scale, and change the intercept of the LevelProfiles.\n    Then we get the full representation: Scale * (Level + Level_shift) * Profile + Intercept.\n    - Level_shift adds a constant value to Level, has the same Profile as Level.\n    - Scale multiplies (Level + Level_shift) by a constant value.\n    - Intercept adds a constant value to LevelProfile, ignoring Level and Profile. **This is the only way of supporting a timeseries that crosses zero\n        in our system. This functionality is under development and has not been properly tested.**\n\n    LevelProfiles also have additional properties that describes their behaviour. These can be used for initialization, validation,\n    and to simplify queries. The properties are:\n    - is_stock: True if attribute is a stock variable. Level Expr should also have is_stock=True. See Expr for details.\n    - is_flow: True if attribute is a flow variable. Level Expr should also have is_flow=True. See Expr for details.\n    - is_not_negative: True if attribute is not allowed to have negative values. Level Expr should also have only non-negative values.\n    - is_max_and_zero_one: Preferred format of Level and Profile. Used for initialization and queries.\n    - is_ingoing: True if attribute is ingoing, False if outgoing, None if neither.\n    - is_cost: True if attribute is objective function cost coefficient. Else None.\n    - is_unitless: True if attribute is known to be unitless. False if known to have a unit that is not None. Else None.\n\n    \"\"\"\n\n    # must be overwritten by subclass when otherwise\n    # don't change the defaults\n    _IS_ABSTRACT: bool = True\n    _IS_STOCK: bool = False\n    _IS_FLOW: bool = False\n    _IS_NOT_NEGATIVE: bool = True\n    _IS_MAX_AND_ZERO_ONE: bool = False\n\n    # must be set by subclass when applicable\n    _IS_INGOING: bool | None = None\n    _IS_COST: bool | None = None\n    _IS_UNITLESS: bool | None = None\n\n    def __init__(\n        self,\n        level: Expr | TimeVector | str | None = None,\n        profile: Expr | TimeVector | str | None = None,\n        value: float | int | None = None,  # To support Price(value=20, unit=\"EUR/MWh\")\n        unit: str | None = None,\n        level_shift: Expr | None = None,\n        intercept: Expr | None = None,\n        scale: Expr | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize LevelProfile.\n\n        See the LevelProfile class docstring for details. A complete LevelProfile is represented as:\n        Scale * (Level + Level_shift) * Profile + Intercept. Normally only Level and Profile are used.\n\n        Either give level and profile, or value and unit.\n\n        Args:\n            level (Expr | TimeVector | str | None, optional): Level Expr. Defaults to None.\n            profile (Expr | TimeVector | str | None, optional): Profile Expr. Defaults to None.\n            value (float | int | None, optional): A constant value to initialize Level. Defaults to None.\n            unit (str | None, optional): Unit of the constant value to initialize Level. Defaults to None.\n            level_shift (Expr | None, optional): Level_shift Expr. Defaults to None.\n            intercept (Expr | None, optional): Intercept Expr. Defaults to None.\n            scale (Expr | None, optional): Scale Expr. Defaults to None.\n\n        \"\"\"\n        self._assert_invariants()\n\n        self._check_type(value, (float, int, type(None)))\n        self._check_type(unit, (str, type(None)))\n        self._check_type(level, (Expr, TimeVector, str, type(None)))\n        self._check_type(profile, (Expr, TimeVector, str, type(None)))\n        self._check_type(level_shift, (Expr, type(None)))\n        self._check_type(intercept, (Expr, type(None)))\n        self._check_type(scale, (Expr, type(None)))\n        level = self._ensure_level_expr(level, value, unit)\n        profile = self._ensure_profile_expr(profile)\n        self._ensure_compatible_level_profile_combo(level, profile)\n        self._ensure_compatible_level_profile_combo(level_shift, profile)\n        self._level: Expr | None = level\n        self._profile: Expr | None = profile\n        self._level_shift: Expr | None = level_shift\n        self._intercept: Expr | None = intercept\n        self._scale: Expr | None = scale\n        # TODO: Validate that profiles are equal in level and level_shift.\n        # TODO: Validate that level_shift, scale and intercept only consist of Exprs with ConstantTimeVectors\n        # TODO: Validate that level_shift, level_scale and intercept have correct Expr properties\n\n    def _assert_invariants(self) -&gt; None:\n        abstract = self._IS_ABSTRACT\n        max_level_profile = self._IS_MAX_AND_ZERO_ONE\n        stock = self._IS_STOCK\n        flow = self._IS_FLOW\n        unitless = self._IS_UNITLESS\n        ingoing = self._IS_INGOING\n        cost = self._IS_COST\n        not_negative = self._IS_NOT_NEGATIVE\n\n        assert not abstract, \"Abstract types should only be used for type hints and checks.\"\n        assert isinstance(max_level_profile, bool)\n        assert isinstance(stock, bool)\n        assert isinstance(flow, bool)\n        assert isinstance(not_negative, bool)\n        assert isinstance(ingoing, bool | type(None))\n        assert isinstance(unitless, bool | type(None))\n        assert isinstance(cost, bool | type(None))\n        assert not (flow and stock)\n        if flow or stock:\n            assert not unitless, \"flow and stock must have unit that is not None.\"\n            assert not_negative, \"flow and stock cannot have negative values.\"\n        if ingoing is True:\n            assert cost is None, \"cost must be None when ingoing is True.\"\n        if cost is True:\n            assert ingoing is None, \"ingoing must be None when cost is True.\"\n\n        parent = super()\n        if isinstance(parent, LevelProfile) and not parent._IS_ABSTRACT:  # noqa: SLF001\n            self._assert_same_behaviour(parent)\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in expressions to loaders.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self.get_level())\n        add_loaders_if(loaders, self.get_profile())\n\n    def clear(self) -&gt; None:\n        \"\"\"\n        Set all internal fields to None.\n\n        You may want to use this to get exogenous flow to use capacities instead of volume.\n        \"\"\"\n        self._level = None\n        self._profile = None\n        self._level_shift = None\n        self._intercept = None\n        self._scale = None\n\n    def is_stock(self) -&gt; bool:\n        \"\"\"\n        Return True if attribute is a stock variable.\n\n        Return False if attribute is not a stock variable.\n        \"\"\"\n        return self._IS_STOCK\n\n    def is_flow(self) -&gt; bool:\n        \"\"\"\n        Return True if attribute is a flow variable.\n\n        Return False if attribute is not a flow variable.\n        \"\"\"\n        return self._IS_FLOW\n\n    def is_not_negative(self) -&gt; bool:\n        \"\"\"\n        Return True if attribute is not allowed to have negative values.\n\n        Return False if attribute can have both positive and negative values.\n        \"\"\"\n        return self._IS_NOT_NEGATIVE\n\n    def is_max_and_zero_one(self) -&gt; bool:\n        \"\"\"\n        When True level should be max (not average) and corresponding profile should be zero_one (not mean_one).\n\n        When False level should be average (not max) and corresponding profile should be mean_one (not zero_one).\n        \"\"\"\n        return self._IS_MAX_AND_ZERO_ONE\n\n    def is_ingoing(self) -&gt; bool | None:\n        \"\"\"\n        Return True if attribute is ingoing.\n\n        Return True if attribute is outgoing.\n\n        Return None if not applicable.\n        \"\"\"\n        return self._IS_INGOING\n\n    def is_cost(self) -&gt; bool | None:\n        \"\"\"\n        Return True if attribute is objective function cost coefficient.\n\n        Return False if attribute is objective function revenue coefficient.\n\n        Return None if not applicable.\n        \"\"\"\n        return self._IS_COST\n\n    def is_unitless(self) -&gt; bool | None:\n        \"\"\"\n        Return True if attribute is known to be unitless.\n\n        Return False if attribute is known to have a unit that is not None.\n\n        Return None if not applicable.\n        \"\"\"\n        return self._IS_UNITLESS\n\n    def has_level(self) -&gt; bool:\n        \"\"\"Return True if get_level will return value not None.\"\"\"\n        return (self._level is not None) or (self._level_shift is not None)\n\n    def has_profile(self) -&gt; bool:\n        \"\"\"Return True if get_profile will return value not None.\"\"\"\n        return self._profile is not None\n\n    def has_intercept(self) -&gt; bool:\n        \"\"\"Return True if get_intercept will return value not None.\"\"\"\n        return self._intercept is not None\n\n    def copy_from(self, other: LevelProfile) -&gt; None:\n        \"\"\"Copy fields from other.\"\"\"\n        self._check_type(other, LevelProfile)\n        self._assert_same_behaviour(other)\n        self._level = other._level\n        self._profile = other._profile\n        self._level_shift = other._level_shift\n        self._intercept = other._intercept\n        self._scale = other._scale\n\n    def get_level(self) -&gt; Expr | None:\n        \"\"\"Get level part of (level * profile + intercept).\"\"\"\n        level = self._level\n\n        if level is None:\n            return None\n\n        if level.is_leaf():\n            level = Expr(\n                src=level.get_src(),\n                operations=level.get_operations(expect_ops=False, copy_list=True),\n                is_stock=level.is_stock(),\n                is_flow=level.is_flow(),\n                is_level=True,\n                is_profile=False,\n                profile=self._profile,\n            )\n\n        if self._level_shift is not None:\n            level += self._level_shift\n\n        if self._scale is not None:\n            level *= self._scale\n\n        return level\n\n    def set_level(self, level: Expr | TimeVector | str | None) -&gt; None:\n        \"\"\"Set level part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n        self._check_type(level, (Expr, TimeVector, str, type(None)))\n        level = self._ensure_level_expr(level)\n        self._ensure_compatible_level_profile_combo(level, self._profile)\n        self._level = level\n\n    def get_profile(self) -&gt; Expr | None:\n        \"\"\"Get profile part of (level * profile + intercept).\"\"\"\n        return self._profile\n\n    def set_profile(self, profile: Expr | TimeVector | str | None) -&gt; None:\n        \"\"\"Set profile part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n        self._check_type(profile, (Expr, TimeVector, str, type(None)))\n        profile = self._ensure_profile_expr(profile)\n        self._ensure_compatible_level_profile_combo(self._level, profile)\n        self._profile = profile\n\n    def get_intercept(self) -&gt; Expr | None:\n        \"\"\"Get intercept part of (level * profile + intercept).\"\"\"\n        intercept = self._intercept\n        if self._scale is not None:\n            intercept *= self._scale\n        return intercept\n\n    def set_intercept(self, value: Expr | None) -&gt; None:\n        \"\"\"Set intercept part of (level * profile + intercept).\"\"\"\n        self._check_type(value, (Expr, type(None)))\n        if value is not None:\n            self._check_level_expr(value)\n        self._intercept = value\n\n    def get_level_unit_set(\n        self,\n        db: QueryDB | Model,\n    ) -&gt; set[TimeIndex]:\n        \"\"\"\n        Return set with all units behind level expression.\n\n        Useful for discovering valid unit input to get_level_value.\n        \"\"\"\n        if not self.has_level():\n            return set()\n        return get_units_from_expr(db, self.get_level())\n\n    def get_profile_timeindex_set(\n        self,\n        db: QueryDB | Model,\n    ) -&gt; set[TimeIndex]:\n        \"\"\"\n        Return set with all TimeIndex behind profile expression.\n\n        Can be used to run optimized queries, i.e. not asking for\n        finer time resolutions than necessary.\n        \"\"\"\n        if not self.has_profile():\n            return set()\n        return get_timeindexes_from_expr(db, self.get_profile())\n\n    def get_scenario_vector(\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_float32: bool = True,\n    ) -&gt; NDArray:\n        \"\"\"\n        Evaluate LevelProfile over the periods in scenario dimension, and at the level period of the data dimension.\n\n        Underlying profiles are evalutated over the scenario dimension,\n        and levels are evalutated to scalars over level_period in the data dimension.\n\n        Args:\n            db (QueryDB | Model): The database or model instance used to fetch the required data.\n            scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n            level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n            unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n                the expression should be unitless.\n            is_float32 (bool, optional): Whether to return the vector as a NumPy array with `float32`\n                precision. Defaults to True.\n\n        \"\"\"\n        return self._get_scenario_vector(db, scenario_horizon, level_period, unit, is_float32)\n\n    def get_data_value(\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_max_level: bool | None = None,\n    ) -&gt; float:\n        \"\"\"\n        Evaluate LevelProfile to a scalar at the level period of the data dimension, and as an average over the scenario horizon.\n\n        Args:\n            db (QueryDB | Model): The database or model instance used to fetch the required data.\n            scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n            level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n            unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n                the expression should be unitless.\n            is_max_level (bool | None, optional): Whether to evaluate the expression as a maximum level (with a zero_one profile)\n                or as an average level (with a mean_one profile). If None, the default format of the attribute is used.\n\n        \"\"\"\n        return self._get_data_value(db, scenario_horizon, level_period, unit, is_max_level)\n\n    def shift_intercept(self, value: float, unit: str | None) -&gt; None:\n        \"\"\"Modify the intercept part of (level * profile + intercept) of an attribute by adding a constant value.\"\"\"\n        expr = ensure_expr(\n            ConstantTimeVector(self._ensure_float(value), unit=unit, is_max_level=False),\n            is_level=True,\n            is_profile=False,\n            is_stock=self._IS_STOCK,\n            is_flow=self._IS_FLOW,\n            profile=None,\n        )\n        if self._intercept is None:\n            self._intercept = expr\n        else:\n            self._intercept += expr\n\n    def shift_level(\n        self,\n        value: float | int,\n        unit: str | None = None,\n        reference_period: ReferencePeriod | None = None,\n        is_max_level: bool | None = None,\n        use_profile: bool = True,  # TODO: Remove. Should always use profile. If has profile validate that it is equal to the profile of Level.\n    ) -&gt; None:\n        \"\"\"Modify the level_shift part of (scale * (level + level_shift) * profile + intercept) of an attribute by adding a constant value.\"\"\"\n        # TODO: Not allowed to shift if there is intercept?\n        self._check_type(value, (float, int))\n        self._check_type(unit, (str, type(None)))\n        self._check_type(reference_period, (ReferencePeriod, type(None)))\n        self._check_type(is_max_level, (bool, type(None)))\n        self._check_type(use_profile, bool)\n\n        if is_max_level is None:\n            is_max_level = self._IS_MAX_AND_ZERO_ONE\n\n        expr = ensure_expr(\n            ConstantTimeVector(\n                self._ensure_float(value),\n                unit=unit,\n                is_max_level=is_max_level,\n                reference_period=reference_period,\n            ),\n            is_level=True,\n            is_profile=False,\n            is_stock=self._IS_STOCK,\n            is_flow=self._IS_FLOW,\n            profile=self._profile if use_profile else None,\n        )\n        if self._level_shift is None:\n            self._level_shift = expr\n        else:\n            self._level_shift += expr\n\n    def scale(self, value: float | int) -&gt; None:\n        \"\"\"Modify the scale part of (scale * (level + level_shift) * profile + intercept) of an attribute by multiplying with a constant value.\"\"\"\n        # TODO: Not allowed to scale if there is intercept?\n        expr = ensure_expr(\n            ConstantTimeVector(self._ensure_float(value), unit=None, is_max_level=False),\n            is_level=True,\n            is_profile=False,\n            profile=None,\n        )\n        if self._scale is None:\n            self._scale = expr\n        else:\n            self._scale *= expr\n\n    def _ensure_level_expr(\n        self,\n        level: Expr | str | TimeVector | None,\n        value: float | int | None = None,\n        unit: str | None = None,\n        reference_period: ReferencePeriod | None = None,\n    ) -&gt; Expr | None:\n        if value is not None:\n            level = ConstantTimeVector(\n                scalar=float(value),\n                unit=unit,\n                is_max_level=self._IS_MAX_AND_ZERO_ONE,\n                is_zero_one_profile=None,\n                reference_period=reference_period,\n            )\n        if level is None:\n            return None\n\n        if isinstance(level, Expr):\n            self._check_level_expr(level)\n            return level\n\n        return Expr(\n            src=level,\n            is_flow=self._IS_FLOW,\n            is_stock=self._IS_STOCK,\n            is_level=True,\n            is_profile=False,\n            profile=None,\n        )\n\n    def _ensure_compatible_level_profile_combo(self, level: Expr | None, profile: Expr | None) -&gt; None:\n        \"\"\"Check that all profiles in leaf levels (in level) also exist in profile.\"\"\"\n        if level is None or profile is None:\n            return\n\n        leaf_level_profiles = get_profile_exprs_from_leaf_levels(level)\n        leaf_profile_profiles = get_leaf_profiles(profile)\n\n        for p in leaf_level_profiles:\n            if p not in leaf_profile_profiles:\n                message = (\n                    f\"Incompatible level/profile combination because all profiles in leaf levels (in level) does not exist in profile. \"\n                    f\"Profile expression {p} found in level {level} but not in profile.\"\n                )\n                raise ValueError(message)\n\n    def _check_level_expr(self, expr: Expr) -&gt; None:\n        msg = f\"{self} requires {expr} to be \"\n        if expr.is_stock() != self._IS_STOCK:\n            raise ValueError(msg + f\"is_stock={self._IS_STOCK}\")\n        if expr.is_flow() != self._IS_FLOW:\n            raise ValueError(msg + f\"is_flow={self._IS_STOCK}\")\n        if expr.is_level() is False:\n            raise ValueError(msg + \"is_level=True\")\n        if expr.is_profile() is True:\n            raise ValueError(msg + \"is_profile=False\")\n\n    def _check_profile_expr(self, expr: Expr) -&gt; None:\n        msg = f\"{self} requires {expr} to be \"\n        if expr.is_stock() is True:\n            raise ValueError(msg + \"is_stock=False\")\n        if expr.is_flow() is True:\n            raise ValueError(msg + \"is_flow=False\")\n        if expr.is_level() is True:\n            raise ValueError(msg + \"is_level=False\")\n        if expr.is_profile() is False:\n            raise ValueError(msg + \"is_profile=True\")\n\n    def _ensure_profile_expr(\n        self,\n        value: Expr | str | TimeVector | None,\n    ) -&gt; Expr | None:\n        if value is None:\n            return None\n\n        if isinstance(value, Expr):\n            self._check_profile_expr(value)\n            return value\n\n        return Expr(\n            src=value,\n            is_flow=False,\n            is_stock=False,\n            is_level=False,\n            is_profile=True,\n            profile=None,\n        )\n\n    def _get_data_value(\n        self,\n        db: QueryDB,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_max_level: bool | None,\n    ) -&gt; float:\n        # NB! don't type check db, as this is done in get_level_value and get_profile_vector\n        self._check_type(scenario_horizon, FixedFrequencyTimeIndex)\n        self._check_type(level_period, SinglePeriodTimeIndex)\n        self._check_type(unit, (str, type(None)))\n        self._check_type(is_max_level, (bool, type(None)))\n\n        level_expr = self.get_level()\n\n        if is_max_level is None:\n            is_max_level = self._IS_MAX_AND_ZERO_ONE\n\n        self._check_type(level_expr, (Expr, type(None)))\n        if not isinstance(level_expr, Expr):\n            raise ValueError(\"Attribute level Expr is None. Have you called Solver.solve yet?\")\n\n        level_value = get_level_value(\n            expr=level_expr,\n            db=db,\n            scen_dim=scenario_horizon,\n            data_dim=level_period,\n            unit=unit,\n            is_max=is_max_level,\n        )\n\n        intercept = None\n        if self._intercept is not None:\n            intercept = _get_constant_from_expr(\n                self._intercept,\n                db,\n                unit=unit,\n                data_dim=level_period,\n                scen_dim=scenario_horizon,\n                is_max=is_max_level,\n            )\n\n        if intercept is None:\n            return level_value\n\n        return level_value + intercept\n\n    def _get_scenario_vector(\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_float32: bool = True,\n    ) -&gt; NDArray:\n        \"\"\"Return vector with values along the given scenario horizon using level over level_period.\"\"\"\n        # NB! don't type check db, as this is done in get_level_value and get_profile_vector\n        self._check_type(scenario_horizon, FixedFrequencyTimeIndex)\n        self._check_type(level_period, SinglePeriodTimeIndex)\n        self._check_type(unit, (str, type(None)))\n        self._check_type(is_float32, bool)\n\n        level_expr = self.get_level()\n\n        self._check_type(level_expr, (Expr, type(None)))\n        if not isinstance(level_expr, Expr):\n            raise ValueError(\"Attribute level Expr is None. Have you called Solver.solve yet?\")\n\n        level_value = get_level_value(\n            expr=level_expr,\n            db=db,\n            scen_dim=scenario_horizon,\n            data_dim=level_period,\n            unit=unit,\n            is_max=self._IS_MAX_AND_ZERO_ONE,\n        )\n\n        profile_expr = self.get_profile()\n\n        if profile_expr is None:\n            profile_vector = np.ones(\n                scenario_horizon.get_num_periods(),\n                dtype=np.float32 if is_float32 else np.float64,\n            )\n        else:\n            profile_vector = get_profile_vector(\n                expr=profile_expr,\n                db=db,\n                scen_dim=scenario_horizon,\n                data_dim=level_period,\n                is_zero_one=self._IS_MAX_AND_ZERO_ONE,\n                is_float32=is_float32,\n            )\n\n        intercept = None\n        if self._intercept is not None:\n            intercept = _get_constant_from_expr(\n                self._intercept,\n                db,\n                unit=unit,\n                data_dim=level_period,\n                scen_dim=scenario_horizon,\n                is_max=self._IS_MAX_AND_ZERO_ONE,\n            )\n\n        if intercept is None:\n            return level_value * profile_vector\n\n        return level_value * profile_vector + intercept\n\n    def _has_same_behaviour(self, other: LevelProfile) -&gt; bool:\n        return all(\n            (\n                self._IS_FLOW == other._IS_FLOW,\n                self._IS_STOCK == other._IS_STOCK,\n                self._IS_NOT_NEGATIVE == other._IS_NOT_NEGATIVE,\n                self._IS_MAX_AND_ZERO_ONE == other._IS_MAX_AND_ZERO_ONE,\n                self._IS_INGOING == other._IS_INGOING,\n                self._IS_COST == other._IS_COST,\n                self._IS_UNITLESS == other._IS_UNITLESS,\n            ),\n        )\n\n    def _assert_same_behaviour(self, other: LevelProfile) -&gt; None:\n        if not self._has_same_behaviour(other):\n            message = f\"Not same behaviour for {self} and {other}\"\n            raise ValueError(message)\n\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Return True if other is equal to self.\"\"\"\n        if not isinstance(other, LevelProfile):\n            return False\n        if not self._has_same_behaviour(other):\n            return False\n        return all(\n            (\n                self._level == other._level,\n                self._profile == other._profile,\n                self._level_shift == other._level_shift,\n                self._intercept == other._intercept,\n                self._scale == other._scale,\n            ),\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute hash of self.\"\"\"\n        return hash(\n            (\n                type(self).__name__,\n                self._level,\n                self._profile,\n                self._level_shift,\n                self._intercept,\n                self._scale,\n            ),\n        )\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Return True if other is equal to self.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Return True if other is equal to self.\"\"\"\n    if not isinstance(other, LevelProfile):\n        return False\n    if not self._has_same_behaviour(other):\n        return False\n    return all(\n        (\n            self._level == other._level,\n            self._profile == other._profile,\n            self._level_shift == other._level_shift,\n            self._intercept == other._intercept,\n            self._scale == other._scale,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Compute hash of self.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute hash of self.\"\"\"\n    return hash(\n        (\n            type(self).__name__,\n            self._level,\n            self._profile,\n            self._level_shift,\n            self._intercept,\n            self._scale,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.__init__","title":"<code>__init__(level: Expr | TimeVector | str | None = None, profile: Expr | TimeVector | str | None = None, value: float | int | None = None, unit: str | None = None, level_shift: Expr | None = None, intercept: Expr | None = None, scale: Expr | None = None) -&gt; None</code>","text":"<p>Initialize LevelProfile.</p> <p>See the LevelProfile class docstring for details. A complete LevelProfile is represented as: Scale * (Level + Level_shift) * Profile + Intercept. Normally only Level and Profile are used.</p> <p>Either give level and profile, or value and unit.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Expr | TimeVector | str | None</code> <p>Level Expr. Defaults to None.</p> <code>None</code> <code>profile</code> <code>Expr | TimeVector | str | None</code> <p>Profile Expr. Defaults to None.</p> <code>None</code> <code>value</code> <code>float | int | None</code> <p>A constant value to initialize Level. Defaults to None.</p> <code>None</code> <code>unit</code> <code>str | None</code> <p>Unit of the constant value to initialize Level. Defaults to None.</p> <code>None</code> <code>level_shift</code> <code>Expr | None</code> <p>Level_shift Expr. Defaults to None.</p> <code>None</code> <code>intercept</code> <code>Expr | None</code> <p>Intercept Expr. Defaults to None.</p> <code>None</code> <code>scale</code> <code>Expr | None</code> <p>Scale Expr. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def __init__(\n    self,\n    level: Expr | TimeVector | str | None = None,\n    profile: Expr | TimeVector | str | None = None,\n    value: float | int | None = None,  # To support Price(value=20, unit=\"EUR/MWh\")\n    unit: str | None = None,\n    level_shift: Expr | None = None,\n    intercept: Expr | None = None,\n    scale: Expr | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize LevelProfile.\n\n    See the LevelProfile class docstring for details. A complete LevelProfile is represented as:\n    Scale * (Level + Level_shift) * Profile + Intercept. Normally only Level and Profile are used.\n\n    Either give level and profile, or value and unit.\n\n    Args:\n        level (Expr | TimeVector | str | None, optional): Level Expr. Defaults to None.\n        profile (Expr | TimeVector | str | None, optional): Profile Expr. Defaults to None.\n        value (float | int | None, optional): A constant value to initialize Level. Defaults to None.\n        unit (str | None, optional): Unit of the constant value to initialize Level. Defaults to None.\n        level_shift (Expr | None, optional): Level_shift Expr. Defaults to None.\n        intercept (Expr | None, optional): Intercept Expr. Defaults to None.\n        scale (Expr | None, optional): Scale Expr. Defaults to None.\n\n    \"\"\"\n    self._assert_invariants()\n\n    self._check_type(value, (float, int, type(None)))\n    self._check_type(unit, (str, type(None)))\n    self._check_type(level, (Expr, TimeVector, str, type(None)))\n    self._check_type(profile, (Expr, TimeVector, str, type(None)))\n    self._check_type(level_shift, (Expr, type(None)))\n    self._check_type(intercept, (Expr, type(None)))\n    self._check_type(scale, (Expr, type(None)))\n    level = self._ensure_level_expr(level, value, unit)\n    profile = self._ensure_profile_expr(profile)\n    self._ensure_compatible_level_profile_combo(level, profile)\n    self._ensure_compatible_level_profile_combo(level_shift, profile)\n    self._level: Expr | None = level\n    self._profile: Expr | None = profile\n    self._level_shift: Expr | None = level_shift\n    self._intercept: Expr | None = intercept\n    self._scale: Expr | None = scale\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in expressions to loaders.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in expressions to loaders.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self.get_level())\n    add_loaders_if(loaders, self.get_profile())\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Set all internal fields to None.</p> <p>You may want to use this to get exogenous flow to use capacities instead of volume.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Set all internal fields to None.\n\n    You may want to use this to get exogenous flow to use capacities instead of volume.\n    \"\"\"\n    self._level = None\n    self._profile = None\n    self._level_shift = None\n    self._intercept = None\n    self._scale = None\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.copy_from","title":"<code>copy_from(other: LevelProfile) -&gt; None</code>","text":"<p>Copy fields from other.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def copy_from(self, other: LevelProfile) -&gt; None:\n    \"\"\"Copy fields from other.\"\"\"\n    self._check_type(other, LevelProfile)\n    self._assert_same_behaviour(other)\n    self._level = other._level\n    self._profile = other._profile\n    self._level_shift = other._level_shift\n    self._intercept = other._intercept\n    self._scale = other._scale\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.get_data_value","title":"<code>get_data_value(db: QueryDB | Model, scenario_horizon: FixedFrequencyTimeIndex, level_period: SinglePeriodTimeIndex, unit: str | None, is_max_level: bool | None = None) -&gt; float</code>","text":"<p>Evaluate LevelProfile to a scalar at the level period of the data dimension, and as an average over the scenario horizon.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>QueryDB | Model</code> <p>The database or model instance used to fetch the required data.</p> required <code>scenario_horizon</code> <code>FixedFrequencyTimeIndex</code> <p>TimeIndex of the scenario dimension to evaluate profiles.</p> required <code>level_period</code> <code>SinglePeriodTimeIndex</code> <p>TimeIndex of the data dimension to evaluate levels.</p> required <code>unit</code> <code>str | None</code> <p>The unit to convert the resulting values into (e.g., MW, GWh). If None, the expression should be unitless.</p> required <code>is_max_level</code> <code>bool | None</code> <p>Whether to evaluate the expression as a maximum level (with a zero_one profile) or as an average level (with a mean_one profile). If None, the default format of the attribute is used.</p> <code>None</code> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_data_value(\n    self,\n    db: QueryDB | Model,\n    scenario_horizon: FixedFrequencyTimeIndex,\n    level_period: SinglePeriodTimeIndex,\n    unit: str | None,\n    is_max_level: bool | None = None,\n) -&gt; float:\n    \"\"\"\n    Evaluate LevelProfile to a scalar at the level period of the data dimension, and as an average over the scenario horizon.\n\n    Args:\n        db (QueryDB | Model): The database or model instance used to fetch the required data.\n        scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n        level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n        unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n            the expression should be unitless.\n        is_max_level (bool | None, optional): Whether to evaluate the expression as a maximum level (with a zero_one profile)\n            or as an average level (with a mean_one profile). If None, the default format of the attribute is used.\n\n    \"\"\"\n    return self._get_data_value(db, scenario_horizon, level_period, unit, is_max_level)\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.get_intercept","title":"<code>get_intercept() -&gt; Expr | None</code>","text":"<p>Get intercept part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_intercept(self) -&gt; Expr | None:\n    \"\"\"Get intercept part of (level * profile + intercept).\"\"\"\n    intercept = self._intercept\n    if self._scale is not None:\n        intercept *= self._scale\n    return intercept\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.get_level","title":"<code>get_level() -&gt; Expr | None</code>","text":"<p>Get level part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_level(self) -&gt; Expr | None:\n    \"\"\"Get level part of (level * profile + intercept).\"\"\"\n    level = self._level\n\n    if level is None:\n        return None\n\n    if level.is_leaf():\n        level = Expr(\n            src=level.get_src(),\n            operations=level.get_operations(expect_ops=False, copy_list=True),\n            is_stock=level.is_stock(),\n            is_flow=level.is_flow(),\n            is_level=True,\n            is_profile=False,\n            profile=self._profile,\n        )\n\n    if self._level_shift is not None:\n        level += self._level_shift\n\n    if self._scale is not None:\n        level *= self._scale\n\n    return level\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.get_level_unit_set","title":"<code>get_level_unit_set(db: QueryDB | Model) -&gt; set[TimeIndex]</code>","text":"<p>Return set with all units behind level expression.</p> <p>Useful for discovering valid unit input to get_level_value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_level_unit_set(\n    self,\n    db: QueryDB | Model,\n) -&gt; set[TimeIndex]:\n    \"\"\"\n    Return set with all units behind level expression.\n\n    Useful for discovering valid unit input to get_level_value.\n    \"\"\"\n    if not self.has_level():\n        return set()\n    return get_units_from_expr(db, self.get_level())\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.get_profile","title":"<code>get_profile() -&gt; Expr | None</code>","text":"<p>Get profile part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_profile(self) -&gt; Expr | None:\n    \"\"\"Get profile part of (level * profile + intercept).\"\"\"\n    return self._profile\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.get_profile_timeindex_set","title":"<code>get_profile_timeindex_set(db: QueryDB | Model) -&gt; set[TimeIndex]</code>","text":"<p>Return set with all TimeIndex behind profile expression.</p> <p>Can be used to run optimized queries, i.e. not asking for finer time resolutions than necessary.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_profile_timeindex_set(\n    self,\n    db: QueryDB | Model,\n) -&gt; set[TimeIndex]:\n    \"\"\"\n    Return set with all TimeIndex behind profile expression.\n\n    Can be used to run optimized queries, i.e. not asking for\n    finer time resolutions than necessary.\n    \"\"\"\n    if not self.has_profile():\n        return set()\n    return get_timeindexes_from_expr(db, self.get_profile())\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.get_scenario_vector","title":"<code>get_scenario_vector(db: QueryDB | Model, scenario_horizon: FixedFrequencyTimeIndex, level_period: SinglePeriodTimeIndex, unit: str | None, is_float32: bool = True) -&gt; NDArray</code>","text":"<p>Evaluate LevelProfile over the periods in scenario dimension, and at the level period of the data dimension.</p> <p>Underlying profiles are evalutated over the scenario dimension, and levels are evalutated to scalars over level_period in the data dimension.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>QueryDB | Model</code> <p>The database or model instance used to fetch the required data.</p> required <code>scenario_horizon</code> <code>FixedFrequencyTimeIndex</code> <p>TimeIndex of the scenario dimension to evaluate profiles.</p> required <code>level_period</code> <code>SinglePeriodTimeIndex</code> <p>TimeIndex of the data dimension to evaluate levels.</p> required <code>unit</code> <code>str | None</code> <p>The unit to convert the resulting values into (e.g., MW, GWh). If None, the expression should be unitless.</p> required <code>is_float32</code> <code>bool</code> <p>Whether to return the vector as a NumPy array with <code>float32</code> precision. Defaults to True.</p> <code>True</code> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_scenario_vector(\n    self,\n    db: QueryDB | Model,\n    scenario_horizon: FixedFrequencyTimeIndex,\n    level_period: SinglePeriodTimeIndex,\n    unit: str | None,\n    is_float32: bool = True,\n) -&gt; NDArray:\n    \"\"\"\n    Evaluate LevelProfile over the periods in scenario dimension, and at the level period of the data dimension.\n\n    Underlying profiles are evalutated over the scenario dimension,\n    and levels are evalutated to scalars over level_period in the data dimension.\n\n    Args:\n        db (QueryDB | Model): The database or model instance used to fetch the required data.\n        scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n        level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n        unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n            the expression should be unitless.\n        is_float32 (bool, optional): Whether to return the vector as a NumPy array with `float32`\n            precision. Defaults to True.\n\n    \"\"\"\n    return self._get_scenario_vector(db, scenario_horizon, level_period, unit, is_float32)\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.has_intercept","title":"<code>has_intercept() -&gt; bool</code>","text":"<p>Return True if get_intercept will return value not None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def has_intercept(self) -&gt; bool:\n    \"\"\"Return True if get_intercept will return value not None.\"\"\"\n    return self._intercept is not None\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.has_level","title":"<code>has_level() -&gt; bool</code>","text":"<p>Return True if get_level will return value not None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def has_level(self) -&gt; bool:\n    \"\"\"Return True if get_level will return value not None.\"\"\"\n    return (self._level is not None) or (self._level_shift is not None)\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.has_profile","title":"<code>has_profile() -&gt; bool</code>","text":"<p>Return True if get_profile will return value not None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def has_profile(self) -&gt; bool:\n    \"\"\"Return True if get_profile will return value not None.\"\"\"\n    return self._profile is not None\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.is_cost","title":"<code>is_cost() -&gt; bool | None</code>","text":"<p>Return True if attribute is objective function cost coefficient.</p> <p>Return False if attribute is objective function revenue coefficient.</p> <p>Return None if not applicable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_cost(self) -&gt; bool | None:\n    \"\"\"\n    Return True if attribute is objective function cost coefficient.\n\n    Return False if attribute is objective function revenue coefficient.\n\n    Return None if not applicable.\n    \"\"\"\n    return self._IS_COST\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.is_flow","title":"<code>is_flow() -&gt; bool</code>","text":"<p>Return True if attribute is a flow variable.</p> <p>Return False if attribute is not a flow variable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_flow(self) -&gt; bool:\n    \"\"\"\n    Return True if attribute is a flow variable.\n\n    Return False if attribute is not a flow variable.\n    \"\"\"\n    return self._IS_FLOW\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.is_ingoing","title":"<code>is_ingoing() -&gt; bool | None</code>","text":"<p>Return True if attribute is ingoing.</p> <p>Return True if attribute is outgoing.</p> <p>Return None if not applicable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_ingoing(self) -&gt; bool | None:\n    \"\"\"\n    Return True if attribute is ingoing.\n\n    Return True if attribute is outgoing.\n\n    Return None if not applicable.\n    \"\"\"\n    return self._IS_INGOING\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.is_max_and_zero_one","title":"<code>is_max_and_zero_one() -&gt; bool</code>","text":"<p>When True level should be max (not average) and corresponding profile should be zero_one (not mean_one).</p> <p>When False level should be average (not max) and corresponding profile should be mean_one (not zero_one).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_max_and_zero_one(self) -&gt; bool:\n    \"\"\"\n    When True level should be max (not average) and corresponding profile should be zero_one (not mean_one).\n\n    When False level should be average (not max) and corresponding profile should be mean_one (not zero_one).\n    \"\"\"\n    return self._IS_MAX_AND_ZERO_ONE\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.is_not_negative","title":"<code>is_not_negative() -&gt; bool</code>","text":"<p>Return True if attribute is not allowed to have negative values.</p> <p>Return False if attribute can have both positive and negative values.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_not_negative(self) -&gt; bool:\n    \"\"\"\n    Return True if attribute is not allowed to have negative values.\n\n    Return False if attribute can have both positive and negative values.\n    \"\"\"\n    return self._IS_NOT_NEGATIVE\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.is_stock","title":"<code>is_stock() -&gt; bool</code>","text":"<p>Return True if attribute is a stock variable.</p> <p>Return False if attribute is not a stock variable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_stock(self) -&gt; bool:\n    \"\"\"\n    Return True if attribute is a stock variable.\n\n    Return False if attribute is not a stock variable.\n    \"\"\"\n    return self._IS_STOCK\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.is_unitless","title":"<code>is_unitless() -&gt; bool | None</code>","text":"<p>Return True if attribute is known to be unitless.</p> <p>Return False if attribute is known to have a unit that is not None.</p> <p>Return None if not applicable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_unitless(self) -&gt; bool | None:\n    \"\"\"\n    Return True if attribute is known to be unitless.\n\n    Return False if attribute is known to have a unit that is not None.\n\n    Return None if not applicable.\n    \"\"\"\n    return self._IS_UNITLESS\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.scale","title":"<code>scale(value: float | int) -&gt; None</code>","text":"<p>Modify the scale part of (scale * (level + level_shift) * profile + intercept) of an attribute by multiplying with a constant value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def scale(self, value: float | int) -&gt; None:\n    \"\"\"Modify the scale part of (scale * (level + level_shift) * profile + intercept) of an attribute by multiplying with a constant value.\"\"\"\n    # TODO: Not allowed to scale if there is intercept?\n    expr = ensure_expr(\n        ConstantTimeVector(self._ensure_float(value), unit=None, is_max_level=False),\n        is_level=True,\n        is_profile=False,\n        profile=None,\n    )\n    if self._scale is None:\n        self._scale = expr\n    else:\n        self._scale *= expr\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.set_intercept","title":"<code>set_intercept(value: Expr | None) -&gt; None</code>","text":"<p>Set intercept part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def set_intercept(self, value: Expr | None) -&gt; None:\n    \"\"\"Set intercept part of (level * profile + intercept).\"\"\"\n    self._check_type(value, (Expr, type(None)))\n    if value is not None:\n        self._check_level_expr(value)\n    self._intercept = value\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.set_level","title":"<code>set_level(level: Expr | TimeVector | str | None) -&gt; None</code>","text":"<p>Set level part of (scale * (level + level_shift) * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def set_level(self, level: Expr | TimeVector | str | None) -&gt; None:\n    \"\"\"Set level part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n    self._check_type(level, (Expr, TimeVector, str, type(None)))\n    level = self._ensure_level_expr(level)\n    self._ensure_compatible_level_profile_combo(level, self._profile)\n    self._level = level\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.set_profile","title":"<code>set_profile(profile: Expr | TimeVector | str | None) -&gt; None</code>","text":"<p>Set profile part of (scale * (level + level_shift) * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def set_profile(self, profile: Expr | TimeVector | str | None) -&gt; None:\n    \"\"\"Set profile part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n    self._check_type(profile, (Expr, TimeVector, str, type(None)))\n    profile = self._ensure_profile_expr(profile)\n    self._ensure_compatible_level_profile_combo(self._level, profile)\n    self._profile = profile\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.shift_intercept","title":"<code>shift_intercept(value: float, unit: str | None) -&gt; None</code>","text":"<p>Modify the intercept part of (level * profile + intercept) of an attribute by adding a constant value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def shift_intercept(self, value: float, unit: str | None) -&gt; None:\n    \"\"\"Modify the intercept part of (level * profile + intercept) of an attribute by adding a constant value.\"\"\"\n    expr = ensure_expr(\n        ConstantTimeVector(self._ensure_float(value), unit=unit, is_max_level=False),\n        is_level=True,\n        is_profile=False,\n        is_stock=self._IS_STOCK,\n        is_flow=self._IS_FLOW,\n        profile=None,\n    )\n    if self._intercept is None:\n        self._intercept = expr\n    else:\n        self._intercept += expr\n</code></pre>"},{"location":"reference/#framcore.attributes.LevelProfile.shift_level","title":"<code>shift_level(value: float | int, unit: str | None = None, reference_period: ReferencePeriod | None = None, is_max_level: bool | None = None, use_profile: bool = True) -&gt; None</code>","text":"<p>Modify the level_shift part of (scale * (level + level_shift) * profile + intercept) of an attribute by adding a constant value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def shift_level(\n    self,\n    value: float | int,\n    unit: str | None = None,\n    reference_period: ReferencePeriod | None = None,\n    is_max_level: bool | None = None,\n    use_profile: bool = True,  # TODO: Remove. Should always use profile. If has profile validate that it is equal to the profile of Level.\n) -&gt; None:\n    \"\"\"Modify the level_shift part of (scale * (level + level_shift) * profile + intercept) of an attribute by adding a constant value.\"\"\"\n    # TODO: Not allowed to shift if there is intercept?\n    self._check_type(value, (float, int))\n    self._check_type(unit, (str, type(None)))\n    self._check_type(reference_period, (ReferencePeriod, type(None)))\n    self._check_type(is_max_level, (bool, type(None)))\n    self._check_type(use_profile, bool)\n\n    if is_max_level is None:\n        is_max_level = self._IS_MAX_AND_ZERO_ONE\n\n    expr = ensure_expr(\n        ConstantTimeVector(\n            self._ensure_float(value),\n            unit=unit,\n            is_max_level=is_max_level,\n            reference_period=reference_period,\n        ),\n        is_level=True,\n        is_profile=False,\n        is_stock=self._IS_STOCK,\n        is_flow=self._IS_FLOW,\n        profile=self._profile if use_profile else None,\n    )\n    if self._level_shift is None:\n        self._level_shift = expr\n    else:\n        self._level_shift += expr\n</code></pre>"},{"location":"reference/#framcore.attributes.Loss","title":"<code>Loss</code>","text":"<p>               Bases: <code>ArrowCoefficient</code></p> <p>Concrete class representing a loss coefficient attribute, indicating a unitless coefficient.</p> <p>Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Loss(ArrowCoefficient):  # TODO: Make a loss for storage that is percentage per time\n    \"\"\"\n    Concrete class representing a loss coefficient attribute, indicating a unitless coefficient.\n\n    Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.MaxFlowVolume","title":"<code>MaxFlowVolume</code>","text":"<p>               Bases: <code>FlowVolume</code></p> <p>Concrete class representing a maximum flow volume attribute, indicating a flow variable with maximum values.</p> <p>Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class MaxFlowVolume(FlowVolume):\n    \"\"\"\n    Concrete class representing a maximum flow volume attribute, indicating a flow variable with maximum values.\n\n    Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_MAX_AND_ZERO_ONE = True\n</code></pre>"},{"location":"reference/#framcore.attributes.ObjectiveCoefficient","title":"<code>ObjectiveCoefficient</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Abstract class representing an objective coefficient attribute, indicating cost or revenue coefficients in the objective function.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class ObjectiveCoefficient(Coefficient):\n    \"\"\"\n    Abstract class representing an objective coefficient attribute, indicating cost or revenue coefficients in the objective function.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_UNITLESS = False\n    _IS_NOT_NEGATIVE = False\n</code></pre>"},{"location":"reference/#framcore.attributes.Price","title":"<code>Price</code>","text":"<p>               Bases: <code>ShadowPrice</code></p> <p>Concrete class representing a price attribute, indicating the price of a commodity at a specific node.</p> <p>Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Price(ShadowPrice):\n    \"\"\"\n    Concrete class representing a price attribute, indicating the price of a commodity at a specific node.\n\n    Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.Proportion","title":"<code>Proportion</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Concrete class representing a proportion coefficient attribute, indicating a unitless coefficient between 0 and 1.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Proportion(Coefficient):\n    \"\"\"\n    Concrete class representing a proportion coefficient attribute, indicating a unitless coefficient between 0 and 1.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.ReservePrice","title":"<code>ReservePrice</code>","text":"<p>               Bases: <code>ObjectiveCoefficient</code></p> <p>Concrete class representing a reserve price attribute, indicating revenue coefficients in the objective function.</p> <p>Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class ReservePrice(ObjectiveCoefficient):\n    \"\"\"\n    Concrete class representing a reserve price attribute, indicating revenue coefficients in the objective function.\n\n    Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_COST = False\n</code></pre>"},{"location":"reference/#framcore.attributes.ShadowPrice","title":"<code>ShadowPrice</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Abstract class representing a shadow price attribute, indicating that the attribute has a unit and might be negative.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class ShadowPrice(Coefficient):\n    \"\"\"\n    Abstract class representing a shadow price attribute, indicating that the attribute has a unit and might be negative.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_UNITLESS = False\n    _IS_NOT_NEGATIVE = False\n</code></pre>"},{"location":"reference/#framcore.attributes.StockVolume","title":"<code>StockVolume</code>","text":"<p>               Bases: <code>LevelProfile</code></p> <p>Concrete class representing a stock volume attribute, indicating a stock variable with maximum values.</p> <p>Subclass of LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class StockVolume(LevelProfile):\n    \"\"\"\n    Concrete class representing a stock volume attribute, indicating a stock variable with maximum values.\n\n    Subclass of LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_STOCK = True\n    _IS_MAX_AND_ZERO_ONE = True\n</code></pre>"},{"location":"reference/#framcore.attributes.WaterValue","title":"<code>WaterValue</code>","text":"<p>               Bases: <code>ShadowPrice</code></p> <p>Concrete class representing a water value attribute, indicating the value of water in the system.</p> <p>Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class WaterValue(ShadowPrice):\n    \"\"\"\n    Concrete class representing a water value attribute, indicating the value of water in the system.\n\n    Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow","title":"<code>Arrow</code>","text":""},{"location":"reference/#framcore.attributes.Arrow.Arrow","title":"<code>Arrow</code>","text":"<p>               Bases: <code>Base</code></p> <p>Arrow class is used by Flows to represent contribution of its commodity to Nodes.</p> <p>The Arrow has direction to determine input or output (is_ingoing), and parameters for the contribution of the Flow to the Node. The main parameters are conversion, efficiency and loss which together form the coefficient = conversion * (1 / efficiency) * (1 - loss) Arrow has its own implementation of get_scenario_vector and get_data_value to calculate the coefficient shown above.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>class Arrow(Base):\n    \"\"\"\n    Arrow class is used by Flows to represent contribution of its commodity to Nodes.\n\n    The Arrow has direction to determine input or output (is_ingoing), and parameters for the contribution of the Flow to the Node.\n    The main parameters are conversion, efficiency and loss which together form the coefficient = conversion * (1 / efficiency) * (1 - loss)\n    Arrow has its own implementation of get_scenario_vector and get_data_value to calculate the coefficient shown above.\n    \"\"\"\n\n    def __init__(\n        self,\n        node: str,\n        is_ingoing: bool,\n        conversion: Conversion | None = None,\n        efficiency: Efficiency | None = None,\n        loss: Loss | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the Arrow class.\"\"\"\n        self._check_type(node, str)\n        self._check_type(is_ingoing, bool)\n        self._check_type(conversion, (Conversion, type(None)))\n        self._check_type(efficiency, (Efficiency, type(None)))\n        self._check_type(loss, (Loss, type(None)))\n        self._node = node\n        self._is_ingoing = is_ingoing\n        self._conversion = conversion\n        self._efficiency = efficiency\n        self._loss = loss\n\n    def get_node(self) -&gt; str:\n        \"\"\"Get the node the arrow is pointing to.\"\"\"\n        return self._node\n\n    def set_node(self, node: str) -&gt; None:\n        \"\"\"Set the node the arrow is pointing to.\"\"\"\n        self._check_type(node, str)\n        self._node = node\n\n    def is_ingoing(self) -&gt; bool:\n        \"\"\"\n        Return True if arrow is ingoing.\n\n        Ingoing means the flow variable supplies to node.\n        Outgoing means the flow variable takes out of node.\n        \"\"\"\n        return self._is_ingoing\n\n    def get_conversion(self) -&gt; Conversion | None:\n        \"\"\"Get the conversion.\"\"\"\n        return self._conversion\n\n    def set_conversion(self, value: Conversion | None) -&gt; None:\n        \"\"\"Set the conversion.\"\"\"\n        self._check_type(value, Conversion, type(None))\n        self._conversion = value\n\n    def get_efficiency(self) -&gt; Efficiency | None:\n        \"\"\"Get the efficiency.\"\"\"\n        return self._efficiency\n\n    def set_efficiency(self, value: Efficiency | None) -&gt; None:\n        \"\"\"Set the efficiency.\"\"\"\n        self._check_type(value, Efficiency, type(None))\n        self._efficiency = value\n\n    def get_loss(self) -&gt; Loss | None:\n        \"\"\"Get the loss.\"\"\"\n        return self._loss\n\n    def set_loss(self, value: Loss | None) -&gt; None:\n        \"\"\"Set the loss.\"\"\"\n        self._check_type(value, Loss, type(None))\n        self._loss = value\n\n    def has_profile(self) -&gt; bool:\n        \"\"\"Return True if any of conversion, efficiency or loss has profile.\"\"\"\n        if self._conversion is not None and self._conversion.has_profile():\n            return True\n        if self._efficiency is not None and self._efficiency.has_profile():\n            return True\n        return bool(self._loss is not None and self._loss.has_profile())\n\n    def get_conversion_unit_set(\n        self,\n        db: QueryDB | Model,\n    ) -&gt; set[str]:\n        \"\"\"Get set of units behind conversion level expr (if any).\"\"\"\n        if self._conversion is None:\n            return set()\n        return self._conversion.get_level_unit_set(db)\n\n    def get_profile_timeindex_set(\n        self,\n        db: QueryDB | Model,\n    ) -&gt; set[TimeIndex]:\n        \"\"\"\n        Get set of timeindexes behind profile.\n\n        Can be used to run optimized queries, i.e. not asking for\n        finer time resolutions than necessary.\n        \"\"\"\n        if self.has_profile() is None:\n            return set()\n        s = set()\n        if self._conversion is not None:\n            s.update(self._conversion.get_profile_timeindex_set(db))\n        if self._loss is not None:\n            s.update(self._loss.get_profile_timeindex_set(db))\n        if self._efficiency is not None:\n            s.update(self._efficiency.get_profile_timeindex_set(db))\n        return s\n\n    def get_scenario_vector(  # noqa: C901, PLR0915\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_float32: bool = True,\n    ) -&gt; NDArray:\n        \"\"\"Return vector with values along the given scenario horizon using level over level_period.\"\"\"\n        conversion_vector = None\n        efficiency_vector = None\n        loss_vector = None\n        conversion_value = None\n        efficiency_value = None\n        loss_value = None\n\n        if self._conversion is not None:\n            if self._conversion.has_profile():\n                conversion_vector = self._conversion.get_scenario_vector(\n                    db=db,\n                    scenario_horizon=scenario_horizon,\n                    level_period=level_period,\n                    unit=unit,\n                    is_float32=is_float32,\n                )\n            elif self._conversion.has_level():\n                conversion_value = self._conversion.get_data_value(\n                    db=db,\n                    scenario_horizon=scenario_horizon,\n                    level_period=level_period,\n                    unit=unit,\n                )\n                conversion_value = float(conversion_value)\n\n        if self._efficiency is not None:\n            if self._efficiency.has_profile():\n                efficiency_vector = self._efficiency.get_scenario_vector(\n                    db=db,\n                    scenario_horizon=scenario_horizon,\n                    level_period=level_period,\n                    unit=None,\n                    is_float32=is_float32,\n                )\n            elif self._efficiency.has_level():\n                efficiency_value = self._efficiency.get_data_value(\n                    db=db,\n                    scenario_horizon=scenario_horizon,\n                    level_period=level_period,\n                    unit=None,\n                )\n                efficiency_value = float(efficiency_value)\n\n        if self._loss is not None:\n            if self._loss.has_profile():\n                loss_vector = self._loss.get_scenario_vector(\n                    db=db,\n                    scenario_horizon=scenario_horizon,\n                    level_period=level_period,\n                    unit=None,\n                    is_float32=is_float32,\n                )\n            elif self._loss.has_level():\n                loss_value = self._loss.get_data_value(\n                    db=db,\n                    scenario_horizon=scenario_horizon,\n                    level_period=level_period,\n                    unit=None,\n                )\n                loss_value = float(loss_value)\n\n        if conversion_value is not None:\n            assert conversion_value &gt;= 0, f\"Arrow with invalid conversion ({conversion_value}): {self}\"\n            out = conversion_value\n        else:\n            out = 1.0\n\n        if efficiency_value is not None:\n            assert efficiency_value &gt; 0, f\"Arrow with invalid efficiency ({efficiency_value}): {self}\"\n            out = out / efficiency_value\n\n        if loss_value is not None:\n            assert loss_value &gt;= 0 or loss_value &lt; 1, f\"Arrow with invalid loss ({loss_value}): {self}\"\n            out = out - out * loss_value\n\n        if conversion_vector is not None:\n            np.multiply(conversion_vector, out, out=conversion_vector)\n            out = conversion_vector\n\n        if efficiency_vector is not None:\n            if isinstance(out, float):\n                np.divide(out, efficiency_vector, out=efficiency_vector)\n                out = efficiency_vector\n            else:\n                np.divide(out, efficiency_vector, out=out)\n\n        if loss_vector is not None:\n            if isinstance(out, float):\n                np.multiply(out, loss_vector, out=loss_vector)\n                np.subtract(out, loss_vector, out=loss_vector)\n                out = loss_vector\n            else:\n                np.multiply(out, loss_vector, out=loss_vector)\n                np.subtract(out, loss_vector, out=out)\n\n        if isinstance(out, float):\n            num_periods = scenario_horizon.get_num_periods()\n            vector = np.ones(num_periods, dtype=np.float32 if is_float32 else np.float64)\n            vector.fill(out)\n            return vector\n\n        return out\n\n    def get_data_value(\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_max_level: bool = False,\n    ) -&gt; float:\n        \"\"\"Return float for level_period.\"\"\"\n        conversion_value = None\n        efficiency_value = None\n        loss_value = None\n\n        if self._conversion is not None and self._conversion.has_level():\n            conversion_value = self._conversion.get_data_value(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=unit,\n                is_max_level=is_max_level,\n            )\n            conversion_value = float(conversion_value)\n\n        if self._efficiency is not None and self._efficiency.has_level():\n            efficiency_value = self._efficiency.get_data_value(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=None,\n                is_max_level=is_max_level,\n            )\n            efficiency_value = float(efficiency_value)\n\n        if self._loss is not None and self._loss.has_level():\n            loss_value = self._loss.get_data_value(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=None,\n                is_max_level=is_max_level,\n            )\n            loss_value = float(loss_value)\n\n        if conversion_value is not None:\n            assert conversion_value &gt;= 0, f\"Arrow with invalid conversion ({conversion_value}): {self}\"\n            out = conversion_value\n        else:\n            out = 1.0\n\n        if efficiency_value is not None:\n            assert efficiency_value &gt; 0, f\"Arrow with invalid efficiency ({efficiency_value}): {self}\"\n            out = out / efficiency_value\n\n        if loss_value is not None:\n            assert loss_value &gt;= 0 or loss_value &lt; 1, f\"Arrow with invalid loss ({loss_value}): {self}\"\n            out = out - out * loss_value\n\n        return out\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self.get_conversion())\n        add_loaders_if(loaders, self.get_loss())\n        add_loaders_if(loaders, self.get_efficiency())\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.__init__","title":"<code>__init__(node: str, is_ingoing: bool, conversion: Conversion | None = None, efficiency: Efficiency | None = None, loss: Loss | None = None) -&gt; None</code>","text":"<p>Initialize the Arrow class.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def __init__(\n    self,\n    node: str,\n    is_ingoing: bool,\n    conversion: Conversion | None = None,\n    efficiency: Efficiency | None = None,\n    loss: Loss | None = None,\n) -&gt; None:\n    \"\"\"Initialize the Arrow class.\"\"\"\n    self._check_type(node, str)\n    self._check_type(is_ingoing, bool)\n    self._check_type(conversion, (Conversion, type(None)))\n    self._check_type(efficiency, (Efficiency, type(None)))\n    self._check_type(loss, (Loss, type(None)))\n    self._node = node\n    self._is_ingoing = is_ingoing\n    self._conversion = conversion\n    self._efficiency = efficiency\n    self._loss = loss\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in attributes to loaders.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self.get_conversion())\n    add_loaders_if(loaders, self.get_loss())\n    add_loaders_if(loaders, self.get_efficiency())\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_conversion","title":"<code>get_conversion() -&gt; Conversion | None</code>","text":"<p>Get the conversion.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_conversion(self) -&gt; Conversion | None:\n    \"\"\"Get the conversion.\"\"\"\n    return self._conversion\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_conversion_unit_set","title":"<code>get_conversion_unit_set(db: QueryDB | Model) -&gt; set[str]</code>","text":"<p>Get set of units behind conversion level expr (if any).</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_conversion_unit_set(\n    self,\n    db: QueryDB | Model,\n) -&gt; set[str]:\n    \"\"\"Get set of units behind conversion level expr (if any).\"\"\"\n    if self._conversion is None:\n        return set()\n    return self._conversion.get_level_unit_set(db)\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_data_value","title":"<code>get_data_value(db: QueryDB | Model, scenario_horizon: FixedFrequencyTimeIndex, level_period: SinglePeriodTimeIndex, unit: str | None, is_max_level: bool = False) -&gt; float</code>","text":"<p>Return float for level_period.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_data_value(\n    self,\n    db: QueryDB | Model,\n    scenario_horizon: FixedFrequencyTimeIndex,\n    level_period: SinglePeriodTimeIndex,\n    unit: str | None,\n    is_max_level: bool = False,\n) -&gt; float:\n    \"\"\"Return float for level_period.\"\"\"\n    conversion_value = None\n    efficiency_value = None\n    loss_value = None\n\n    if self._conversion is not None and self._conversion.has_level():\n        conversion_value = self._conversion.get_data_value(\n            db=db,\n            scenario_horizon=scenario_horizon,\n            level_period=level_period,\n            unit=unit,\n            is_max_level=is_max_level,\n        )\n        conversion_value = float(conversion_value)\n\n    if self._efficiency is not None and self._efficiency.has_level():\n        efficiency_value = self._efficiency.get_data_value(\n            db=db,\n            scenario_horizon=scenario_horizon,\n            level_period=level_period,\n            unit=None,\n            is_max_level=is_max_level,\n        )\n        efficiency_value = float(efficiency_value)\n\n    if self._loss is not None and self._loss.has_level():\n        loss_value = self._loss.get_data_value(\n            db=db,\n            scenario_horizon=scenario_horizon,\n            level_period=level_period,\n            unit=None,\n            is_max_level=is_max_level,\n        )\n        loss_value = float(loss_value)\n\n    if conversion_value is not None:\n        assert conversion_value &gt;= 0, f\"Arrow with invalid conversion ({conversion_value}): {self}\"\n        out = conversion_value\n    else:\n        out = 1.0\n\n    if efficiency_value is not None:\n        assert efficiency_value &gt; 0, f\"Arrow with invalid efficiency ({efficiency_value}): {self}\"\n        out = out / efficiency_value\n\n    if loss_value is not None:\n        assert loss_value &gt;= 0 or loss_value &lt; 1, f\"Arrow with invalid loss ({loss_value}): {self}\"\n        out = out - out * loss_value\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_efficiency","title":"<code>get_efficiency() -&gt; Efficiency | None</code>","text":"<p>Get the efficiency.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_efficiency(self) -&gt; Efficiency | None:\n    \"\"\"Get the efficiency.\"\"\"\n    return self._efficiency\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_loss","title":"<code>get_loss() -&gt; Loss | None</code>","text":"<p>Get the loss.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_loss(self) -&gt; Loss | None:\n    \"\"\"Get the loss.\"\"\"\n    return self._loss\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_node","title":"<code>get_node() -&gt; str</code>","text":"<p>Get the node the arrow is pointing to.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_node(self) -&gt; str:\n    \"\"\"Get the node the arrow is pointing to.\"\"\"\n    return self._node\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_profile_timeindex_set","title":"<code>get_profile_timeindex_set(db: QueryDB | Model) -&gt; set[TimeIndex]</code>","text":"<p>Get set of timeindexes behind profile.</p> <p>Can be used to run optimized queries, i.e. not asking for finer time resolutions than necessary.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_profile_timeindex_set(\n    self,\n    db: QueryDB | Model,\n) -&gt; set[TimeIndex]:\n    \"\"\"\n    Get set of timeindexes behind profile.\n\n    Can be used to run optimized queries, i.e. not asking for\n    finer time resolutions than necessary.\n    \"\"\"\n    if self.has_profile() is None:\n        return set()\n    s = set()\n    if self._conversion is not None:\n        s.update(self._conversion.get_profile_timeindex_set(db))\n    if self._loss is not None:\n        s.update(self._loss.get_profile_timeindex_set(db))\n    if self._efficiency is not None:\n        s.update(self._efficiency.get_profile_timeindex_set(db))\n    return s\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.get_scenario_vector","title":"<code>get_scenario_vector(db: QueryDB | Model, scenario_horizon: FixedFrequencyTimeIndex, level_period: SinglePeriodTimeIndex, unit: str | None, is_float32: bool = True) -&gt; NDArray</code>","text":"<p>Return vector with values along the given scenario horizon using level over level_period.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def get_scenario_vector(  # noqa: C901, PLR0915\n    self,\n    db: QueryDB | Model,\n    scenario_horizon: FixedFrequencyTimeIndex,\n    level_period: SinglePeriodTimeIndex,\n    unit: str | None,\n    is_float32: bool = True,\n) -&gt; NDArray:\n    \"\"\"Return vector with values along the given scenario horizon using level over level_period.\"\"\"\n    conversion_vector = None\n    efficiency_vector = None\n    loss_vector = None\n    conversion_value = None\n    efficiency_value = None\n    loss_value = None\n\n    if self._conversion is not None:\n        if self._conversion.has_profile():\n            conversion_vector = self._conversion.get_scenario_vector(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=unit,\n                is_float32=is_float32,\n            )\n        elif self._conversion.has_level():\n            conversion_value = self._conversion.get_data_value(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=unit,\n            )\n            conversion_value = float(conversion_value)\n\n    if self._efficiency is not None:\n        if self._efficiency.has_profile():\n            efficiency_vector = self._efficiency.get_scenario_vector(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=None,\n                is_float32=is_float32,\n            )\n        elif self._efficiency.has_level():\n            efficiency_value = self._efficiency.get_data_value(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=None,\n            )\n            efficiency_value = float(efficiency_value)\n\n    if self._loss is not None:\n        if self._loss.has_profile():\n            loss_vector = self._loss.get_scenario_vector(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=None,\n                is_float32=is_float32,\n            )\n        elif self._loss.has_level():\n            loss_value = self._loss.get_data_value(\n                db=db,\n                scenario_horizon=scenario_horizon,\n                level_period=level_period,\n                unit=None,\n            )\n            loss_value = float(loss_value)\n\n    if conversion_value is not None:\n        assert conversion_value &gt;= 0, f\"Arrow with invalid conversion ({conversion_value}): {self}\"\n        out = conversion_value\n    else:\n        out = 1.0\n\n    if efficiency_value is not None:\n        assert efficiency_value &gt; 0, f\"Arrow with invalid efficiency ({efficiency_value}): {self}\"\n        out = out / efficiency_value\n\n    if loss_value is not None:\n        assert loss_value &gt;= 0 or loss_value &lt; 1, f\"Arrow with invalid loss ({loss_value}): {self}\"\n        out = out - out * loss_value\n\n    if conversion_vector is not None:\n        np.multiply(conversion_vector, out, out=conversion_vector)\n        out = conversion_vector\n\n    if efficiency_vector is not None:\n        if isinstance(out, float):\n            np.divide(out, efficiency_vector, out=efficiency_vector)\n            out = efficiency_vector\n        else:\n            np.divide(out, efficiency_vector, out=out)\n\n    if loss_vector is not None:\n        if isinstance(out, float):\n            np.multiply(out, loss_vector, out=loss_vector)\n            np.subtract(out, loss_vector, out=loss_vector)\n            out = loss_vector\n        else:\n            np.multiply(out, loss_vector, out=loss_vector)\n            np.subtract(out, loss_vector, out=out)\n\n    if isinstance(out, float):\n        num_periods = scenario_horizon.get_num_periods()\n        vector = np.ones(num_periods, dtype=np.float32 if is_float32 else np.float64)\n        vector.fill(out)\n        return vector\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.has_profile","title":"<code>has_profile() -&gt; bool</code>","text":"<p>Return True if any of conversion, efficiency or loss has profile.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def has_profile(self) -&gt; bool:\n    \"\"\"Return True if any of conversion, efficiency or loss has profile.\"\"\"\n    if self._conversion is not None and self._conversion.has_profile():\n        return True\n    if self._efficiency is not None and self._efficiency.has_profile():\n        return True\n    return bool(self._loss is not None and self._loss.has_profile())\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.is_ingoing","title":"<code>is_ingoing() -&gt; bool</code>","text":"<p>Return True if arrow is ingoing.</p> <p>Ingoing means the flow variable supplies to node. Outgoing means the flow variable takes out of node.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def is_ingoing(self) -&gt; bool:\n    \"\"\"\n    Return True if arrow is ingoing.\n\n    Ingoing means the flow variable supplies to node.\n    Outgoing means the flow variable takes out of node.\n    \"\"\"\n    return self._is_ingoing\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.set_conversion","title":"<code>set_conversion(value: Conversion | None) -&gt; None</code>","text":"<p>Set the conversion.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def set_conversion(self, value: Conversion | None) -&gt; None:\n    \"\"\"Set the conversion.\"\"\"\n    self._check_type(value, Conversion, type(None))\n    self._conversion = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.set_efficiency","title":"<code>set_efficiency(value: Efficiency | None) -&gt; None</code>","text":"<p>Set the efficiency.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def set_efficiency(self, value: Efficiency | None) -&gt; None:\n    \"\"\"Set the efficiency.\"\"\"\n    self._check_type(value, Efficiency, type(None))\n    self._efficiency = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.set_loss","title":"<code>set_loss(value: Loss | None) -&gt; None</code>","text":"<p>Set the loss.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def set_loss(self, value: Loss | None) -&gt; None:\n    \"\"\"Set the loss.\"\"\"\n    self._check_type(value, Loss, type(None))\n    self._loss = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Arrow.Arrow.set_node","title":"<code>set_node(node: str) -&gt; None</code>","text":"<p>Set the node the arrow is pointing to.</p> Source code in <code>framcore/attributes/Arrow.py</code> <pre><code>def set_node(self, node: str) -&gt; None:\n    \"\"\"Set the node the arrow is pointing to.\"\"\"\n    self._check_type(node, str)\n    self._node = node\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand","title":"<code>ElasticDemand</code>","text":"<p>ElasticDemand attribute class.</p>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand","title":"<code>ElasticDemand</code>","text":"<p>               Bases: <code>Base</code></p> <p>ElasticDemand class representing the price elasticity of a demand Component.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>class ElasticDemand(Base):\n    \"\"\"ElasticDemand class representing the price elasticity of a demand Component.\"\"\"\n\n    def __init__(\n        self,\n        price_elasticity: Elasticity,\n        min_price: Price,\n        normal_price: Price,\n        max_price: Price,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ElasticDemand class.\n\n        Args:\n            price_elasticity (Elasticity): The price elasticity factor of the demand consumer.\n            min_price (Price): Lower limit for price elasticity.\n            normal_price (Price): Price for which the demand is inelastic. If it deviates from this price, the consumer will adjust\n                                  it's consumption according to the _price_elasticity factor.\n            max_price (Price): Upper limit for price elasticity / reservation price level.\n\n        \"\"\"\n        self._check_type(price_elasticity, Elasticity)\n        self._check_type(min_price, Price)\n        self._check_type(normal_price, Price)\n        self._check_type(max_price, Price)\n\n        self._price_elasticity = price_elasticity\n        self._min_price = min_price\n        self._normal_price = normal_price\n        self._max_price = max_price\n\n    def get_price_elasticity(self) -&gt; Elasticity:\n        \"\"\"Get the price elasticity.\"\"\"\n        return self._price_elasticity\n\n    def set_price_elasticity(self, elasticity: Price) -&gt; None:\n        \"\"\"Set the price elasticity.\"\"\"\n        self._check_type(elasticity, Elasticity)\n        self._price_elasticity = elasticity\n\n    def get_min_price(self) -&gt; Price:\n        \"\"\"Get the minimum price.\"\"\"\n        return self._min_price\n\n    def set_min_price(self, min_price: Price) -&gt; None:\n        \"\"\"Set the minimum price.\"\"\"\n        self._check_type(min_price, Price)\n        self._min_price = min_price\n\n    def get_normal_price(self) -&gt; Price:\n        \"\"\"Get the normal price.\"\"\"\n        return self._normal_price\n\n    def set_normal_price(self, normal_price: Price) -&gt; None:\n        \"\"\"Set the normal price.\"\"\"\n        self._check_type(normal_price, Price)\n        self._normal_price = normal_price\n\n    def get_max_price(self) -&gt; Price:\n        \"\"\"Get the maximum price.\"\"\"\n        return self._max_price\n\n    def set_max_price(self, max_price: Price) -&gt; None:\n        \"\"\"Set the maximum price.\"\"\"\n        self._check_type(max_price, Price)\n        self._max_price = max_price\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self._normal_price)\n        add_loaders_if(loaders, self._price_elasticity)\n        add_loaders_if(loaders, self._max_price)\n        add_loaders_if(loaders, self._min_price)\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.__init__","title":"<code>__init__(price_elasticity: Elasticity, min_price: Price, normal_price: Price, max_price: Price) -&gt; None</code>","text":"<p>Initialize the ElasticDemand class.</p> <p>Parameters:</p> Name Type Description Default <code>price_elasticity</code> <code>Elasticity</code> <p>The price elasticity factor of the demand consumer.</p> required <code>min_price</code> <code>Price</code> <p>Lower limit for price elasticity.</p> required <code>normal_price</code> <code>Price</code> <p>Price for which the demand is inelastic. If it deviates from this price, the consumer will adjust                   it's consumption according to the _price_elasticity factor.</p> required <code>max_price</code> <code>Price</code> <p>Upper limit for price elasticity / reservation price level.</p> required Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def __init__(\n    self,\n    price_elasticity: Elasticity,\n    min_price: Price,\n    normal_price: Price,\n    max_price: Price,\n) -&gt; None:\n    \"\"\"\n    Initialize the ElasticDemand class.\n\n    Args:\n        price_elasticity (Elasticity): The price elasticity factor of the demand consumer.\n        min_price (Price): Lower limit for price elasticity.\n        normal_price (Price): Price for which the demand is inelastic. If it deviates from this price, the consumer will adjust\n                              it's consumption according to the _price_elasticity factor.\n        max_price (Price): Upper limit for price elasticity / reservation price level.\n\n    \"\"\"\n    self._check_type(price_elasticity, Elasticity)\n    self._check_type(min_price, Price)\n    self._check_type(normal_price, Price)\n    self._check_type(max_price, Price)\n\n    self._price_elasticity = price_elasticity\n    self._min_price = min_price\n    self._normal_price = normal_price\n    self._max_price = max_price\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in attributes to loaders.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self._normal_price)\n    add_loaders_if(loaders, self._price_elasticity)\n    add_loaders_if(loaders, self._max_price)\n    add_loaders_if(loaders, self._min_price)\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.get_max_price","title":"<code>get_max_price() -&gt; Price</code>","text":"<p>Get the maximum price.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def get_max_price(self) -&gt; Price:\n    \"\"\"Get the maximum price.\"\"\"\n    return self._max_price\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.get_min_price","title":"<code>get_min_price() -&gt; Price</code>","text":"<p>Get the minimum price.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def get_min_price(self) -&gt; Price:\n    \"\"\"Get the minimum price.\"\"\"\n    return self._min_price\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.get_normal_price","title":"<code>get_normal_price() -&gt; Price</code>","text":"<p>Get the normal price.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def get_normal_price(self) -&gt; Price:\n    \"\"\"Get the normal price.\"\"\"\n    return self._normal_price\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.get_price_elasticity","title":"<code>get_price_elasticity() -&gt; Elasticity</code>","text":"<p>Get the price elasticity.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def get_price_elasticity(self) -&gt; Elasticity:\n    \"\"\"Get the price elasticity.\"\"\"\n    return self._price_elasticity\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.set_max_price","title":"<code>set_max_price(max_price: Price) -&gt; None</code>","text":"<p>Set the maximum price.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def set_max_price(self, max_price: Price) -&gt; None:\n    \"\"\"Set the maximum price.\"\"\"\n    self._check_type(max_price, Price)\n    self._max_price = max_price\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.set_min_price","title":"<code>set_min_price(min_price: Price) -&gt; None</code>","text":"<p>Set the minimum price.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def set_min_price(self, min_price: Price) -&gt; None:\n    \"\"\"Set the minimum price.\"\"\"\n    self._check_type(min_price, Price)\n    self._min_price = min_price\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.set_normal_price","title":"<code>set_normal_price(normal_price: Price) -&gt; None</code>","text":"<p>Set the normal price.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def set_normal_price(self, normal_price: Price) -&gt; None:\n    \"\"\"Set the normal price.\"\"\"\n    self._check_type(normal_price, Price)\n    self._normal_price = normal_price\n</code></pre>"},{"location":"reference/#framcore.attributes.ElasticDemand.ElasticDemand.set_price_elasticity","title":"<code>set_price_elasticity(elasticity: Price) -&gt; None</code>","text":"<p>Set the price elasticity.</p> Source code in <code>framcore/attributes/ElasticDemand.py</code> <pre><code>def set_price_elasticity(self, elasticity: Price) -&gt; None:\n    \"\"\"Set the price elasticity.\"\"\"\n    self._check_type(elasticity, Elasticity)\n    self._price_elasticity = elasticity\n</code></pre>"},{"location":"reference/#framcore.attributes.ReservoirCurve","title":"<code>ReservoirCurve</code>","text":""},{"location":"reference/#framcore.attributes.ReservoirCurve.ReservoirCurve","title":"<code>ReservoirCurve</code>","text":"<p>               Bases: <code>Base</code></p> <p>Water level elevation to water volume characteristics for HydroStorage.</p> Source code in <code>framcore/attributes/ReservoirCurve.py</code> <pre><code>class ReservoirCurve(Base):\n    \"\"\"Water level elevation to water volume characteristics for HydroStorage.\"\"\"\n\n    # TODO: Implement and comment, also too generic name\n\n    def __init__(self, value: str | None) -&gt; None:\n        \"\"\"Initialize a ReservoirCurve instance.\"\"\"\n        self._check_type(value, (str, type(None)))\n        self._value = value\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n        return\n</code></pre>"},{"location":"reference/#framcore.attributes.ReservoirCurve.ReservoirCurve.__init__","title":"<code>__init__(value: str | None) -&gt; None</code>","text":"<p>Initialize a ReservoirCurve instance.</p> Source code in <code>framcore/attributes/ReservoirCurve.py</code> <pre><code>def __init__(self, value: str | None) -&gt; None:\n    \"\"\"Initialize a ReservoirCurve instance.\"\"\"\n    self._check_type(value, (str, type(None)))\n    self._value = value\n</code></pre>"},{"location":"reference/#framcore.attributes.ReservoirCurve.ReservoirCurve.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in attributes to loaders.</p> Source code in <code>framcore/attributes/ReservoirCurve.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n    return\n</code></pre>"},{"location":"reference/#framcore.attributes.SoftBound","title":"<code>SoftBound</code>","text":""},{"location":"reference/#framcore.attributes.SoftBound.SoftBound","title":"<code>SoftBound</code>","text":"<p>Represents a soft bound attribute. Penalty applied if the bound is violated.</p> Source code in <code>framcore/attributes/SoftBound.py</code> <pre><code>class SoftBound:\n    \"\"\"Represents a soft bound attribute. Penalty applied if the bound is violated.\"\"\"\n\n    # TODO: Implement and comment\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n        return\n</code></pre>"},{"location":"reference/#framcore.attributes.SoftBound.SoftBound.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in attributes to loaders.</p> Source code in <code>framcore/attributes/SoftBound.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n    return\n</code></pre>"},{"location":"reference/#framcore.attributes.StartUpCost","title":"<code>StartUpCost</code>","text":""},{"location":"reference/#framcore.attributes.StartUpCost.StartUpCost","title":"<code>StartUpCost</code>","text":"<p>               Bases: <code>Base</code></p> <p>Represent the costs associated with starting up the operation of a Component.</p> Source code in <code>framcore/attributes/StartUpCost.py</code> <pre><code>class StartUpCost(Base):\n    \"\"\"Represent the costs associated with starting up the operation of a Component.\"\"\"\n\n    # TODO: Complete description\n\n    def __init__(\n        self,\n        startup_cost: Cost,\n        min_stable_load: Proportion,\n        start_hours: Hours,\n        part_load_efficiency: Efficiency,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the StartUpCost class.\n\n        Args:\n            startup_cost (Cost): _description_\n            min_stable_load (Proportion): _description_\n            start_hours (Hours): _description_\n            part_load_efficiency (Efficiency): _description_\n\n        \"\"\"\n        self._check_type(startup_cost, Cost)\n        self._check_type(min_stable_load, Proportion)\n        self._check_type(start_hours, Hours)\n        self._check_type(part_load_efficiency, Efficiency)\n\n        self._startup_cost = startup_cost\n        self._min_stable_load = min_stable_load\n        self._start_hours = start_hours\n        self._part_load_efficiency = part_load_efficiency\n\n    def get_startupcost(self) -&gt; Cost:\n        \"\"\"Get the startup cost.\"\"\"\n        return self._startup_cost\n\n    def set_startupcost(self, startupcost: Cost) -&gt; None:\n        \"\"\"Set the startup cost.\"\"\"\n        self._check_type(startupcost, Cost)\n        self._startup_cost = startupcost\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the fingerprint of the startup cost.\"\"\"\n        return self.get_fingerprint_default()\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Get all loaders stored in attributes.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self.get_startupcost())\n        add_loaders_if(loaders, self._start_hours)\n        add_loaders_if(loaders, self._min_stable_load)\n        add_loaders_if(loaders, self._part_load_efficiency)\n</code></pre>"},{"location":"reference/#framcore.attributes.StartUpCost.StartUpCost.__init__","title":"<code>__init__(startup_cost: Cost, min_stable_load: Proportion, start_hours: Hours, part_load_efficiency: Efficiency) -&gt; None</code>","text":"<p>Initialize the StartUpCost class.</p> <p>Parameters:</p> Name Type Description Default <code>startup_cost</code> <code>Cost</code> <p>description</p> required <code>min_stable_load</code> <code>Proportion</code> <p>description</p> required <code>start_hours</code> <code>Hours</code> <p>description</p> required <code>part_load_efficiency</code> <code>Efficiency</code> <p>description</p> required Source code in <code>framcore/attributes/StartUpCost.py</code> <pre><code>def __init__(\n    self,\n    startup_cost: Cost,\n    min_stable_load: Proportion,\n    start_hours: Hours,\n    part_load_efficiency: Efficiency,\n) -&gt; None:\n    \"\"\"\n    Initialize the StartUpCost class.\n\n    Args:\n        startup_cost (Cost): _description_\n        min_stable_load (Proportion): _description_\n        start_hours (Hours): _description_\n        part_load_efficiency (Efficiency): _description_\n\n    \"\"\"\n    self._check_type(startup_cost, Cost)\n    self._check_type(min_stable_load, Proportion)\n    self._check_type(start_hours, Hours)\n    self._check_type(part_load_efficiency, Efficiency)\n\n    self._startup_cost = startup_cost\n    self._min_stable_load = min_stable_load\n    self._start_hours = start_hours\n    self._part_load_efficiency = part_load_efficiency\n</code></pre>"},{"location":"reference/#framcore.attributes.StartUpCost.StartUpCost.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Get all loaders stored in attributes.</p> Source code in <code>framcore/attributes/StartUpCost.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Get all loaders stored in attributes.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self.get_startupcost())\n    add_loaders_if(loaders, self._start_hours)\n    add_loaders_if(loaders, self._min_stable_load)\n    add_loaders_if(loaders, self._part_load_efficiency)\n</code></pre>"},{"location":"reference/#framcore.attributes.StartUpCost.StartUpCost.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the fingerprint of the startup cost.</p> Source code in <code>framcore/attributes/StartUpCost.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the fingerprint of the startup cost.\"\"\"\n    return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.attributes.StartUpCost.StartUpCost.get_startupcost","title":"<code>get_startupcost() -&gt; Cost</code>","text":"<p>Get the startup cost.</p> Source code in <code>framcore/attributes/StartUpCost.py</code> <pre><code>def get_startupcost(self) -&gt; Cost:\n    \"\"\"Get the startup cost.\"\"\"\n    return self._startup_cost\n</code></pre>"},{"location":"reference/#framcore.attributes.StartUpCost.StartUpCost.set_startupcost","title":"<code>set_startupcost(startupcost: Cost) -&gt; None</code>","text":"<p>Set the startup cost.</p> Source code in <code>framcore/attributes/StartUpCost.py</code> <pre><code>def set_startupcost(self, startupcost: Cost) -&gt; None:\n    \"\"\"Set the startup cost.\"\"\"\n    self._check_type(startupcost, Cost)\n    self._startup_cost = startupcost\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage","title":"<code>Storage</code>","text":""},{"location":"reference/#framcore.attributes.Storage.Storage","title":"<code>Storage</code>","text":"<p>               Bases: <code>Base</code></p> <p>Represents all types of storage this system supports.</p> <p>Subclasses are supposed to restrict which attributes that are used, not add more.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>class Storage(Base):\n    \"\"\"\n    Represents all types of storage this system supports.\n\n    Subclasses are supposed to restrict which attributes that are used, not add more.\n    \"\"\"\n\n    def __init__(\n        self,\n        capacity: StockVolume,\n        volume: StockVolume | None = None,\n        loss: Loss | None = None,  # TODO: Should be loss percentage per time.\n        reservoir_curve: ReservoirCurve | None = None,\n        max_soft_bound: SoftBound | None = None,\n        min_soft_bound: SoftBound | None = None,\n        target_bound: TargetBound | None = None,\n        initial_storage_percentage: float | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Create new storage.\n\n        Args:\n            capacity (StockVolume): Storage capacity.\n            volume (StockVolume | None, optional): Storage filling (actual/result). Defaults to None.\n            loss (Loss | None, optional): Loss percentage per time. Defaults to None.\n            reservoir_curve (ReservoirCurve | None, optional): Water level elevation to water volume for HydroStorage. Defaults to None.\n            max_soft_bound (SoftBound | None, optional): Upper soft boundary that is penalized if broken. Defaults to None.\n            min_soft_bound (SoftBound | None, optional): Lower soft boundary that is penalized if broken. Defaults to None.\n            target_bound (TargetBound | None, optional): Target filling, can be penalized if deviation. Defaults to None.\n            initial_storage_percentage (float | None, optional): Initial storage filling percentage at start of simulation. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n\n        self._check_type(capacity, StockVolume)\n        self._check_type(volume, (StockVolume, type(None)))\n        self._check_type(loss, (StockVolume, type(None)))\n        self._check_type(reservoir_curve, (ReservoirCurve, type(None)))\n        self._check_type(max_soft_bound, (SoftBound, type(None)))\n        self._check_type(min_soft_bound, (SoftBound, type(None)))\n        self._check_type(target_bound, (TargetBound, type(None)))\n        self._check_type(initial_storage_percentage, (float, type(None)))\n\n        if initial_storage_percentage is not None:\n            self._check_float(initial_storage_percentage, lower_bound=0.0, upper_bound=1.0)\n\n        self._capacity = capacity\n\n        self._loss = loss\n        self._reservoir_curve = reservoir_curve\n        self._max_soft_bound = max_soft_bound\n        self._min_soft_bound = min_soft_bound\n        self._target_bound = target_bound\n        self._initial_storage_percentage = initial_storage_percentage\n\n        self._cost_terms: dict[str, ObjectiveCoefficient] = dict()\n\n        if volume is None:\n            volume = StockVolume()\n        self._volume = volume\n\n    def get_capacity(self) -&gt; StockVolume:\n        \"\"\"Get the capacity.\"\"\"\n        return self._capacity\n\n    def get_volume(self) -&gt; StockVolume:\n        \"\"\"Get the volume.\"\"\"\n        return self._volume\n\n    def add_cost_term(self, key: str, cost_term: ObjectiveCoefficient) -&gt; None:\n        \"\"\"Add a cost term.\"\"\"\n        self._check_type(key, str)\n        self._check_type(cost_term, ObjectiveCoefficient)\n        self._cost_terms[key] = cost_term\n\n    def get_cost_terms(self) -&gt; dict[str, ObjectiveCoefficient]:\n        \"\"\"Get the cost terms.\"\"\"\n        return self._cost_terms\n\n    def get_loss(self) -&gt; Loss | None:\n        \"\"\"Get the loss.\"\"\"\n        return self._loss\n\n    def set_loss(self, value: Loss | None) -&gt; None:\n        \"\"\"Set the loss.\"\"\"\n        self._check_type(value, (Loss, type(None)))\n        self._loss = value\n\n    def get_reservoir_curve(self) -&gt; ReservoirCurve | None:\n        \"\"\"Get the reservoir curve.\"\"\"\n        return self._reservoir_curve\n\n    def set_reservoir_curve(self, value: ReservoirCurve | None) -&gt; None:\n        \"\"\"Set the reservoir curve.\"\"\"\n        self._check_type(value, (ReservoirCurve, type(None)))\n        self._reservoir_curve = value\n\n    def get_max_soft_bound(self) -&gt; SoftBound | None:\n        \"\"\"Get the max soft bound.\"\"\"\n        return self._max_soft_bound\n\n    def set_max_soft_bound(self, value: SoftBound | None) -&gt; None:\n        \"\"\"Set the max soft bound.\"\"\"\n        self._check_type(value, (SoftBound, type(None)))\n        self._max_soft_bound = value\n\n    def get_min_soft_bound(self) -&gt; SoftBound | None:\n        \"\"\"Get the min soft bound.\"\"\"\n        return self._min_soft_bound\n\n    def set_min_soft_bound(self, value: SoftBound | None) -&gt; None:\n        \"\"\"Set the min soft bound.\"\"\"\n        self._check_type(value, (SoftBound, type(None)))\n        self._min_soft_bound = value\n\n    def get_target_bound(self) -&gt; TargetBound | None:\n        \"\"\"Get the target bound.\"\"\"\n        return self._target_bound\n\n    def set_target_bound(self, value: TargetBound | None) -&gt; None:\n        \"\"\"Set the target bound.\"\"\"\n        self._check_type(value, (TargetBound, type(None)))\n        self._target_bound = value\n\n    def get_initial_storage_percentage(self) -&gt; float | None:\n        \"\"\"Get the initial storage percentage (float in [0, 1]).\"\"\"\n        return self._initial_storage_percentage\n\n    def set_initial_storage_percentage(self, value: float) -&gt; None:\n        \"\"\"Set the initial storage percentage (float in [0, 1]).\"\"\"\n        self._check_float(value, lower_bound=0.0, upper_bound=1.0)\n        self._initial_storage_percentage = value\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self.get_capacity())\n        add_loaders_if(loaders, self.get_loss())\n        add_loaders_if(loaders, self.get_volume())\n        add_loaders_if(loaders, self.get_max_soft_bound())\n        add_loaders_if(loaders, self.get_min_soft_bound())\n        add_loaders_if(loaders, self.get_reservoir_curve())\n        add_loaders_if(loaders, self.get_target_bound())\n\n        for cost in self.get_cost_terms().values():\n            add_loaders_if(loaders, cost)\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.__init__","title":"<code>__init__(capacity: StockVolume, volume: StockVolume | None = None, loss: Loss | None = None, reservoir_curve: ReservoirCurve | None = None, max_soft_bound: SoftBound | None = None, min_soft_bound: SoftBound | None = None, target_bound: TargetBound | None = None, initial_storage_percentage: float | None = None) -&gt; None</code>","text":"<p>Create new storage.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>StockVolume</code> <p>Storage capacity.</p> required <code>volume</code> <code>StockVolume | None</code> <p>Storage filling (actual/result). Defaults to None.</p> <code>None</code> <code>loss</code> <code>Loss | None</code> <p>Loss percentage per time. Defaults to None.</p> <code>None</code> <code>reservoir_curve</code> <code>ReservoirCurve | None</code> <p>Water level elevation to water volume for HydroStorage. Defaults to None.</p> <code>None</code> <code>max_soft_bound</code> <code>SoftBound | None</code> <p>Upper soft boundary that is penalized if broken. Defaults to None.</p> <code>None</code> <code>min_soft_bound</code> <code>SoftBound | None</code> <p>Lower soft boundary that is penalized if broken. Defaults to None.</p> <code>None</code> <code>target_bound</code> <code>TargetBound | None</code> <p>Target filling, can be penalized if deviation. Defaults to None.</p> <code>None</code> <code>initial_storage_percentage</code> <code>float | None</code> <p>Initial storage filling percentage at start of simulation. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def __init__(\n    self,\n    capacity: StockVolume,\n    volume: StockVolume | None = None,\n    loss: Loss | None = None,  # TODO: Should be loss percentage per time.\n    reservoir_curve: ReservoirCurve | None = None,\n    max_soft_bound: SoftBound | None = None,\n    min_soft_bound: SoftBound | None = None,\n    target_bound: TargetBound | None = None,\n    initial_storage_percentage: float | None = None,\n) -&gt; None:\n    \"\"\"\n    Create new storage.\n\n    Args:\n        capacity (StockVolume): Storage capacity.\n        volume (StockVolume | None, optional): Storage filling (actual/result). Defaults to None.\n        loss (Loss | None, optional): Loss percentage per time. Defaults to None.\n        reservoir_curve (ReservoirCurve | None, optional): Water level elevation to water volume for HydroStorage. Defaults to None.\n        max_soft_bound (SoftBound | None, optional): Upper soft boundary that is penalized if broken. Defaults to None.\n        min_soft_bound (SoftBound | None, optional): Lower soft boundary that is penalized if broken. Defaults to None.\n        target_bound (TargetBound | None, optional): Target filling, can be penalized if deviation. Defaults to None.\n        initial_storage_percentage (float | None, optional): Initial storage filling percentage at start of simulation. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n\n    self._check_type(capacity, StockVolume)\n    self._check_type(volume, (StockVolume, type(None)))\n    self._check_type(loss, (StockVolume, type(None)))\n    self._check_type(reservoir_curve, (ReservoirCurve, type(None)))\n    self._check_type(max_soft_bound, (SoftBound, type(None)))\n    self._check_type(min_soft_bound, (SoftBound, type(None)))\n    self._check_type(target_bound, (TargetBound, type(None)))\n    self._check_type(initial_storage_percentage, (float, type(None)))\n\n    if initial_storage_percentage is not None:\n        self._check_float(initial_storage_percentage, lower_bound=0.0, upper_bound=1.0)\n\n    self._capacity = capacity\n\n    self._loss = loss\n    self._reservoir_curve = reservoir_curve\n    self._max_soft_bound = max_soft_bound\n    self._min_soft_bound = min_soft_bound\n    self._target_bound = target_bound\n    self._initial_storage_percentage = initial_storage_percentage\n\n    self._cost_terms: dict[str, ObjectiveCoefficient] = dict()\n\n    if volume is None:\n        volume = StockVolume()\n    self._volume = volume\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.add_cost_term","title":"<code>add_cost_term(key: str, cost_term: ObjectiveCoefficient) -&gt; None</code>","text":"<p>Add a cost term.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def add_cost_term(self, key: str, cost_term: ObjectiveCoefficient) -&gt; None:\n    \"\"\"Add a cost term.\"\"\"\n    self._check_type(key, str)\n    self._check_type(cost_term, ObjectiveCoefficient)\n    self._cost_terms[key] = cost_term\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in attributes to loaders.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self.get_capacity())\n    add_loaders_if(loaders, self.get_loss())\n    add_loaders_if(loaders, self.get_volume())\n    add_loaders_if(loaders, self.get_max_soft_bound())\n    add_loaders_if(loaders, self.get_min_soft_bound())\n    add_loaders_if(loaders, self.get_reservoir_curve())\n    add_loaders_if(loaders, self.get_target_bound())\n\n    for cost in self.get_cost_terms().values():\n        add_loaders_if(loaders, cost)\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_capacity","title":"<code>get_capacity() -&gt; StockVolume</code>","text":"<p>Get the capacity.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_capacity(self) -&gt; StockVolume:\n    \"\"\"Get the capacity.\"\"\"\n    return self._capacity\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_cost_terms","title":"<code>get_cost_terms() -&gt; dict[str, ObjectiveCoefficient]</code>","text":"<p>Get the cost terms.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_cost_terms(self) -&gt; dict[str, ObjectiveCoefficient]:\n    \"\"\"Get the cost terms.\"\"\"\n    return self._cost_terms\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_initial_storage_percentage","title":"<code>get_initial_storage_percentage() -&gt; float | None</code>","text":"<p>Get the initial storage percentage (float in [0, 1]).</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_initial_storage_percentage(self) -&gt; float | None:\n    \"\"\"Get the initial storage percentage (float in [0, 1]).\"\"\"\n    return self._initial_storage_percentage\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_loss","title":"<code>get_loss() -&gt; Loss | None</code>","text":"<p>Get the loss.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_loss(self) -&gt; Loss | None:\n    \"\"\"Get the loss.\"\"\"\n    return self._loss\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_max_soft_bound","title":"<code>get_max_soft_bound() -&gt; SoftBound | None</code>","text":"<p>Get the max soft bound.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_max_soft_bound(self) -&gt; SoftBound | None:\n    \"\"\"Get the max soft bound.\"\"\"\n    return self._max_soft_bound\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_min_soft_bound","title":"<code>get_min_soft_bound() -&gt; SoftBound | None</code>","text":"<p>Get the min soft bound.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_min_soft_bound(self) -&gt; SoftBound | None:\n    \"\"\"Get the min soft bound.\"\"\"\n    return self._min_soft_bound\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_reservoir_curve","title":"<code>get_reservoir_curve() -&gt; ReservoirCurve | None</code>","text":"<p>Get the reservoir curve.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_reservoir_curve(self) -&gt; ReservoirCurve | None:\n    \"\"\"Get the reservoir curve.\"\"\"\n    return self._reservoir_curve\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_target_bound","title":"<code>get_target_bound() -&gt; TargetBound | None</code>","text":"<p>Get the target bound.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_target_bound(self) -&gt; TargetBound | None:\n    \"\"\"Get the target bound.\"\"\"\n    return self._target_bound\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.get_volume","title":"<code>get_volume() -&gt; StockVolume</code>","text":"<p>Get the volume.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def get_volume(self) -&gt; StockVolume:\n    \"\"\"Get the volume.\"\"\"\n    return self._volume\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.set_initial_storage_percentage","title":"<code>set_initial_storage_percentage(value: float) -&gt; None</code>","text":"<p>Set the initial storage percentage (float in [0, 1]).</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def set_initial_storage_percentage(self, value: float) -&gt; None:\n    \"\"\"Set the initial storage percentage (float in [0, 1]).\"\"\"\n    self._check_float(value, lower_bound=0.0, upper_bound=1.0)\n    self._initial_storage_percentage = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.set_loss","title":"<code>set_loss(value: Loss | None) -&gt; None</code>","text":"<p>Set the loss.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def set_loss(self, value: Loss | None) -&gt; None:\n    \"\"\"Set the loss.\"\"\"\n    self._check_type(value, (Loss, type(None)))\n    self._loss = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.set_max_soft_bound","title":"<code>set_max_soft_bound(value: SoftBound | None) -&gt; None</code>","text":"<p>Set the max soft bound.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def set_max_soft_bound(self, value: SoftBound | None) -&gt; None:\n    \"\"\"Set the max soft bound.\"\"\"\n    self._check_type(value, (SoftBound, type(None)))\n    self._max_soft_bound = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.set_min_soft_bound","title":"<code>set_min_soft_bound(value: SoftBound | None) -&gt; None</code>","text":"<p>Set the min soft bound.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def set_min_soft_bound(self, value: SoftBound | None) -&gt; None:\n    \"\"\"Set the min soft bound.\"\"\"\n    self._check_type(value, (SoftBound, type(None)))\n    self._min_soft_bound = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.set_reservoir_curve","title":"<code>set_reservoir_curve(value: ReservoirCurve | None) -&gt; None</code>","text":"<p>Set the reservoir curve.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def set_reservoir_curve(self, value: ReservoirCurve | None) -&gt; None:\n    \"\"\"Set the reservoir curve.\"\"\"\n    self._check_type(value, (ReservoirCurve, type(None)))\n    self._reservoir_curve = value\n</code></pre>"},{"location":"reference/#framcore.attributes.Storage.Storage.set_target_bound","title":"<code>set_target_bound(value: TargetBound | None) -&gt; None</code>","text":"<p>Set the target bound.</p> Source code in <code>framcore/attributes/Storage.py</code> <pre><code>def set_target_bound(self, value: TargetBound | None) -&gt; None:\n    \"\"\"Set the target bound.\"\"\"\n    self._check_type(value, (TargetBound, type(None)))\n    self._target_bound = value\n</code></pre>"},{"location":"reference/#framcore.attributes.TargetBound","title":"<code>TargetBound</code>","text":""},{"location":"reference/#framcore.attributes.TargetBound.TargetBound","title":"<code>TargetBound</code>","text":"<p>Target boundary attribute. Can be penalized if deviation from target.</p> Source code in <code>framcore/attributes/TargetBound.py</code> <pre><code>class TargetBound:\n    \"\"\"Target boundary attribute. Can be penalized if deviation from target.\"\"\"\n\n    # TODO: Implement and comment\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n        return\n</code></pre>"},{"location":"reference/#framcore.attributes.TargetBound.TargetBound.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in attributes to loaders.</p> Source code in <code>framcore/attributes/TargetBound.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in attributes to loaders.\"\"\"\n    return\n</code></pre>"},{"location":"reference/#framcore.attributes.hydro","title":"<code>hydro</code>","text":""},{"location":"reference/#framcore.attributes.hydro.HydroBypass","title":"<code>HydroBypass</code>","text":""},{"location":"reference/#framcore.attributes.hydro.HydroBypass.HydroBypass","title":"<code>HydroBypass</code>","text":"<p>               Bases: <code>Base</code></p> <p>HydroBypass represents a controlled water way from a HydroModule. Used to bypass main release of the HydroModule.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>class HydroBypass(Base):\n    \"\"\"HydroBypass represents a controlled water way from a HydroModule. Used to bypass main release of the HydroModule.\"\"\"\n\n    def __init__(\n        self,\n        to_module: str | None,\n        capacity: FlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize object.\n\n        Args:\n            to_module (str | None): Name of the HydroModule the water is released to.\n            capacity (FlowVolume | None, optional): Restrictions on the volume of water which can pass through the bypass at a given moment. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n\n        self._check_type(to_module, (str, type(None)))\n        self._check_type(capacity, (FlowVolume, type(None)))\n\n        self._to_module = to_module\n        self._capacity = capacity\n        self._volume = AvgFlowVolume()\n\n    def get_to_module(self) -&gt; str | None:\n        \"\"\"Get the name of the module to which the bypass leads.\"\"\"\n        return self._to_module\n\n    def set_to_module(self, to_module: str) -&gt; None:\n        \"\"\"Set the name of the module to which the bypass leads.\"\"\"\n        self._check_type(to_module, str)\n        self._to_module = to_module\n\n    def get_capacity(self) -&gt; FlowVolume | None:\n        \"\"\"Get the capacity of the bypass.\"\"\"\n        return self._capacity\n\n    def get_volume(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the volume of the bypass.\"\"\"\n        return self._volume\n\n    def _get_fingerprint(self) -&gt; Fingerprint:\n        return self.get_fingerprint_default(refs={\"to_module\": self._to_module})\n</code></pre> <code></code> <code>__init__(to_module: str | None, capacity: FlowVolume | None = None) -&gt; None</code> <p>Initialize object.</p> <p>Parameters:</p> Name Type Description Default <code>to_module</code> <code>str | None</code> <p>Name of the HydroModule the water is released to.</p> required <code>capacity</code> <code>FlowVolume | None</code> <p>Restrictions on the volume of water which can pass through the bypass at a given moment. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def __init__(\n    self,\n    to_module: str | None,\n    capacity: FlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize object.\n\n    Args:\n        to_module (str | None): Name of the HydroModule the water is released to.\n        capacity (FlowVolume | None, optional): Restrictions on the volume of water which can pass through the bypass at a given moment. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n\n    self._check_type(to_module, (str, type(None)))\n    self._check_type(capacity, (FlowVolume, type(None)))\n\n    self._to_module = to_module\n    self._capacity = capacity\n    self._volume = AvgFlowVolume()\n</code></pre> <code></code> <code>get_capacity() -&gt; FlowVolume | None</code> <p>Get the capacity of the bypass.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def get_capacity(self) -&gt; FlowVolume | None:\n    \"\"\"Get the capacity of the bypass.\"\"\"\n    return self._capacity\n</code></pre> <code></code> <code>get_to_module() -&gt; str | None</code> <p>Get the name of the module to which the bypass leads.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def get_to_module(self) -&gt; str | None:\n    \"\"\"Get the name of the module to which the bypass leads.\"\"\"\n    return self._to_module\n</code></pre> <code></code> <code>get_volume() -&gt; AvgFlowVolume</code> <p>Get the volume of the bypass.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def get_volume(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the volume of the bypass.\"\"\"\n    return self._volume\n</code></pre> <code></code> <code>set_to_module(to_module: str) -&gt; None</code> <p>Set the name of the module to which the bypass leads.</p> Source code in <code>framcore/attributes/hydro/HydroBypass.py</code> <pre><code>def set_to_module(self, to_module: str) -&gt; None:\n    \"\"\"Set the name of the module to which the bypass leads.\"\"\"\n    self._check_type(to_module, str)\n    self._to_module = to_module\n</code></pre>"},{"location":"reference/#framcore.attributes.hydro.HydroGenerator","title":"<code>HydroGenerator</code>","text":""},{"location":"reference/#framcore.attributes.hydro.HydroGenerator.HydroGenerator","title":"<code>HydroGenerator</code>","text":"<p>               Bases: <code>Base</code></p> <p>Produces power from the main release of a HydroModule.</p> <p>Produces to a power node, and can have variable costs associated with operation. Other attributes are energy equivalent, PQ curve, nominal head and tailwater elevation.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>class HydroGenerator(Base):\n    \"\"\"\n    Produces power from the main release of a HydroModule.\n\n    Produces to a power node, and can have variable costs associated with operation. Other attributes are energy equivalent, PQ curve, nominal head\n    and tailwater elevation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        power_node: str,\n        energy_equivalent: Conversion,  # energy equivalent\n        pq_curve: Expr | str | Curve | None = None,\n        nominal_head: Expr | str | TimeVector | None = None,\n        tailwater_elevation: Expr | str | TimeVector | None = None,\n        voc: Cost | None = None,\n        production: AvgFlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a HydroGenerator with parameters.\n\n        Args:\n            power_node (str): Node to supply power to.\n            energy_equivalent (Conversion): Conversion factor of power produced to water released.\n            pq_curve (Expr | str | Curve | None, optional): Expression or curve describing the relationship produced power and water released. Defaults to None.\n            nominal_head (Expr | str | TimeVector | None, optional): Vertical distance between upstream and dowstream water level. Defaults to None.\n            tailwater_elevation (Expr | str | TimeVector | None, optional): Elevation at the surface where the water exits the turbine. Defaults to None.\n            voc (Cost | None, optional): Variable operational costs. Defaults to None.\n            production (AvgFlowVolume | None, optional): Result of power volume produced. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n\n        self._check_type(power_node, str)\n        self._check_type(energy_equivalent, Conversion)\n        self._check_type(pq_curve, (Expr, str, Curve, type(None)))\n        self._check_type(nominal_head, (Expr, str, TimeVector, type(None)))\n        self._check_type(tailwater_elevation, (Expr, str, TimeVector, type(None)))\n        self._check_type(voc, (Cost, type(None)))\n\n        self._power_node = power_node\n        self._energy_eq = energy_equivalent\n        self._pq_curve = ensure_expr(pq_curve)\n        self._nominal_head = ensure_expr(nominal_head, is_level=True)\n        self._tailwater_elevation = ensure_expr(tailwater_elevation, is_level=True)\n        self._voc = voc\n\n        if production is None:\n            production = AvgFlowVolume()\n        self._production: AvgFlowVolume = production\n\n    def get_power_node(self) -&gt; str:\n        \"\"\"Get the power node of the hydro generator.\"\"\"\n        return self._power_node\n\n    def set_power_node(self, power_node: str) -&gt; None:\n        \"\"\"Set the power node of the pump unit.\"\"\"\n        self._check_type(power_node, str)\n        self._power_node = power_node\n\n    def get_energy_equivalent(self) -&gt; Conversion:\n        \"\"\"Get the energy equivalent of the hydro generator.\"\"\"\n        return self._energy_eq\n\n    def get_pq_curve(self) -&gt; Expr | None:\n        \"\"\"Get the PQ curve of the hydro generator.\"\"\"\n        return self._pq_curve\n\n    def get_nominal_head(self) -&gt; Expr | None:\n        \"\"\"Get the nominal head of the hydro generator.\"\"\"\n        return self._nominal_head\n\n    def get_tailwater_elevation(self) -&gt; Expr | None:\n        \"\"\"Get the tailwater elevation of the hydro generator.\"\"\"\n        return self._tailwater_elevation\n\n    def get_voc(self) -&gt; Cost | None:\n        \"\"\"Get the variable operation and maintenance cost of the hydro generator.\"\"\"\n        return self._voc\n\n    def set_voc(self, voc: Cost) -&gt; None:\n        \"\"\"Set the variable operation and maintenance cost of the hydro generator.\"\"\"\n        self._check_type(voc, Cost)\n        self._voc = voc\n\n    def get_production(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the generation of the hydro generator.\"\"\"\n        return self._production\n\n    def _get_fingerprint(self) -&gt; Fingerprint:\n        raise self.get_fingerprint_default(refs={\"power_node\": self._power_node})\n</code></pre> <code></code> <code>__init__(power_node: str, energy_equivalent: Conversion, pq_curve: Expr | str | Curve | None = None, nominal_head: Expr | str | TimeVector | None = None, tailwater_elevation: Expr | str | TimeVector | None = None, voc: Cost | None = None, production: AvgFlowVolume | None = None) -&gt; None</code> <p>Initialize a HydroGenerator with parameters.</p> <p>Parameters:</p> Name Type Description Default <code>power_node</code> <code>str</code> <p>Node to supply power to.</p> required <code>energy_equivalent</code> <code>Conversion</code> <p>Conversion factor of power produced to water released.</p> required <code>pq_curve</code> <code>Expr | str | Curve | None</code> <p>Expression or curve describing the relationship produced power and water released. Defaults to None.</p> <code>None</code> <code>nominal_head</code> <code>Expr | str | TimeVector | None</code> <p>Vertical distance between upstream and dowstream water level. Defaults to None.</p> <code>None</code> <code>tailwater_elevation</code> <code>Expr | str | TimeVector | None</code> <p>Elevation at the surface where the water exits the turbine. Defaults to None.</p> <code>None</code> <code>voc</code> <code>Cost | None</code> <p>Variable operational costs. Defaults to None.</p> <code>None</code> <code>production</code> <code>AvgFlowVolume | None</code> <p>Result of power volume produced. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def __init__(\n    self,\n    power_node: str,\n    energy_equivalent: Conversion,  # energy equivalent\n    pq_curve: Expr | str | Curve | None = None,\n    nominal_head: Expr | str | TimeVector | None = None,\n    tailwater_elevation: Expr | str | TimeVector | None = None,\n    voc: Cost | None = None,\n    production: AvgFlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a HydroGenerator with parameters.\n\n    Args:\n        power_node (str): Node to supply power to.\n        energy_equivalent (Conversion): Conversion factor of power produced to water released.\n        pq_curve (Expr | str | Curve | None, optional): Expression or curve describing the relationship produced power and water released. Defaults to None.\n        nominal_head (Expr | str | TimeVector | None, optional): Vertical distance between upstream and dowstream water level. Defaults to None.\n        tailwater_elevation (Expr | str | TimeVector | None, optional): Elevation at the surface where the water exits the turbine. Defaults to None.\n        voc (Cost | None, optional): Variable operational costs. Defaults to None.\n        production (AvgFlowVolume | None, optional): Result of power volume produced. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n\n    self._check_type(power_node, str)\n    self._check_type(energy_equivalent, Conversion)\n    self._check_type(pq_curve, (Expr, str, Curve, type(None)))\n    self._check_type(nominal_head, (Expr, str, TimeVector, type(None)))\n    self._check_type(tailwater_elevation, (Expr, str, TimeVector, type(None)))\n    self._check_type(voc, (Cost, type(None)))\n\n    self._power_node = power_node\n    self._energy_eq = energy_equivalent\n    self._pq_curve = ensure_expr(pq_curve)\n    self._nominal_head = ensure_expr(nominal_head, is_level=True)\n    self._tailwater_elevation = ensure_expr(tailwater_elevation, is_level=True)\n    self._voc = voc\n\n    if production is None:\n        production = AvgFlowVolume()\n    self._production: AvgFlowVolume = production\n</code></pre> <code></code> <code>get_energy_equivalent() -&gt; Conversion</code> <p>Get the energy equivalent of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_energy_equivalent(self) -&gt; Conversion:\n    \"\"\"Get the energy equivalent of the hydro generator.\"\"\"\n    return self._energy_eq\n</code></pre> <code></code> <code>get_nominal_head() -&gt; Expr | None</code> <p>Get the nominal head of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_nominal_head(self) -&gt; Expr | None:\n    \"\"\"Get the nominal head of the hydro generator.\"\"\"\n    return self._nominal_head\n</code></pre> <code></code> <code>get_power_node() -&gt; str</code> <p>Get the power node of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_power_node(self) -&gt; str:\n    \"\"\"Get the power node of the hydro generator.\"\"\"\n    return self._power_node\n</code></pre> <code></code> <code>get_pq_curve() -&gt; Expr | None</code> <p>Get the PQ curve of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_pq_curve(self) -&gt; Expr | None:\n    \"\"\"Get the PQ curve of the hydro generator.\"\"\"\n    return self._pq_curve\n</code></pre> <code></code> <code>get_production() -&gt; AvgFlowVolume</code> <p>Get the generation of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_production(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the generation of the hydro generator.\"\"\"\n    return self._production\n</code></pre> <code></code> <code>get_tailwater_elevation() -&gt; Expr | None</code> <p>Get the tailwater elevation of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_tailwater_elevation(self) -&gt; Expr | None:\n    \"\"\"Get the tailwater elevation of the hydro generator.\"\"\"\n    return self._tailwater_elevation\n</code></pre> <code></code> <code>get_voc() -&gt; Cost | None</code> <p>Get the variable operation and maintenance cost of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def get_voc(self) -&gt; Cost | None:\n    \"\"\"Get the variable operation and maintenance cost of the hydro generator.\"\"\"\n    return self._voc\n</code></pre> <code></code> <code>set_power_node(power_node: str) -&gt; None</code> <p>Set the power node of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def set_power_node(self, power_node: str) -&gt; None:\n    \"\"\"Set the power node of the pump unit.\"\"\"\n    self._check_type(power_node, str)\n    self._power_node = power_node\n</code></pre> <code></code> <code>set_voc(voc: Cost) -&gt; None</code> <p>Set the variable operation and maintenance cost of the hydro generator.</p> Source code in <code>framcore/attributes/hydro/HydroGenerator.py</code> <pre><code>def set_voc(self, voc: Cost) -&gt; None:\n    \"\"\"Set the variable operation and maintenance cost of the hydro generator.\"\"\"\n    self._check_type(voc, Cost)\n    self._voc = voc\n</code></pre>"},{"location":"reference/#framcore.attributes.hydro.HydroPump","title":"<code>HydroPump</code>","text":""},{"location":"reference/#framcore.attributes.hydro.HydroPump.HydroPump","title":"<code>HydroPump</code>","text":"<p>               Bases: <code>Base</code></p> <p>Represent a pump associated with a HydroModule.</p> <p>The HydroPump can consume power from a power Node to move water upstream between two HydroModules. It has a max power capacity, and mean energy equivalent and water capacity. It can also describe the relationship between head and flow (Q), with min and max head and flow.</p> <p>Results for water and power consumption are stored as AvgFlowVolume attributes.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>class HydroPump(Base):\n    \"\"\"\n    Represent a pump associated with a HydroModule.\n\n    The HydroPump can consume power from a power Node to move water upstream between two HydroModules. It has a max power capacity, and mean energy\n    equivalent and water capacity. It can also describe the relationship between head and flow (Q), with min and max head and flow.\n\n    Results for water and power consumption are stored as AvgFlowVolume attributes.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        power_node: str,\n        from_module: str,\n        to_module: str,\n        water_capacity: FlowVolume,\n        energy_equivalent: Conversion,\n        power_capacity: FlowVolume | None = None,\n        head_min: Expr | str | TimeVector | None = None,\n        head_max: Expr | str | TimeVector | None = None,\n        q_min: Expr | str | TimeVector | None = None,\n        q_max: Expr | str | TimeVector | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a HydroPump object parameters.\n\n        Args:\n            power_node (str): Node to take power from when operating.\n            from_module (str): Source HydroModule to move water from.\n            to_module (str): Destination HydroModule to move water to.\n            water_capacity (FlowVolume): Max pumped water volume given the mean energy equivalent and power capacity.\n            energy_equivalent (Conversion): Mean conversion factor between power consumed and volume of water moved.\n            power_capacity (FlowVolume | None, optional): Max power consumed. Defaults to None.\n            head_min (Expr | str | TimeVector | None, optional): Minimum elevation difference between upstream and downstream water level. Defaults to None.\n            head_max (Expr | str | TimeVector | None, optional): Maximum elevation difference between upstream and downstream water level. Defaults to None.\n            q_min (Expr | str | TimeVector | None, optional): Maximum water flow at head_min. Defaults to None.\n            q_max (Expr | str | TimeVector | None, optional): Maximum water flow at head_max. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n        self._check_type(power_node, str)\n        self._check_modules(from_module, to_module)  # checks types and that they are not the same.\n        self._check_type(water_capacity, FlowVolume)\n        self._check_type(power_capacity, (FlowVolume, type(None)))\n        self._check_type(energy_equivalent, Conversion)\n        self._check_type(head_min, (Expr, str, TimeVector, type(None)))\n        self._check_type(head_max, (Expr, str, TimeVector, type(None)))\n        self._check_type(q_min, (Expr, str, TimeVector, type(None)))\n        self._check_type(q_max, (Expr, str, TimeVector, type(None)))\n\n        self._power_node = power_node\n        self._from_module = from_module\n        self._to_module = to_module\n        self._water_capacity = water_capacity\n        self._energy_eq = energy_equivalent\n        self._power_capacity = power_capacity\n\n        self._hmin = ensure_expr(head_min, is_level=True)\n        self._hmax = ensure_expr(head_max, is_level=True)\n        self._qmin = ensure_expr(q_min, is_flow=True, is_level=True)\n        self._qmax = ensure_expr(q_max, is_flow=True, is_level=True)\n\n        self._water_consumption = AvgFlowVolume()\n        self._power_consumption = AvgFlowVolume()\n\n    def get_water_capacity(self) -&gt; FlowVolume:\n        \"\"\"Get the capacity of the pump unit.\"\"\"\n        return self._water_capacity\n\n    def get_power_capacity(self) -&gt; FlowVolume:\n        \"\"\"Get the capacity of the pump unit.\"\"\"\n        return self._power_capacity\n\n    def get_power_node(self) -&gt; str:\n        \"\"\"Get the power node of the pump unit.\"\"\"\n        return self._power_node\n\n    def set_power_node(self, power_node: str) -&gt; None:\n        \"\"\"Set the power node of the pump unit.\"\"\"\n        self._check_type(power_node, str)\n        self._power_node = power_node\n\n    def get_from_module(self) -&gt; str:\n        \"\"\"Get the module from which the pump unit is pumping.\"\"\"\n        return self._from_module\n\n    def get_to_module(self) -&gt; str:\n        \"\"\"Get the module to which the pump unit is pumping.\"\"\"\n        return self._to_module\n\n    # TODO: should be split in two? Keep in mind we check that the to and from modules are not the same. So if we split this user might run into issues if\n    # trying to first set from_module to to_module then change to_module.\n    def set_modules(self, from_module: str, to_module: str) -&gt; None:\n        \"\"\"Set the modules for the pump unit.\"\"\"\n        self._check_modules(from_module, to_module)\n        self._from_module = from_module\n        self._to_module = to_module\n\n    def get_water_consumption(self) -&gt; FlowVolume:\n        \"\"\"Get the water consumption of the pump unit.\"\"\"\n        return self._water_consumption\n\n    def get_power_consumption(self) -&gt; FlowVolume:\n        \"\"\"Get the power consumption of the pump unit.\"\"\"\n        return self._power_consumption\n\n    def _check_modules(self, from_module: str, to_module: str) -&gt; None:\n        self._check_type(from_module, str)\n        self._check_type(to_module, str)\n        if from_module == to_module:\n            message = f\"{self} cannot pump to and from the same module. Got {from_module} for both from_module and to_module.\"\n            raise ValueError(message)\n\n    def _check_base_module_name(self, base_name: str) -&gt; None:\n        if base_name not in (self._from_module, self._to_module):\n            message = (\n                f\"Module {base_name} has not been coupled correctly to its pump {self}. Pump is coupled to modules {self._from_module} and {self._to_module}\"\n            )\n            raise RuntimeError(message)\n\n    # other parameters\n    def get_energy_equivalent(self) -&gt; Conversion:\n        \"\"\"Get the energy equivalent of hydro pump.\"\"\"\n        return self._energy_eq\n\n    def set_energy_eq(self, energy_eq: Conversion) -&gt; None:\n        \"\"\"Set the energy equivalent.\"\"\"\n        self._check_type(energy_eq, Conversion)\n        self._energy_eq = energy_eq\n\n    def get_head_min(self) -&gt; Expr:\n        \"\"\"Get min fall height of hydro pump.\"\"\"\n        return self._head_min\n\n    def set_head_min(self, head_min: Expr | str | None) -&gt; None:\n        \"\"\"Set min fall height.\"\"\"\n        self._head_min = ensure_expr(head_min)\n\n    def get_head_max(self) -&gt; Expr:\n        \"\"\"Get max fall height of hydro pump.\"\"\"\n        return self._hmax\n\n    def set_head_max(self, hmax: Expr | str | None) -&gt; None:\n        \"\"\"Set max fall height.\"\"\"\n        self._hmax = ensure_expr(hmax)\n\n    def get_q_min(self) -&gt; Expr:\n        \"\"\"Get Q min of hydro pump.\"\"\"\n        return self._q_min\n\n    def set_qmin(self, q_min: Expr | str | None) -&gt; None:\n        \"\"\"Set Q min.\"\"\"\n        self._q_min = ensure_expr(q_min)\n\n    def get_q_max(self) -&gt; Expr:\n        \"\"\"Get Q max of hydro pump.\"\"\"\n        return self._q_max\n\n    def set_qmax(self, q_max: Expr | str | None) -&gt; None:\n        \"\"\"Set Q max.\"\"\"\n        self._q_max = ensure_expr(q_max)\n\n    def _get_fingerprint(self) -&gt; Fingerprint:\n        return self.get_fingerprint_default(\n            refs={\n                \"power_node\": self._power_node,\n                \"from_module\": self._from_module,\n                \"to_module\": self._to_module,\n            },\n        )\n</code></pre> <code></code> <code>__init__(power_node: str, from_module: str, to_module: str, water_capacity: FlowVolume, energy_equivalent: Conversion, power_capacity: FlowVolume | None = None, head_min: Expr | str | TimeVector | None = None, head_max: Expr | str | TimeVector | None = None, q_min: Expr | str | TimeVector | None = None, q_max: Expr | str | TimeVector | None = None) -&gt; None</code> <p>Initialize a HydroPump object parameters.</p> <p>Parameters:</p> Name Type Description Default <code>power_node</code> <code>str</code> <p>Node to take power from when operating.</p> required <code>from_module</code> <code>str</code> <p>Source HydroModule to move water from.</p> required <code>to_module</code> <code>str</code> <p>Destination HydroModule to move water to.</p> required <code>water_capacity</code> <code>FlowVolume</code> <p>Max pumped water volume given the mean energy equivalent and power capacity.</p> required <code>energy_equivalent</code> <code>Conversion</code> <p>Mean conversion factor between power consumed and volume of water moved.</p> required <code>power_capacity</code> <code>FlowVolume | None</code> <p>Max power consumed. Defaults to None.</p> <code>None</code> <code>head_min</code> <code>Expr | str | TimeVector | None</code> <p>Minimum elevation difference between upstream and downstream water level. Defaults to None.</p> <code>None</code> <code>head_max</code> <code>Expr | str | TimeVector | None</code> <p>Maximum elevation difference between upstream and downstream water level. Defaults to None.</p> <code>None</code> <code>q_min</code> <code>Expr | str | TimeVector | None</code> <p>Maximum water flow at head_min. Defaults to None.</p> <code>None</code> <code>q_max</code> <code>Expr | str | TimeVector | None</code> <p>Maximum water flow at head_max. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def __init__(\n    self,\n    power_node: str,\n    from_module: str,\n    to_module: str,\n    water_capacity: FlowVolume,\n    energy_equivalent: Conversion,\n    power_capacity: FlowVolume | None = None,\n    head_min: Expr | str | TimeVector | None = None,\n    head_max: Expr | str | TimeVector | None = None,\n    q_min: Expr | str | TimeVector | None = None,\n    q_max: Expr | str | TimeVector | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a HydroPump object parameters.\n\n    Args:\n        power_node (str): Node to take power from when operating.\n        from_module (str): Source HydroModule to move water from.\n        to_module (str): Destination HydroModule to move water to.\n        water_capacity (FlowVolume): Max pumped water volume given the mean energy equivalent and power capacity.\n        energy_equivalent (Conversion): Mean conversion factor between power consumed and volume of water moved.\n        power_capacity (FlowVolume | None, optional): Max power consumed. Defaults to None.\n        head_min (Expr | str | TimeVector | None, optional): Minimum elevation difference between upstream and downstream water level. Defaults to None.\n        head_max (Expr | str | TimeVector | None, optional): Maximum elevation difference between upstream and downstream water level. Defaults to None.\n        q_min (Expr | str | TimeVector | None, optional): Maximum water flow at head_min. Defaults to None.\n        q_max (Expr | str | TimeVector | None, optional): Maximum water flow at head_max. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self._check_type(power_node, str)\n    self._check_modules(from_module, to_module)  # checks types and that they are not the same.\n    self._check_type(water_capacity, FlowVolume)\n    self._check_type(power_capacity, (FlowVolume, type(None)))\n    self._check_type(energy_equivalent, Conversion)\n    self._check_type(head_min, (Expr, str, TimeVector, type(None)))\n    self._check_type(head_max, (Expr, str, TimeVector, type(None)))\n    self._check_type(q_min, (Expr, str, TimeVector, type(None)))\n    self._check_type(q_max, (Expr, str, TimeVector, type(None)))\n\n    self._power_node = power_node\n    self._from_module = from_module\n    self._to_module = to_module\n    self._water_capacity = water_capacity\n    self._energy_eq = energy_equivalent\n    self._power_capacity = power_capacity\n\n    self._hmin = ensure_expr(head_min, is_level=True)\n    self._hmax = ensure_expr(head_max, is_level=True)\n    self._qmin = ensure_expr(q_min, is_flow=True, is_level=True)\n    self._qmax = ensure_expr(q_max, is_flow=True, is_level=True)\n\n    self._water_consumption = AvgFlowVolume()\n    self._power_consumption = AvgFlowVolume()\n</code></pre> <code></code> <code>get_energy_equivalent() -&gt; Conversion</code> <p>Get the energy equivalent of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_energy_equivalent(self) -&gt; Conversion:\n    \"\"\"Get the energy equivalent of hydro pump.\"\"\"\n    return self._energy_eq\n</code></pre> <code></code> <code>get_from_module() -&gt; str</code> <p>Get the module from which the pump unit is pumping.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_from_module(self) -&gt; str:\n    \"\"\"Get the module from which the pump unit is pumping.\"\"\"\n    return self._from_module\n</code></pre> <code></code> <code>get_head_max() -&gt; Expr</code> <p>Get max fall height of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_head_max(self) -&gt; Expr:\n    \"\"\"Get max fall height of hydro pump.\"\"\"\n    return self._hmax\n</code></pre> <code></code> <code>get_head_min() -&gt; Expr</code> <p>Get min fall height of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_head_min(self) -&gt; Expr:\n    \"\"\"Get min fall height of hydro pump.\"\"\"\n    return self._head_min\n</code></pre> <code></code> <code>get_power_capacity() -&gt; FlowVolume</code> <p>Get the capacity of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_power_capacity(self) -&gt; FlowVolume:\n    \"\"\"Get the capacity of the pump unit.\"\"\"\n    return self._power_capacity\n</code></pre> <code></code> <code>get_power_consumption() -&gt; FlowVolume</code> <p>Get the power consumption of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_power_consumption(self) -&gt; FlowVolume:\n    \"\"\"Get the power consumption of the pump unit.\"\"\"\n    return self._power_consumption\n</code></pre> <code></code> <code>get_power_node() -&gt; str</code> <p>Get the power node of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_power_node(self) -&gt; str:\n    \"\"\"Get the power node of the pump unit.\"\"\"\n    return self._power_node\n</code></pre> <code></code> <code>get_q_max() -&gt; Expr</code> <p>Get Q max of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_q_max(self) -&gt; Expr:\n    \"\"\"Get Q max of hydro pump.\"\"\"\n    return self._q_max\n</code></pre> <code></code> <code>get_q_min() -&gt; Expr</code> <p>Get Q min of hydro pump.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_q_min(self) -&gt; Expr:\n    \"\"\"Get Q min of hydro pump.\"\"\"\n    return self._q_min\n</code></pre> <code></code> <code>get_to_module() -&gt; str</code> <p>Get the module to which the pump unit is pumping.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_to_module(self) -&gt; str:\n    \"\"\"Get the module to which the pump unit is pumping.\"\"\"\n    return self._to_module\n</code></pre> <code></code> <code>get_water_capacity() -&gt; FlowVolume</code> <p>Get the capacity of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_water_capacity(self) -&gt; FlowVolume:\n    \"\"\"Get the capacity of the pump unit.\"\"\"\n    return self._water_capacity\n</code></pre> <code></code> <code>get_water_consumption() -&gt; FlowVolume</code> <p>Get the water consumption of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def get_water_consumption(self) -&gt; FlowVolume:\n    \"\"\"Get the water consumption of the pump unit.\"\"\"\n    return self._water_consumption\n</code></pre> <code></code> <code>set_energy_eq(energy_eq: Conversion) -&gt; None</code> <p>Set the energy equivalent.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_energy_eq(self, energy_eq: Conversion) -&gt; None:\n    \"\"\"Set the energy equivalent.\"\"\"\n    self._check_type(energy_eq, Conversion)\n    self._energy_eq = energy_eq\n</code></pre> <code></code> <code>set_head_max(hmax: Expr | str | None) -&gt; None</code> <p>Set max fall height.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_head_max(self, hmax: Expr | str | None) -&gt; None:\n    \"\"\"Set max fall height.\"\"\"\n    self._hmax = ensure_expr(hmax)\n</code></pre> <code></code> <code>set_head_min(head_min: Expr | str | None) -&gt; None</code> <p>Set min fall height.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_head_min(self, head_min: Expr | str | None) -&gt; None:\n    \"\"\"Set min fall height.\"\"\"\n    self._head_min = ensure_expr(head_min)\n</code></pre> <code></code> <code>set_modules(from_module: str, to_module: str) -&gt; None</code> <p>Set the modules for the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_modules(self, from_module: str, to_module: str) -&gt; None:\n    \"\"\"Set the modules for the pump unit.\"\"\"\n    self._check_modules(from_module, to_module)\n    self._from_module = from_module\n    self._to_module = to_module\n</code></pre> <code></code> <code>set_power_node(power_node: str) -&gt; None</code> <p>Set the power node of the pump unit.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_power_node(self, power_node: str) -&gt; None:\n    \"\"\"Set the power node of the pump unit.\"\"\"\n    self._check_type(power_node, str)\n    self._power_node = power_node\n</code></pre> <code></code> <code>set_qmax(q_max: Expr | str | None) -&gt; None</code> <p>Set Q max.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_qmax(self, q_max: Expr | str | None) -&gt; None:\n    \"\"\"Set Q max.\"\"\"\n    self._q_max = ensure_expr(q_max)\n</code></pre> <code></code> <code>set_qmin(q_min: Expr | str | None) -&gt; None</code> <p>Set Q min.</p> Source code in <code>framcore/attributes/hydro/HydroPump.py</code> <pre><code>def set_qmin(self, q_min: Expr | str | None) -&gt; None:\n    \"\"\"Set Q min.\"\"\"\n    self._q_min = ensure_expr(q_min)\n</code></pre>"},{"location":"reference/#framcore.attributes.hydro.HydroReservoir","title":"<code>HydroReservoir</code>","text":""},{"location":"reference/#framcore.attributes.hydro.HydroReservoir.HydroReservoir","title":"<code>HydroReservoir</code>","text":"<p>               Bases: <code>Storage</code></p> <p>Represent a hydro reservoir of a HydroModule.</p> Source code in <code>framcore/attributes/hydro/HydroReservoir.py</code> <pre><code>class HydroReservoir(Storage):\n    \"\"\"Represent a hydro reservoir of a HydroModule.\"\"\"\n\n    def __init__(\n        self,\n        capacity: StockVolume,\n        reservoir_curve: ReservoirCurve = None,\n        volume: StockVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a HydroReservoir instance.\n\n        Args:\n            capacity (StockVolume): The maximum storage capacity of the reservoir.\n            reservoir_curve (ReservoirCurve, optional): The curve describing water level elevation to volume characteristics.\n            volume (StockVolume, optional): Volume of water in the reservoir.\n\n        \"\"\"\n        super().__init__(\n            capacity=capacity,\n            reservoir_curve=reservoir_curve,\n            volume=volume,\n        )\n</code></pre> <code></code> <code>__init__(capacity: StockVolume, reservoir_curve: ReservoirCurve = None, volume: StockVolume | None = None) -&gt; None</code> <p>Initialize a HydroReservoir instance.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>StockVolume</code> <p>The maximum storage capacity of the reservoir.</p> required <code>reservoir_curve</code> <code>ReservoirCurve</code> <p>The curve describing water level elevation to volume characteristics.</p> <code>None</code> <code>volume</code> <code>StockVolume</code> <p>Volume of water in the reservoir.</p> <code>None</code> Source code in <code>framcore/attributes/hydro/HydroReservoir.py</code> <pre><code>def __init__(\n    self,\n    capacity: StockVolume,\n    reservoir_curve: ReservoirCurve = None,\n    volume: StockVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a HydroReservoir instance.\n\n    Args:\n        capacity (StockVolume): The maximum storage capacity of the reservoir.\n        reservoir_curve (ReservoirCurve, optional): The curve describing water level elevation to volume characteristics.\n        volume (StockVolume, optional): Volume of water in the reservoir.\n\n    \"\"\"\n    super().__init__(\n        capacity=capacity,\n        reservoir_curve=reservoir_curve,\n        volume=volume,\n    )\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes","title":"<code>level_profile_attributes</code>","text":""},{"location":"reference/#framcore.attributes.level_profile_attributes.ArrowCoefficient","title":"<code>ArrowCoefficient</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Abstract class representing an arrow coefficient attribute, used for efficiency, loss, and conversion coefficients.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class ArrowCoefficient(Coefficient):\n    \"\"\"\n    Abstract class representing an arrow coefficient attribute, used for efficiency, loss, and conversion coefficients.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.AvgFlowVolume","title":"<code>AvgFlowVolume</code>","text":"<p>               Bases: <code>FlowVolume</code></p> <p>Concrete class representing an average flow volume attribute, indicating a flow variable with average values.</p> <p>Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class AvgFlowVolume(FlowVolume):\n    \"\"\"\n    Concrete class representing an average flow volume attribute, indicating a flow variable with average values.\n\n    Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Coefficient","title":"<code>Coefficient</code>","text":"<p>               Bases: <code>LevelProfile</code></p> <p>Abstract class representing a coefficient attribute, used as a base class for various coefficient types.</p> <p>Subclass of LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Coefficient(LevelProfile):\n    \"\"\"\n    Abstract class representing a coefficient attribute, used as a base class for various coefficient types.\n\n    Subclass of LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Conversion","title":"<code>Conversion</code>","text":"<p>               Bases: <code>ArrowCoefficient</code></p> <p>Concrete class representing a conversion coefficient attribute, used for conversion factors in the model.</p> <p>Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Conversion(ArrowCoefficient):\n    \"\"\"\n    Concrete class representing a conversion coefficient attribute, used for conversion factors in the model.\n\n    Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Cost","title":"<code>Cost</code>","text":"<p>               Bases: <code>ObjectiveCoefficient</code></p> <p>Concrete class representing a cost attribute, indicating cost coefficients in the objective function.</p> <p>Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Cost(ObjectiveCoefficient):\n    \"\"\"\n    Concrete class representing a cost attribute, indicating cost coefficients in the objective function.\n\n    Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_COST = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Efficiency","title":"<code>Efficiency</code>","text":"<p>               Bases: <code>ArrowCoefficient</code></p> <p>Concrete class representing an efficiency coefficient attribute, indicating a unitless coefficient.</p> <p>Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Efficiency(ArrowCoefficient):\n    \"\"\"\n    Concrete class representing an efficiency coefficient attribute, indicating a unitless coefficient.\n\n    Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Elasticity","title":"<code>Elasticity</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Concrete class representing an elasticity coefficient attribute, indicating a unitless coefficient.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Elasticity(Coefficient):  # TODO: How do this work?\n    \"\"\"\n    Concrete class representing an elasticity coefficient attribute, indicating a unitless coefficient.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.FlowVolume","title":"<code>FlowVolume</code>","text":"<p>               Bases: <code>LevelProfile</code></p> <p>Abstract class representing a flow volume attribute, indicating that the attribute is a flow variable.</p> <p>Subclass of LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class FlowVolume(LevelProfile):\n    \"\"\"\n    Abstract class representing a flow volume attribute, indicating that the attribute is a flow variable.\n\n    Subclass of LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_FLOW = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Hours","title":"<code>Hours</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Concrete class representing an hours coefficient attribute, indicating a time-related coefficient.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Hours(Coefficient):  # TODO: How do this work?\n    \"\"\"\n    Concrete class representing an hours coefficient attribute, indicating a time-related coefficient.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile","title":"<code>LevelProfile</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Attributes representing timeseries data for Components. Mostly as Level * Profile, where both Level and Profile are Expr (expressions).</p> <p>Level and Profile represent two distinct dimensions of time. This is because we want to simulate future system states with historical weather patterns. Therefore, Level represents the system state at a given time (data_dim), while Profile represents the scenario dimension (scen_dim). A Level would for example represent the installed capacity of solar plants towards 2030, while the Profile would represent the historical variation between 1991-2020.</p> <p>Level and Profile can have two main formats: A maximum Level with a Profile that varies between 0-1, and an average Level with a Profile with a mean of 1 (the latter can have a ReferencePeriod). The max format is, for example, used for capacities, while the mean format can be used for prices and flows. The system needs to be able to convert between the two formats. This is especially important for aggregations (for example weighted averages) where all the TimeVectors need to be on the same format for a correct result. One simple example of conversion is pairing a max Level of 100 MW with a mean_one Profile [0, 1, 2]. Asking for this on the max format will return the series 100[0, 0.5, 1] MW, while on the avg format it will return 50[0, 1, 2] MW.</p> <p>Queries to LevelProfile need to provide a database, the desired target TimeIndex for both dimensions, the target unit and the desired format. At the moment we support these queries for LevelProfile: - self.get_data_value(db, scen_dim, data_dim, unit, is_max_level) - self.get_scenario_vector(db, scen_dim, data_dim, unit, is_float32)</p> <p>In addition, we have the possibility to shift, scale, and change the intercept of the LevelProfiles. Then we get the full representation: Scale * (Level + Level_shift) * Profile + Intercept. - Level_shift adds a constant value to Level, has the same Profile as Level. - Scale multiplies (Level + Level_shift) by a constant value. - Intercept adds a constant value to LevelProfile, ignoring Level and Profile. This is the only way of supporting a timeseries that crosses zero     in our system. This functionality is under development and has not been properly tested.</p> <p>LevelProfiles also have additional properties that describes their behaviour. These can be used for initialization, validation, and to simplify queries. The properties are: - is_stock: True if attribute is a stock variable. Level Expr should also have is_stock=True. See Expr for details. - is_flow: True if attribute is a flow variable. Level Expr should also have is_flow=True. See Expr for details. - is_not_negative: True if attribute is not allowed to have negative values. Level Expr should also have only non-negative values. - is_max_and_zero_one: Preferred format of Level and Profile. Used for initialization and queries. - is_ingoing: True if attribute is ingoing, False if outgoing, None if neither. - is_cost: True if attribute is objective function cost coefficient. Else None. - is_unitless: True if attribute is known to be unitless. False if known to have a unit that is not None. Else None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class LevelProfile(Base, ABC):\n    \"\"\"\n    Attributes representing timeseries data for Components. Mostly as Level * Profile, where both Level and Profile are Expr (expressions).\n\n    Level and Profile represent two distinct dimensions of time. This is because we want to simulate future system states with historical weather patterns.\n    Therefore, Level represents the system state at a given time (data_dim), while Profile represents the scenario dimension (scen_dim).\n    A Level would for example represent the installed capacity of solar plants towards 2030,\n    while the Profile would represent the historical variation between 1991-2020.\n\n    Level and Profile can have two main formats: A maximum Level with a Profile that varies between 0-1,\n    and an average Level with a Profile with a mean of 1 (the latter can have a ReferencePeriod).\n    The max format is, for example, used for capacities, while the mean format can be used for prices and flows.\n    The system needs to be able to convert between the two formats. This is especially important for aggregations\n    (for example weighted averages) where all the TimeVectors need to be on the same format for a correct result.\n    One simple example of conversion is pairing a max Level of 100 MW with a mean_one Profile [0, 1, 2].\n    Asking for this on the max format will return the series 100*[0, 0.5, 1] MW, while on the avg format it will return 50*[0, 1, 2] MW.\n\n    Queries to LevelProfile need to provide a database, the desired target TimeIndex for both dimensions, the target unit and the desired format.\n    At the moment we support these queries for LevelProfile:\n    - self.get_data_value(db, scen_dim, data_dim, unit, is_max_level)\n    - self.get_scenario_vector(db, scen_dim, data_dim, unit, is_float32)\n\n    In addition, we have the possibility to shift, scale, and change the intercept of the LevelProfiles.\n    Then we get the full representation: Scale * (Level + Level_shift) * Profile + Intercept.\n    - Level_shift adds a constant value to Level, has the same Profile as Level.\n    - Scale multiplies (Level + Level_shift) by a constant value.\n    - Intercept adds a constant value to LevelProfile, ignoring Level and Profile. **This is the only way of supporting a timeseries that crosses zero\n        in our system. This functionality is under development and has not been properly tested.**\n\n    LevelProfiles also have additional properties that describes their behaviour. These can be used for initialization, validation,\n    and to simplify queries. The properties are:\n    - is_stock: True if attribute is a stock variable. Level Expr should also have is_stock=True. See Expr for details.\n    - is_flow: True if attribute is a flow variable. Level Expr should also have is_flow=True. See Expr for details.\n    - is_not_negative: True if attribute is not allowed to have negative values. Level Expr should also have only non-negative values.\n    - is_max_and_zero_one: Preferred format of Level and Profile. Used for initialization and queries.\n    - is_ingoing: True if attribute is ingoing, False if outgoing, None if neither.\n    - is_cost: True if attribute is objective function cost coefficient. Else None.\n    - is_unitless: True if attribute is known to be unitless. False if known to have a unit that is not None. Else None.\n\n    \"\"\"\n\n    # must be overwritten by subclass when otherwise\n    # don't change the defaults\n    _IS_ABSTRACT: bool = True\n    _IS_STOCK: bool = False\n    _IS_FLOW: bool = False\n    _IS_NOT_NEGATIVE: bool = True\n    _IS_MAX_AND_ZERO_ONE: bool = False\n\n    # must be set by subclass when applicable\n    _IS_INGOING: bool | None = None\n    _IS_COST: bool | None = None\n    _IS_UNITLESS: bool | None = None\n\n    def __init__(\n        self,\n        level: Expr | TimeVector | str | None = None,\n        profile: Expr | TimeVector | str | None = None,\n        value: float | int | None = None,  # To support Price(value=20, unit=\"EUR/MWh\")\n        unit: str | None = None,\n        level_shift: Expr | None = None,\n        intercept: Expr | None = None,\n        scale: Expr | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize LevelProfile.\n\n        See the LevelProfile class docstring for details. A complete LevelProfile is represented as:\n        Scale * (Level + Level_shift) * Profile + Intercept. Normally only Level and Profile are used.\n\n        Either give level and profile, or value and unit.\n\n        Args:\n            level (Expr | TimeVector | str | None, optional): Level Expr. Defaults to None.\n            profile (Expr | TimeVector | str | None, optional): Profile Expr. Defaults to None.\n            value (float | int | None, optional): A constant value to initialize Level. Defaults to None.\n            unit (str | None, optional): Unit of the constant value to initialize Level. Defaults to None.\n            level_shift (Expr | None, optional): Level_shift Expr. Defaults to None.\n            intercept (Expr | None, optional): Intercept Expr. Defaults to None.\n            scale (Expr | None, optional): Scale Expr. Defaults to None.\n\n        \"\"\"\n        self._assert_invariants()\n\n        self._check_type(value, (float, int, type(None)))\n        self._check_type(unit, (str, type(None)))\n        self._check_type(level, (Expr, TimeVector, str, type(None)))\n        self._check_type(profile, (Expr, TimeVector, str, type(None)))\n        self._check_type(level_shift, (Expr, type(None)))\n        self._check_type(intercept, (Expr, type(None)))\n        self._check_type(scale, (Expr, type(None)))\n        level = self._ensure_level_expr(level, value, unit)\n        profile = self._ensure_profile_expr(profile)\n        self._ensure_compatible_level_profile_combo(level, profile)\n        self._ensure_compatible_level_profile_combo(level_shift, profile)\n        self._level: Expr | None = level\n        self._profile: Expr | None = profile\n        self._level_shift: Expr | None = level_shift\n        self._intercept: Expr | None = intercept\n        self._scale: Expr | None = scale\n        # TODO: Validate that profiles are equal in level and level_shift.\n        # TODO: Validate that level_shift, scale and intercept only consist of Exprs with ConstantTimeVectors\n        # TODO: Validate that level_shift, level_scale and intercept have correct Expr properties\n\n    def _assert_invariants(self) -&gt; None:\n        abstract = self._IS_ABSTRACT\n        max_level_profile = self._IS_MAX_AND_ZERO_ONE\n        stock = self._IS_STOCK\n        flow = self._IS_FLOW\n        unitless = self._IS_UNITLESS\n        ingoing = self._IS_INGOING\n        cost = self._IS_COST\n        not_negative = self._IS_NOT_NEGATIVE\n\n        assert not abstract, \"Abstract types should only be used for type hints and checks.\"\n        assert isinstance(max_level_profile, bool)\n        assert isinstance(stock, bool)\n        assert isinstance(flow, bool)\n        assert isinstance(not_negative, bool)\n        assert isinstance(ingoing, bool | type(None))\n        assert isinstance(unitless, bool | type(None))\n        assert isinstance(cost, bool | type(None))\n        assert not (flow and stock)\n        if flow or stock:\n            assert not unitless, \"flow and stock must have unit that is not None.\"\n            assert not_negative, \"flow and stock cannot have negative values.\"\n        if ingoing is True:\n            assert cost is None, \"cost must be None when ingoing is True.\"\n        if cost is True:\n            assert ingoing is None, \"ingoing must be None when cost is True.\"\n\n        parent = super()\n        if isinstance(parent, LevelProfile) and not parent._IS_ABSTRACT:  # noqa: SLF001\n            self._assert_same_behaviour(parent)\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in expressions to loaders.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self.get_level())\n        add_loaders_if(loaders, self.get_profile())\n\n    def clear(self) -&gt; None:\n        \"\"\"\n        Set all internal fields to None.\n\n        You may want to use this to get exogenous flow to use capacities instead of volume.\n        \"\"\"\n        self._level = None\n        self._profile = None\n        self._level_shift = None\n        self._intercept = None\n        self._scale = None\n\n    def is_stock(self) -&gt; bool:\n        \"\"\"\n        Return True if attribute is a stock variable.\n\n        Return False if attribute is not a stock variable.\n        \"\"\"\n        return self._IS_STOCK\n\n    def is_flow(self) -&gt; bool:\n        \"\"\"\n        Return True if attribute is a flow variable.\n\n        Return False if attribute is not a flow variable.\n        \"\"\"\n        return self._IS_FLOW\n\n    def is_not_negative(self) -&gt; bool:\n        \"\"\"\n        Return True if attribute is not allowed to have negative values.\n\n        Return False if attribute can have both positive and negative values.\n        \"\"\"\n        return self._IS_NOT_NEGATIVE\n\n    def is_max_and_zero_one(self) -&gt; bool:\n        \"\"\"\n        When True level should be max (not average) and corresponding profile should be zero_one (not mean_one).\n\n        When False level should be average (not max) and corresponding profile should be mean_one (not zero_one).\n        \"\"\"\n        return self._IS_MAX_AND_ZERO_ONE\n\n    def is_ingoing(self) -&gt; bool | None:\n        \"\"\"\n        Return True if attribute is ingoing.\n\n        Return True if attribute is outgoing.\n\n        Return None if not applicable.\n        \"\"\"\n        return self._IS_INGOING\n\n    def is_cost(self) -&gt; bool | None:\n        \"\"\"\n        Return True if attribute is objective function cost coefficient.\n\n        Return False if attribute is objective function revenue coefficient.\n\n        Return None if not applicable.\n        \"\"\"\n        return self._IS_COST\n\n    def is_unitless(self) -&gt; bool | None:\n        \"\"\"\n        Return True if attribute is known to be unitless.\n\n        Return False if attribute is known to have a unit that is not None.\n\n        Return None if not applicable.\n        \"\"\"\n        return self._IS_UNITLESS\n\n    def has_level(self) -&gt; bool:\n        \"\"\"Return True if get_level will return value not None.\"\"\"\n        return (self._level is not None) or (self._level_shift is not None)\n\n    def has_profile(self) -&gt; bool:\n        \"\"\"Return True if get_profile will return value not None.\"\"\"\n        return self._profile is not None\n\n    def has_intercept(self) -&gt; bool:\n        \"\"\"Return True if get_intercept will return value not None.\"\"\"\n        return self._intercept is not None\n\n    def copy_from(self, other: LevelProfile) -&gt; None:\n        \"\"\"Copy fields from other.\"\"\"\n        self._check_type(other, LevelProfile)\n        self._assert_same_behaviour(other)\n        self._level = other._level\n        self._profile = other._profile\n        self._level_shift = other._level_shift\n        self._intercept = other._intercept\n        self._scale = other._scale\n\n    def get_level(self) -&gt; Expr | None:\n        \"\"\"Get level part of (level * profile + intercept).\"\"\"\n        level = self._level\n\n        if level is None:\n            return None\n\n        if level.is_leaf():\n            level = Expr(\n                src=level.get_src(),\n                operations=level.get_operations(expect_ops=False, copy_list=True),\n                is_stock=level.is_stock(),\n                is_flow=level.is_flow(),\n                is_level=True,\n                is_profile=False,\n                profile=self._profile,\n            )\n\n        if self._level_shift is not None:\n            level += self._level_shift\n\n        if self._scale is not None:\n            level *= self._scale\n\n        return level\n\n    def set_level(self, level: Expr | TimeVector | str | None) -&gt; None:\n        \"\"\"Set level part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n        self._check_type(level, (Expr, TimeVector, str, type(None)))\n        level = self._ensure_level_expr(level)\n        self._ensure_compatible_level_profile_combo(level, self._profile)\n        self._level = level\n\n    def get_profile(self) -&gt; Expr | None:\n        \"\"\"Get profile part of (level * profile + intercept).\"\"\"\n        return self._profile\n\n    def set_profile(self, profile: Expr | TimeVector | str | None) -&gt; None:\n        \"\"\"Set profile part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n        self._check_type(profile, (Expr, TimeVector, str, type(None)))\n        profile = self._ensure_profile_expr(profile)\n        self._ensure_compatible_level_profile_combo(self._level, profile)\n        self._profile = profile\n\n    def get_intercept(self) -&gt; Expr | None:\n        \"\"\"Get intercept part of (level * profile + intercept).\"\"\"\n        intercept = self._intercept\n        if self._scale is not None:\n            intercept *= self._scale\n        return intercept\n\n    def set_intercept(self, value: Expr | None) -&gt; None:\n        \"\"\"Set intercept part of (level * profile + intercept).\"\"\"\n        self._check_type(value, (Expr, type(None)))\n        if value is not None:\n            self._check_level_expr(value)\n        self._intercept = value\n\n    def get_level_unit_set(\n        self,\n        db: QueryDB | Model,\n    ) -&gt; set[TimeIndex]:\n        \"\"\"\n        Return set with all units behind level expression.\n\n        Useful for discovering valid unit input to get_level_value.\n        \"\"\"\n        if not self.has_level():\n            return set()\n        return get_units_from_expr(db, self.get_level())\n\n    def get_profile_timeindex_set(\n        self,\n        db: QueryDB | Model,\n    ) -&gt; set[TimeIndex]:\n        \"\"\"\n        Return set with all TimeIndex behind profile expression.\n\n        Can be used to run optimized queries, i.e. not asking for\n        finer time resolutions than necessary.\n        \"\"\"\n        if not self.has_profile():\n            return set()\n        return get_timeindexes_from_expr(db, self.get_profile())\n\n    def get_scenario_vector(\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_float32: bool = True,\n    ) -&gt; NDArray:\n        \"\"\"\n        Evaluate LevelProfile over the periods in scenario dimension, and at the level period of the data dimension.\n\n        Underlying profiles are evalutated over the scenario dimension,\n        and levels are evalutated to scalars over level_period in the data dimension.\n\n        Args:\n            db (QueryDB | Model): The database or model instance used to fetch the required data.\n            scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n            level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n            unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n                the expression should be unitless.\n            is_float32 (bool, optional): Whether to return the vector as a NumPy array with `float32`\n                precision. Defaults to True.\n\n        \"\"\"\n        return self._get_scenario_vector(db, scenario_horizon, level_period, unit, is_float32)\n\n    def get_data_value(\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_max_level: bool | None = None,\n    ) -&gt; float:\n        \"\"\"\n        Evaluate LevelProfile to a scalar at the level period of the data dimension, and as an average over the scenario horizon.\n\n        Args:\n            db (QueryDB | Model): The database or model instance used to fetch the required data.\n            scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n            level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n            unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n                the expression should be unitless.\n            is_max_level (bool | None, optional): Whether to evaluate the expression as a maximum level (with a zero_one profile)\n                or as an average level (with a mean_one profile). If None, the default format of the attribute is used.\n\n        \"\"\"\n        return self._get_data_value(db, scenario_horizon, level_period, unit, is_max_level)\n\n    def shift_intercept(self, value: float, unit: str | None) -&gt; None:\n        \"\"\"Modify the intercept part of (level * profile + intercept) of an attribute by adding a constant value.\"\"\"\n        expr = ensure_expr(\n            ConstantTimeVector(self._ensure_float(value), unit=unit, is_max_level=False),\n            is_level=True,\n            is_profile=False,\n            is_stock=self._IS_STOCK,\n            is_flow=self._IS_FLOW,\n            profile=None,\n        )\n        if self._intercept is None:\n            self._intercept = expr\n        else:\n            self._intercept += expr\n\n    def shift_level(\n        self,\n        value: float | int,\n        unit: str | None = None,\n        reference_period: ReferencePeriod | None = None,\n        is_max_level: bool | None = None,\n        use_profile: bool = True,  # TODO: Remove. Should always use profile. If has profile validate that it is equal to the profile of Level.\n    ) -&gt; None:\n        \"\"\"Modify the level_shift part of (scale * (level + level_shift) * profile + intercept) of an attribute by adding a constant value.\"\"\"\n        # TODO: Not allowed to shift if there is intercept?\n        self._check_type(value, (float, int))\n        self._check_type(unit, (str, type(None)))\n        self._check_type(reference_period, (ReferencePeriod, type(None)))\n        self._check_type(is_max_level, (bool, type(None)))\n        self._check_type(use_profile, bool)\n\n        if is_max_level is None:\n            is_max_level = self._IS_MAX_AND_ZERO_ONE\n\n        expr = ensure_expr(\n            ConstantTimeVector(\n                self._ensure_float(value),\n                unit=unit,\n                is_max_level=is_max_level,\n                reference_period=reference_period,\n            ),\n            is_level=True,\n            is_profile=False,\n            is_stock=self._IS_STOCK,\n            is_flow=self._IS_FLOW,\n            profile=self._profile if use_profile else None,\n        )\n        if self._level_shift is None:\n            self._level_shift = expr\n        else:\n            self._level_shift += expr\n\n    def scale(self, value: float | int) -&gt; None:\n        \"\"\"Modify the scale part of (scale * (level + level_shift) * profile + intercept) of an attribute by multiplying with a constant value.\"\"\"\n        # TODO: Not allowed to scale if there is intercept?\n        expr = ensure_expr(\n            ConstantTimeVector(self._ensure_float(value), unit=None, is_max_level=False),\n            is_level=True,\n            is_profile=False,\n            profile=None,\n        )\n        if self._scale is None:\n            self._scale = expr\n        else:\n            self._scale *= expr\n\n    def _ensure_level_expr(\n        self,\n        level: Expr | str | TimeVector | None,\n        value: float | int | None = None,\n        unit: str | None = None,\n        reference_period: ReferencePeriod | None = None,\n    ) -&gt; Expr | None:\n        if value is not None:\n            level = ConstantTimeVector(\n                scalar=float(value),\n                unit=unit,\n                is_max_level=self._IS_MAX_AND_ZERO_ONE,\n                is_zero_one_profile=None,\n                reference_period=reference_period,\n            )\n        if level is None:\n            return None\n\n        if isinstance(level, Expr):\n            self._check_level_expr(level)\n            return level\n\n        return Expr(\n            src=level,\n            is_flow=self._IS_FLOW,\n            is_stock=self._IS_STOCK,\n            is_level=True,\n            is_profile=False,\n            profile=None,\n        )\n\n    def _ensure_compatible_level_profile_combo(self, level: Expr | None, profile: Expr | None) -&gt; None:\n        \"\"\"Check that all profiles in leaf levels (in level) also exist in profile.\"\"\"\n        if level is None or profile is None:\n            return\n\n        leaf_level_profiles = get_profile_exprs_from_leaf_levels(level)\n        leaf_profile_profiles = get_leaf_profiles(profile)\n\n        for p in leaf_level_profiles:\n            if p not in leaf_profile_profiles:\n                message = (\n                    f\"Incompatible level/profile combination because all profiles in leaf levels (in level) does not exist in profile. \"\n                    f\"Profile expression {p} found in level {level} but not in profile.\"\n                )\n                raise ValueError(message)\n\n    def _check_level_expr(self, expr: Expr) -&gt; None:\n        msg = f\"{self} requires {expr} to be \"\n        if expr.is_stock() != self._IS_STOCK:\n            raise ValueError(msg + f\"is_stock={self._IS_STOCK}\")\n        if expr.is_flow() != self._IS_FLOW:\n            raise ValueError(msg + f\"is_flow={self._IS_STOCK}\")\n        if expr.is_level() is False:\n            raise ValueError(msg + \"is_level=True\")\n        if expr.is_profile() is True:\n            raise ValueError(msg + \"is_profile=False\")\n\n    def _check_profile_expr(self, expr: Expr) -&gt; None:\n        msg = f\"{self} requires {expr} to be \"\n        if expr.is_stock() is True:\n            raise ValueError(msg + \"is_stock=False\")\n        if expr.is_flow() is True:\n            raise ValueError(msg + \"is_flow=False\")\n        if expr.is_level() is True:\n            raise ValueError(msg + \"is_level=False\")\n        if expr.is_profile() is False:\n            raise ValueError(msg + \"is_profile=True\")\n\n    def _ensure_profile_expr(\n        self,\n        value: Expr | str | TimeVector | None,\n    ) -&gt; Expr | None:\n        if value is None:\n            return None\n\n        if isinstance(value, Expr):\n            self._check_profile_expr(value)\n            return value\n\n        return Expr(\n            src=value,\n            is_flow=False,\n            is_stock=False,\n            is_level=False,\n            is_profile=True,\n            profile=None,\n        )\n\n    def _get_data_value(\n        self,\n        db: QueryDB,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_max_level: bool | None,\n    ) -&gt; float:\n        # NB! don't type check db, as this is done in get_level_value and get_profile_vector\n        self._check_type(scenario_horizon, FixedFrequencyTimeIndex)\n        self._check_type(level_period, SinglePeriodTimeIndex)\n        self._check_type(unit, (str, type(None)))\n        self._check_type(is_max_level, (bool, type(None)))\n\n        level_expr = self.get_level()\n\n        if is_max_level is None:\n            is_max_level = self._IS_MAX_AND_ZERO_ONE\n\n        self._check_type(level_expr, (Expr, type(None)))\n        if not isinstance(level_expr, Expr):\n            raise ValueError(\"Attribute level Expr is None. Have you called Solver.solve yet?\")\n\n        level_value = get_level_value(\n            expr=level_expr,\n            db=db,\n            scen_dim=scenario_horizon,\n            data_dim=level_period,\n            unit=unit,\n            is_max=is_max_level,\n        )\n\n        intercept = None\n        if self._intercept is not None:\n            intercept = _get_constant_from_expr(\n                self._intercept,\n                db,\n                unit=unit,\n                data_dim=level_period,\n                scen_dim=scenario_horizon,\n                is_max=is_max_level,\n            )\n\n        if intercept is None:\n            return level_value\n\n        return level_value + intercept\n\n    def _get_scenario_vector(\n        self,\n        db: QueryDB | Model,\n        scenario_horizon: FixedFrequencyTimeIndex,\n        level_period: SinglePeriodTimeIndex,\n        unit: str | None,\n        is_float32: bool = True,\n    ) -&gt; NDArray:\n        \"\"\"Return vector with values along the given scenario horizon using level over level_period.\"\"\"\n        # NB! don't type check db, as this is done in get_level_value and get_profile_vector\n        self._check_type(scenario_horizon, FixedFrequencyTimeIndex)\n        self._check_type(level_period, SinglePeriodTimeIndex)\n        self._check_type(unit, (str, type(None)))\n        self._check_type(is_float32, bool)\n\n        level_expr = self.get_level()\n\n        self._check_type(level_expr, (Expr, type(None)))\n        if not isinstance(level_expr, Expr):\n            raise ValueError(\"Attribute level Expr is None. Have you called Solver.solve yet?\")\n\n        level_value = get_level_value(\n            expr=level_expr,\n            db=db,\n            scen_dim=scenario_horizon,\n            data_dim=level_period,\n            unit=unit,\n            is_max=self._IS_MAX_AND_ZERO_ONE,\n        )\n\n        profile_expr = self.get_profile()\n\n        if profile_expr is None:\n            profile_vector = np.ones(\n                scenario_horizon.get_num_periods(),\n                dtype=np.float32 if is_float32 else np.float64,\n            )\n        else:\n            profile_vector = get_profile_vector(\n                expr=profile_expr,\n                db=db,\n                scen_dim=scenario_horizon,\n                data_dim=level_period,\n                is_zero_one=self._IS_MAX_AND_ZERO_ONE,\n                is_float32=is_float32,\n            )\n\n        intercept = None\n        if self._intercept is not None:\n            intercept = _get_constant_from_expr(\n                self._intercept,\n                db,\n                unit=unit,\n                data_dim=level_period,\n                scen_dim=scenario_horizon,\n                is_max=self._IS_MAX_AND_ZERO_ONE,\n            )\n\n        if intercept is None:\n            return level_value * profile_vector\n\n        return level_value * profile_vector + intercept\n\n    def _has_same_behaviour(self, other: LevelProfile) -&gt; bool:\n        return all(\n            (\n                self._IS_FLOW == other._IS_FLOW,\n                self._IS_STOCK == other._IS_STOCK,\n                self._IS_NOT_NEGATIVE == other._IS_NOT_NEGATIVE,\n                self._IS_MAX_AND_ZERO_ONE == other._IS_MAX_AND_ZERO_ONE,\n                self._IS_INGOING == other._IS_INGOING,\n                self._IS_COST == other._IS_COST,\n                self._IS_UNITLESS == other._IS_UNITLESS,\n            ),\n        )\n\n    def _assert_same_behaviour(self, other: LevelProfile) -&gt; None:\n        if not self._has_same_behaviour(other):\n            message = f\"Not same behaviour for {self} and {other}\"\n            raise ValueError(message)\n\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Return True if other is equal to self.\"\"\"\n        if not isinstance(other, LevelProfile):\n            return False\n        if not self._has_same_behaviour(other):\n            return False\n        return all(\n            (\n                self._level == other._level,\n                self._profile == other._profile,\n                self._level_shift == other._level_shift,\n                self._intercept == other._intercept,\n                self._scale == other._scale,\n            ),\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute hash of self.\"\"\"\n        return hash(\n            (\n                type(self).__name__,\n                self._level,\n                self._profile,\n                self._level_shift,\n                self._intercept,\n                self._scale,\n            ),\n        )\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Return True if other is equal to self.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Return True if other is equal to self.\"\"\"\n    if not isinstance(other, LevelProfile):\n        return False\n    if not self._has_same_behaviour(other):\n        return False\n    return all(\n        (\n            self._level == other._level,\n            self._profile == other._profile,\n            self._level_shift == other._level_shift,\n            self._intercept == other._intercept,\n            self._scale == other._scale,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Compute hash of self.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute hash of self.\"\"\"\n    return hash(\n        (\n            type(self).__name__,\n            self._level,\n            self._profile,\n            self._level_shift,\n            self._intercept,\n            self._scale,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.__init__","title":"<code>__init__(level: Expr | TimeVector | str | None = None, profile: Expr | TimeVector | str | None = None, value: float | int | None = None, unit: str | None = None, level_shift: Expr | None = None, intercept: Expr | None = None, scale: Expr | None = None) -&gt; None</code>","text":"<p>Initialize LevelProfile.</p> <p>See the LevelProfile class docstring for details. A complete LevelProfile is represented as: Scale * (Level + Level_shift) * Profile + Intercept. Normally only Level and Profile are used.</p> <p>Either give level and profile, or value and unit.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Expr | TimeVector | str | None</code> <p>Level Expr. Defaults to None.</p> <code>None</code> <code>profile</code> <code>Expr | TimeVector | str | None</code> <p>Profile Expr. Defaults to None.</p> <code>None</code> <code>value</code> <code>float | int | None</code> <p>A constant value to initialize Level. Defaults to None.</p> <code>None</code> <code>unit</code> <code>str | None</code> <p>Unit of the constant value to initialize Level. Defaults to None.</p> <code>None</code> <code>level_shift</code> <code>Expr | None</code> <p>Level_shift Expr. Defaults to None.</p> <code>None</code> <code>intercept</code> <code>Expr | None</code> <p>Intercept Expr. Defaults to None.</p> <code>None</code> <code>scale</code> <code>Expr | None</code> <p>Scale Expr. Defaults to None.</p> <code>None</code> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def __init__(\n    self,\n    level: Expr | TimeVector | str | None = None,\n    profile: Expr | TimeVector | str | None = None,\n    value: float | int | None = None,  # To support Price(value=20, unit=\"EUR/MWh\")\n    unit: str | None = None,\n    level_shift: Expr | None = None,\n    intercept: Expr | None = None,\n    scale: Expr | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize LevelProfile.\n\n    See the LevelProfile class docstring for details. A complete LevelProfile is represented as:\n    Scale * (Level + Level_shift) * Profile + Intercept. Normally only Level and Profile are used.\n\n    Either give level and profile, or value and unit.\n\n    Args:\n        level (Expr | TimeVector | str | None, optional): Level Expr. Defaults to None.\n        profile (Expr | TimeVector | str | None, optional): Profile Expr. Defaults to None.\n        value (float | int | None, optional): A constant value to initialize Level. Defaults to None.\n        unit (str | None, optional): Unit of the constant value to initialize Level. Defaults to None.\n        level_shift (Expr | None, optional): Level_shift Expr. Defaults to None.\n        intercept (Expr | None, optional): Intercept Expr. Defaults to None.\n        scale (Expr | None, optional): Scale Expr. Defaults to None.\n\n    \"\"\"\n    self._assert_invariants()\n\n    self._check_type(value, (float, int, type(None)))\n    self._check_type(unit, (str, type(None)))\n    self._check_type(level, (Expr, TimeVector, str, type(None)))\n    self._check_type(profile, (Expr, TimeVector, str, type(None)))\n    self._check_type(level_shift, (Expr, type(None)))\n    self._check_type(intercept, (Expr, type(None)))\n    self._check_type(scale, (Expr, type(None)))\n    level = self._ensure_level_expr(level, value, unit)\n    profile = self._ensure_profile_expr(profile)\n    self._ensure_compatible_level_profile_combo(level, profile)\n    self._ensure_compatible_level_profile_combo(level_shift, profile)\n    self._level: Expr | None = level\n    self._profile: Expr | None = profile\n    self._level_shift: Expr | None = level_shift\n    self._intercept: Expr | None = intercept\n    self._scale: Expr | None = scale\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in expressions to loaders.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in expressions to loaders.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self.get_level())\n    add_loaders_if(loaders, self.get_profile())\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Set all internal fields to None.</p> <p>You may want to use this to get exogenous flow to use capacities instead of volume.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Set all internal fields to None.\n\n    You may want to use this to get exogenous flow to use capacities instead of volume.\n    \"\"\"\n    self._level = None\n    self._profile = None\n    self._level_shift = None\n    self._intercept = None\n    self._scale = None\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.copy_from","title":"<code>copy_from(other: LevelProfile) -&gt; None</code>","text":"<p>Copy fields from other.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def copy_from(self, other: LevelProfile) -&gt; None:\n    \"\"\"Copy fields from other.\"\"\"\n    self._check_type(other, LevelProfile)\n    self._assert_same_behaviour(other)\n    self._level = other._level\n    self._profile = other._profile\n    self._level_shift = other._level_shift\n    self._intercept = other._intercept\n    self._scale = other._scale\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.get_data_value","title":"<code>get_data_value(db: QueryDB | Model, scenario_horizon: FixedFrequencyTimeIndex, level_period: SinglePeriodTimeIndex, unit: str | None, is_max_level: bool | None = None) -&gt; float</code>","text":"<p>Evaluate LevelProfile to a scalar at the level period of the data dimension, and as an average over the scenario horizon.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>QueryDB | Model</code> <p>The database or model instance used to fetch the required data.</p> required <code>scenario_horizon</code> <code>FixedFrequencyTimeIndex</code> <p>TimeIndex of the scenario dimension to evaluate profiles.</p> required <code>level_period</code> <code>SinglePeriodTimeIndex</code> <p>TimeIndex of the data dimension to evaluate levels.</p> required <code>unit</code> <code>str | None</code> <p>The unit to convert the resulting values into (e.g., MW, GWh). If None, the expression should be unitless.</p> required <code>is_max_level</code> <code>bool | None</code> <p>Whether to evaluate the expression as a maximum level (with a zero_one profile) or as an average level (with a mean_one profile). If None, the default format of the attribute is used.</p> <code>None</code> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_data_value(\n    self,\n    db: QueryDB | Model,\n    scenario_horizon: FixedFrequencyTimeIndex,\n    level_period: SinglePeriodTimeIndex,\n    unit: str | None,\n    is_max_level: bool | None = None,\n) -&gt; float:\n    \"\"\"\n    Evaluate LevelProfile to a scalar at the level period of the data dimension, and as an average over the scenario horizon.\n\n    Args:\n        db (QueryDB | Model): The database or model instance used to fetch the required data.\n        scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n        level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n        unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n            the expression should be unitless.\n        is_max_level (bool | None, optional): Whether to evaluate the expression as a maximum level (with a zero_one profile)\n            or as an average level (with a mean_one profile). If None, the default format of the attribute is used.\n\n    \"\"\"\n    return self._get_data_value(db, scenario_horizon, level_period, unit, is_max_level)\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.get_intercept","title":"<code>get_intercept() -&gt; Expr | None</code>","text":"<p>Get intercept part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_intercept(self) -&gt; Expr | None:\n    \"\"\"Get intercept part of (level * profile + intercept).\"\"\"\n    intercept = self._intercept\n    if self._scale is not None:\n        intercept *= self._scale\n    return intercept\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.get_level","title":"<code>get_level() -&gt; Expr | None</code>","text":"<p>Get level part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_level(self) -&gt; Expr | None:\n    \"\"\"Get level part of (level * profile + intercept).\"\"\"\n    level = self._level\n\n    if level is None:\n        return None\n\n    if level.is_leaf():\n        level = Expr(\n            src=level.get_src(),\n            operations=level.get_operations(expect_ops=False, copy_list=True),\n            is_stock=level.is_stock(),\n            is_flow=level.is_flow(),\n            is_level=True,\n            is_profile=False,\n            profile=self._profile,\n        )\n\n    if self._level_shift is not None:\n        level += self._level_shift\n\n    if self._scale is not None:\n        level *= self._scale\n\n    return level\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.get_level_unit_set","title":"<code>get_level_unit_set(db: QueryDB | Model) -&gt; set[TimeIndex]</code>","text":"<p>Return set with all units behind level expression.</p> <p>Useful for discovering valid unit input to get_level_value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_level_unit_set(\n    self,\n    db: QueryDB | Model,\n) -&gt; set[TimeIndex]:\n    \"\"\"\n    Return set with all units behind level expression.\n\n    Useful for discovering valid unit input to get_level_value.\n    \"\"\"\n    if not self.has_level():\n        return set()\n    return get_units_from_expr(db, self.get_level())\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.get_profile","title":"<code>get_profile() -&gt; Expr | None</code>","text":"<p>Get profile part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_profile(self) -&gt; Expr | None:\n    \"\"\"Get profile part of (level * profile + intercept).\"\"\"\n    return self._profile\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.get_profile_timeindex_set","title":"<code>get_profile_timeindex_set(db: QueryDB | Model) -&gt; set[TimeIndex]</code>","text":"<p>Return set with all TimeIndex behind profile expression.</p> <p>Can be used to run optimized queries, i.e. not asking for finer time resolutions than necessary.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_profile_timeindex_set(\n    self,\n    db: QueryDB | Model,\n) -&gt; set[TimeIndex]:\n    \"\"\"\n    Return set with all TimeIndex behind profile expression.\n\n    Can be used to run optimized queries, i.e. not asking for\n    finer time resolutions than necessary.\n    \"\"\"\n    if not self.has_profile():\n        return set()\n    return get_timeindexes_from_expr(db, self.get_profile())\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.get_scenario_vector","title":"<code>get_scenario_vector(db: QueryDB | Model, scenario_horizon: FixedFrequencyTimeIndex, level_period: SinglePeriodTimeIndex, unit: str | None, is_float32: bool = True) -&gt; NDArray</code>","text":"<p>Evaluate LevelProfile over the periods in scenario dimension, and at the level period of the data dimension.</p> <p>Underlying profiles are evalutated over the scenario dimension, and levels are evalutated to scalars over level_period in the data dimension.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>QueryDB | Model</code> <p>The database or model instance used to fetch the required data.</p> required <code>scenario_horizon</code> <code>FixedFrequencyTimeIndex</code> <p>TimeIndex of the scenario dimension to evaluate profiles.</p> required <code>level_period</code> <code>SinglePeriodTimeIndex</code> <p>TimeIndex of the data dimension to evaluate levels.</p> required <code>unit</code> <code>str | None</code> <p>The unit to convert the resulting values into (e.g., MW, GWh). If None, the expression should be unitless.</p> required <code>is_float32</code> <code>bool</code> <p>Whether to return the vector as a NumPy array with <code>float32</code> precision. Defaults to True.</p> <code>True</code> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def get_scenario_vector(\n    self,\n    db: QueryDB | Model,\n    scenario_horizon: FixedFrequencyTimeIndex,\n    level_period: SinglePeriodTimeIndex,\n    unit: str | None,\n    is_float32: bool = True,\n) -&gt; NDArray:\n    \"\"\"\n    Evaluate LevelProfile over the periods in scenario dimension, and at the level period of the data dimension.\n\n    Underlying profiles are evalutated over the scenario dimension,\n    and levels are evalutated to scalars over level_period in the data dimension.\n\n    Args:\n        db (QueryDB | Model): The database or model instance used to fetch the required data.\n        scenario_horizon (FixedFrequencyTimeIndex): TimeIndex of the scenario dimension to evaluate profiles.\n        level_period (SinglePeriodTimeIndex): TimeIndex of the data dimension to evaluate levels.\n        unit (str | None): The unit to convert the resulting values into (e.g., MW, GWh). If None,\n            the expression should be unitless.\n        is_float32 (bool, optional): Whether to return the vector as a NumPy array with `float32`\n            precision. Defaults to True.\n\n    \"\"\"\n    return self._get_scenario_vector(db, scenario_horizon, level_period, unit, is_float32)\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.has_intercept","title":"<code>has_intercept() -&gt; bool</code>","text":"<p>Return True if get_intercept will return value not None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def has_intercept(self) -&gt; bool:\n    \"\"\"Return True if get_intercept will return value not None.\"\"\"\n    return self._intercept is not None\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.has_level","title":"<code>has_level() -&gt; bool</code>","text":"<p>Return True if get_level will return value not None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def has_level(self) -&gt; bool:\n    \"\"\"Return True if get_level will return value not None.\"\"\"\n    return (self._level is not None) or (self._level_shift is not None)\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.has_profile","title":"<code>has_profile() -&gt; bool</code>","text":"<p>Return True if get_profile will return value not None.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def has_profile(self) -&gt; bool:\n    \"\"\"Return True if get_profile will return value not None.\"\"\"\n    return self._profile is not None\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.is_cost","title":"<code>is_cost() -&gt; bool | None</code>","text":"<p>Return True if attribute is objective function cost coefficient.</p> <p>Return False if attribute is objective function revenue coefficient.</p> <p>Return None if not applicable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_cost(self) -&gt; bool | None:\n    \"\"\"\n    Return True if attribute is objective function cost coefficient.\n\n    Return False if attribute is objective function revenue coefficient.\n\n    Return None if not applicable.\n    \"\"\"\n    return self._IS_COST\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.is_flow","title":"<code>is_flow() -&gt; bool</code>","text":"<p>Return True if attribute is a flow variable.</p> <p>Return False if attribute is not a flow variable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_flow(self) -&gt; bool:\n    \"\"\"\n    Return True if attribute is a flow variable.\n\n    Return False if attribute is not a flow variable.\n    \"\"\"\n    return self._IS_FLOW\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.is_ingoing","title":"<code>is_ingoing() -&gt; bool | None</code>","text":"<p>Return True if attribute is ingoing.</p> <p>Return True if attribute is outgoing.</p> <p>Return None if not applicable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_ingoing(self) -&gt; bool | None:\n    \"\"\"\n    Return True if attribute is ingoing.\n\n    Return True if attribute is outgoing.\n\n    Return None if not applicable.\n    \"\"\"\n    return self._IS_INGOING\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.is_max_and_zero_one","title":"<code>is_max_and_zero_one() -&gt; bool</code>","text":"<p>When True level should be max (not average) and corresponding profile should be zero_one (not mean_one).</p> <p>When False level should be average (not max) and corresponding profile should be mean_one (not zero_one).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_max_and_zero_one(self) -&gt; bool:\n    \"\"\"\n    When True level should be max (not average) and corresponding profile should be zero_one (not mean_one).\n\n    When False level should be average (not max) and corresponding profile should be mean_one (not zero_one).\n    \"\"\"\n    return self._IS_MAX_AND_ZERO_ONE\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.is_not_negative","title":"<code>is_not_negative() -&gt; bool</code>","text":"<p>Return True if attribute is not allowed to have negative values.</p> <p>Return False if attribute can have both positive and negative values.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_not_negative(self) -&gt; bool:\n    \"\"\"\n    Return True if attribute is not allowed to have negative values.\n\n    Return False if attribute can have both positive and negative values.\n    \"\"\"\n    return self._IS_NOT_NEGATIVE\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.is_stock","title":"<code>is_stock() -&gt; bool</code>","text":"<p>Return True if attribute is a stock variable.</p> <p>Return False if attribute is not a stock variable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_stock(self) -&gt; bool:\n    \"\"\"\n    Return True if attribute is a stock variable.\n\n    Return False if attribute is not a stock variable.\n    \"\"\"\n    return self._IS_STOCK\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.is_unitless","title":"<code>is_unitless() -&gt; bool | None</code>","text":"<p>Return True if attribute is known to be unitless.</p> <p>Return False if attribute is known to have a unit that is not None.</p> <p>Return None if not applicable.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def is_unitless(self) -&gt; bool | None:\n    \"\"\"\n    Return True if attribute is known to be unitless.\n\n    Return False if attribute is known to have a unit that is not None.\n\n    Return None if not applicable.\n    \"\"\"\n    return self._IS_UNITLESS\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.scale","title":"<code>scale(value: float | int) -&gt; None</code>","text":"<p>Modify the scale part of (scale * (level + level_shift) * profile + intercept) of an attribute by multiplying with a constant value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def scale(self, value: float | int) -&gt; None:\n    \"\"\"Modify the scale part of (scale * (level + level_shift) * profile + intercept) of an attribute by multiplying with a constant value.\"\"\"\n    # TODO: Not allowed to scale if there is intercept?\n    expr = ensure_expr(\n        ConstantTimeVector(self._ensure_float(value), unit=None, is_max_level=False),\n        is_level=True,\n        is_profile=False,\n        profile=None,\n    )\n    if self._scale is None:\n        self._scale = expr\n    else:\n        self._scale *= expr\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.set_intercept","title":"<code>set_intercept(value: Expr | None) -&gt; None</code>","text":"<p>Set intercept part of (level * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def set_intercept(self, value: Expr | None) -&gt; None:\n    \"\"\"Set intercept part of (level * profile + intercept).\"\"\"\n    self._check_type(value, (Expr, type(None)))\n    if value is not None:\n        self._check_level_expr(value)\n    self._intercept = value\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.set_level","title":"<code>set_level(level: Expr | TimeVector | str | None) -&gt; None</code>","text":"<p>Set level part of (scale * (level + level_shift) * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def set_level(self, level: Expr | TimeVector | str | None) -&gt; None:\n    \"\"\"Set level part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n    self._check_type(level, (Expr, TimeVector, str, type(None)))\n    level = self._ensure_level_expr(level)\n    self._ensure_compatible_level_profile_combo(level, self._profile)\n    self._level = level\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.set_profile","title":"<code>set_profile(profile: Expr | TimeVector | str | None) -&gt; None</code>","text":"<p>Set profile part of (scale * (level + level_shift) * profile + intercept).</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def set_profile(self, profile: Expr | TimeVector | str | None) -&gt; None:\n    \"\"\"Set profile part of (scale * (level + level_shift) * profile + intercept).\"\"\"\n    self._check_type(profile, (Expr, TimeVector, str, type(None)))\n    profile = self._ensure_profile_expr(profile)\n    self._ensure_compatible_level_profile_combo(self._level, profile)\n    self._profile = profile\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.shift_intercept","title":"<code>shift_intercept(value: float, unit: str | None) -&gt; None</code>","text":"<p>Modify the intercept part of (level * profile + intercept) of an attribute by adding a constant value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def shift_intercept(self, value: float, unit: str | None) -&gt; None:\n    \"\"\"Modify the intercept part of (level * profile + intercept) of an attribute by adding a constant value.\"\"\"\n    expr = ensure_expr(\n        ConstantTimeVector(self._ensure_float(value), unit=unit, is_max_level=False),\n        is_level=True,\n        is_profile=False,\n        is_stock=self._IS_STOCK,\n        is_flow=self._IS_FLOW,\n        profile=None,\n    )\n    if self._intercept is None:\n        self._intercept = expr\n    else:\n        self._intercept += expr\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.LevelProfile.shift_level","title":"<code>shift_level(value: float | int, unit: str | None = None, reference_period: ReferencePeriod | None = None, is_max_level: bool | None = None, use_profile: bool = True) -&gt; None</code>","text":"<p>Modify the level_shift part of (scale * (level + level_shift) * profile + intercept) of an attribute by adding a constant value.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>def shift_level(\n    self,\n    value: float | int,\n    unit: str | None = None,\n    reference_period: ReferencePeriod | None = None,\n    is_max_level: bool | None = None,\n    use_profile: bool = True,  # TODO: Remove. Should always use profile. If has profile validate that it is equal to the profile of Level.\n) -&gt; None:\n    \"\"\"Modify the level_shift part of (scale * (level + level_shift) * profile + intercept) of an attribute by adding a constant value.\"\"\"\n    # TODO: Not allowed to shift if there is intercept?\n    self._check_type(value, (float, int))\n    self._check_type(unit, (str, type(None)))\n    self._check_type(reference_period, (ReferencePeriod, type(None)))\n    self._check_type(is_max_level, (bool, type(None)))\n    self._check_type(use_profile, bool)\n\n    if is_max_level is None:\n        is_max_level = self._IS_MAX_AND_ZERO_ONE\n\n    expr = ensure_expr(\n        ConstantTimeVector(\n            self._ensure_float(value),\n            unit=unit,\n            is_max_level=is_max_level,\n            reference_period=reference_period,\n        ),\n        is_level=True,\n        is_profile=False,\n        is_stock=self._IS_STOCK,\n        is_flow=self._IS_FLOW,\n        profile=self._profile if use_profile else None,\n    )\n    if self._level_shift is None:\n        self._level_shift = expr\n    else:\n        self._level_shift += expr\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Loss","title":"<code>Loss</code>","text":"<p>               Bases: <code>ArrowCoefficient</code></p> <p>Concrete class representing a loss coefficient attribute, indicating a unitless coefficient.</p> <p>Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Loss(ArrowCoefficient):  # TODO: Make a loss for storage that is percentage per time\n    \"\"\"\n    Concrete class representing a loss coefficient attribute, indicating a unitless coefficient.\n\n    Subclass of ArrowCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.MaxFlowVolume","title":"<code>MaxFlowVolume</code>","text":"<p>               Bases: <code>FlowVolume</code></p> <p>Concrete class representing a maximum flow volume attribute, indicating a flow variable with maximum values.</p> <p>Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class MaxFlowVolume(FlowVolume):\n    \"\"\"\n    Concrete class representing a maximum flow volume attribute, indicating a flow variable with maximum values.\n\n    Subclass of FlowVolume &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_MAX_AND_ZERO_ONE = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.ObjectiveCoefficient","title":"<code>ObjectiveCoefficient</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Abstract class representing an objective coefficient attribute, indicating cost or revenue coefficients in the objective function.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class ObjectiveCoefficient(Coefficient):\n    \"\"\"\n    Abstract class representing an objective coefficient attribute, indicating cost or revenue coefficients in the objective function.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_UNITLESS = False\n    _IS_NOT_NEGATIVE = False\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Price","title":"<code>Price</code>","text":"<p>               Bases: <code>ShadowPrice</code></p> <p>Concrete class representing a price attribute, indicating the price of a commodity at a specific node.</p> <p>Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Price(ShadowPrice):\n    \"\"\"\n    Concrete class representing a price attribute, indicating the price of a commodity at a specific node.\n\n    Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.Proportion","title":"<code>Proportion</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Concrete class representing a proportion coefficient attribute, indicating a unitless coefficient between 0 and 1.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class Proportion(Coefficient):\n    \"\"\"\n    Concrete class representing a proportion coefficient attribute, indicating a unitless coefficient between 0 and 1.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_UNITLESS = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.ReservePrice","title":"<code>ReservePrice</code>","text":"<p>               Bases: <code>ObjectiveCoefficient</code></p> <p>Concrete class representing a reserve price attribute, indicating revenue coefficients in the objective function.</p> <p>Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class ReservePrice(ObjectiveCoefficient):\n    \"\"\"\n    Concrete class representing a reserve price attribute, indicating revenue coefficients in the objective function.\n\n    Subclass of ObjectiveCoefficient &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_COST = False\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.ShadowPrice","title":"<code>ShadowPrice</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Abstract class representing a shadow price attribute, indicating that the attribute has a unit and might be negative.</p> <p>Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class ShadowPrice(Coefficient):\n    \"\"\"\n    Abstract class representing a shadow price attribute, indicating that the attribute has a unit and might be negative.\n\n    Subclass of Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_UNITLESS = False\n    _IS_NOT_NEGATIVE = False\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.StockVolume","title":"<code>StockVolume</code>","text":"<p>               Bases: <code>LevelProfile</code></p> <p>Concrete class representing a stock volume attribute, indicating a stock variable with maximum values.</p> <p>Subclass of LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class StockVolume(LevelProfile):\n    \"\"\"\n    Concrete class representing a stock volume attribute, indicating a stock variable with maximum values.\n\n    Subclass of LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n    _IS_STOCK = True\n    _IS_MAX_AND_ZERO_ONE = True\n</code></pre>"},{"location":"reference/#framcore.attributes.level_profile_attributes.WaterValue","title":"<code>WaterValue</code>","text":"<p>               Bases: <code>ShadowPrice</code></p> <p>Concrete class representing a water value attribute, indicating the value of water in the system.</p> <p>Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.</p> Source code in <code>framcore/attributes/level_profile_attributes.py</code> <pre><code>class WaterValue(ShadowPrice):\n    \"\"\"\n    Concrete class representing a water value attribute, indicating the value of water in the system.\n\n    Subclass of ShadowPrice &lt; Coefficient &lt; LevelProfile. See LevelProfile for details.\n    \"\"\"\n\n    _IS_ABSTRACT = False\n</code></pre>"},{"location":"reference/#framcore.components","title":"<code>components</code>","text":""},{"location":"reference/#framcore.components.Solar","title":"<code>Solar</code>","text":"<p>               Bases: <code>_WindSolar</code></p> <p>Solar power component.</p> <p>Has attributes for power node, capacity, variable operation cost, and production.</p> <p>Compatible with WindSolarAggregator.</p> Source code in <code>framcore/components/wind_solar.py</code> <pre><code>class Solar(_WindSolar):\n    \"\"\"\n    Solar power component.\n\n    Has attributes for power node, capacity, variable operation cost, and production.\n\n    Compatible with WindSolarAggregator.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#framcore.components.Wind","title":"<code>Wind</code>","text":"<p>               Bases: <code>_WindSolar</code></p> <p>Wind power component.</p> <p>Has attributes for power node, capacity, variable operation cost, and production.</p> <p>Compatible with WindSolarAggregator.</p> Source code in <code>framcore/components/wind_solar.py</code> <pre><code>class Wind(_WindSolar):\n    \"\"\"\n    Wind power component.\n\n    Has attributes for power node, capacity, variable operation cost, and production.\n\n    Compatible with WindSolarAggregator.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#framcore.components.Component","title":"<code>Component</code>","text":""},{"location":"reference/#framcore.components.Component.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Components describe the main elements in the energy system. Can have additional Attributes and Metadata.</p> <p>We have high-level and low-level Components. High-level Components, such as a HydroModule, can be decomposed into low-level Components like Flows and Nodes. The high-level description lets analysts work with recognizable domain objects, while the low-level descriptions enable generic algorithms that minimize code duplication and simplify data manipulation.</p> <p>Some energy market models like JulES, SpineOpt and PyPSA also have a generic description of the system, so this two-tier system can be used to easier adapt the dataset to their required formats.</p> <p>The method Component.get_simpler_components() is used to decompose high-level Components into low-level Components. This can also be used together with the utility function get_supported_components() to transform a set of Components into a set that only contains supported Component types.</p> <p>Result attributes are initialized in the high-level Components. When they are transferred to low-level Components, and the results are set by a model like JulES, the results will also appear in the high-level Components.</p> <p>Nodes, Flows and Arrows are the main building blocks in FRAM's low-level representation of energy systems. Node represent a point where a commodity can possibly be traded, stored or pass through. Movement between Nodes is represented by Flows and Arrows. Flows represent a commodity flow, and can have Arrows that each describe contribution of the Flow into a Node. The Arrows have direction to determine input or output, and parameters for the contribution of the Flow to the Node (conversion, efficiency and loss).</p> Source code in <code>framcore/components/Component.py</code> <pre><code>class Component(Base, ABC):\n    \"\"\"\n    Components describe the main elements in the energy system. Can have additional Attributes and Metadata.\n\n    We have high-level and low-level Components. High-level Components, such as a HydroModule,\n    can be decomposed into low-level Components like Flows and Nodes. The high-level description lets\n    analysts work with recognizable domain objects, while the low-level descriptions enable generic algorithms\n    that minimize code duplication and simplify data manipulation.\n\n    Some energy market models like JulES, SpineOpt and PyPSA also have a generic description of the system,\n    so this two-tier system can be used to easier adapt the dataset to their required formats.\n\n    The method Component.get_simpler_components() is used to decompose high-level Components into low-level\n    Components. This can also be used together with the utility function get_supported_components() to transform\n    a set of Components into a set that only contains supported Component types.\n\n    Result attributes are initialized in the high-level Components. When they are transferred to low-level Components,\n    and the results are set by a model like JulES, the results will also appear in the high-level Components.\n\n    Nodes, Flows and Arrows are the main building blocks in FRAM's low-level representation of energy systems.\n    Node represent a point where a commodity can possibly be traded, stored or pass through.\n    Movement between Nodes is represented by Flows and Arrows. Flows represent a commodity flow,\n    and can have Arrows that each describe contribution of the Flow into a Node.\n    The Arrows have direction to determine input or output, and parameters for the contribution of the\n    Flow to the Node (conversion, efficiency and loss).\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Set mandatory private variables.\"\"\"\n        self._parent: Component | None = None\n        self._meta: dict[str, Meta] = dict()\n\n    def add_meta(self, key: str, value: Meta) -&gt; None:\n        \"\"\"Add metadata to component. Overwrite if already exist.\"\"\"\n        self._check_type(key, str)\n        self._check_type(value, Meta)\n        self._meta[key] = value\n\n    def get_meta(self, key: str) -&gt; Meta | None:\n        \"\"\"Get metadata from component or return None if not exist.\"\"\"\n        self._check_type(key, str)\n        return self._meta.get(key, None)\n\n    def get_meta_keys(self) -&gt; Iterable[str]:\n        \"\"\"Get iterable with all metakeys in component.\"\"\"\n        return self._meta.keys()\n\n    def get_simpler_components(\n        self,\n        base_name: str,\n    ) -&gt; dict[str, Component]:\n        \"\"\"\n        Return representation of self as dict of named simpler components.\n\n        The base_name should be unique within a model instance, and should\n        be used to prefix name of all simpler components.\n\n        Insert self as parent in each child.\n\n        Transfer metadata to each child.\n        \"\"\"\n        self._check_type(base_name, str)\n        components = self._get_simpler_components(base_name)\n        assert base_name not in components, f\"base_name: {base_name} should not be in \\ncomponent: {self}\"\n        components: dict[str, Component]\n        self._check_type(components, dict)\n        for name, c in components.items():\n            self._check_type(name, str)\n            self._check_type(c, Component)\n            self._check_component_not_self(c)\n            c: Component\n            c._parent = self  # noqa: SLF001\n        for key in self.get_meta_keys():\n            value = self.get_meta(key)\n            for c in components.values():\n                c.add_meta(key, value)\n        return components\n\n    def get_parent(self) -&gt; Component | None:\n        \"\"\"Return parent if any, else None.\"\"\"\n        self._check_type(self._parent, (Component, type(None)))\n        self._check_component_not_self(self._parent)\n        return self._parent\n\n    def get_parents(self) -&gt; list[Component]:\n        \"\"\"Return list of all parents, including self.\"\"\"\n        child = self\n        parent = child.get_parent()\n        parents = [child]\n        while parent is not None:\n            child = parent\n            parent = child.get_parent()\n            parents.append(child)\n        self._check_unique_parents(parents)\n        return parents\n\n    def get_top_parent(self) -&gt; Component:\n        \"\"\"Return topmost parent. (May be object self).\"\"\"\n        parents = self.get_parents()\n        return parents[-1]\n\n    def replace_node(self, old: str, new: str) -&gt; None:\n        \"\"\"Replace old Node with new. Not error if no match.\"\"\"\n        self._check_type(old, str)\n        self._check_type(new, str)\n        self._replace_node(old, new)\n\n    def _check_component_not_self(self, other: Component | None) -&gt; None:\n        if not isinstance(other, Component):\n            return\n        if self != other:\n            return\n        message = f\"Expected other component than {self}.\"\n        raise TypeError(message)\n\n    def _check_unique_parents(self, parents: list[Component]) -&gt; None:\n        if len(parents) &gt; len(set(parents)):\n            message = f\"Parents for {self} are not unique.\"\n            raise TypeError(message)\n\n    @abstractmethod\n    def _replace_node(self, old: str, new: str) -&gt; None:\n        pass\n\n    @abstractmethod\n    def _get_simpler_components(self, base_name: str) -&gt; dict[str, Component]:\n        pass\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Set mandatory private variables.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Set mandatory private variables.\"\"\"\n    self._parent: Component | None = None\n    self._meta: dict[str, Meta] = dict()\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.add_meta","title":"<code>add_meta(key: str, value: Meta) -&gt; None</code>","text":"<p>Add metadata to component. Overwrite if already exist.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def add_meta(self, key: str, value: Meta) -&gt; None:\n    \"\"\"Add metadata to component. Overwrite if already exist.\"\"\"\n    self._check_type(key, str)\n    self._check_type(value, Meta)\n    self._meta[key] = value\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.get_meta","title":"<code>get_meta(key: str) -&gt; Meta | None</code>","text":"<p>Get metadata from component or return None if not exist.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def get_meta(self, key: str) -&gt; Meta | None:\n    \"\"\"Get metadata from component or return None if not exist.\"\"\"\n    self._check_type(key, str)\n    return self._meta.get(key, None)\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.get_meta_keys","title":"<code>get_meta_keys() -&gt; Iterable[str]</code>","text":"<p>Get iterable with all metakeys in component.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def get_meta_keys(self) -&gt; Iterable[str]:\n    \"\"\"Get iterable with all metakeys in component.\"\"\"\n    return self._meta.keys()\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.get_parent","title":"<code>get_parent() -&gt; Component | None</code>","text":"<p>Return parent if any, else None.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def get_parent(self) -&gt; Component | None:\n    \"\"\"Return parent if any, else None.\"\"\"\n    self._check_type(self._parent, (Component, type(None)))\n    self._check_component_not_self(self._parent)\n    return self._parent\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.get_parents","title":"<code>get_parents() -&gt; list[Component]</code>","text":"<p>Return list of all parents, including self.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def get_parents(self) -&gt; list[Component]:\n    \"\"\"Return list of all parents, including self.\"\"\"\n    child = self\n    parent = child.get_parent()\n    parents = [child]\n    while parent is not None:\n        child = parent\n        parent = child.get_parent()\n        parents.append(child)\n    self._check_unique_parents(parents)\n    return parents\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.get_simpler_components","title":"<code>get_simpler_components(base_name: str) -&gt; dict[str, Component]</code>","text":"<p>Return representation of self as dict of named simpler components.</p> <p>The base_name should be unique within a model instance, and should be used to prefix name of all simpler components.</p> <p>Insert self as parent in each child.</p> <p>Transfer metadata to each child.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def get_simpler_components(\n    self,\n    base_name: str,\n) -&gt; dict[str, Component]:\n    \"\"\"\n    Return representation of self as dict of named simpler components.\n\n    The base_name should be unique within a model instance, and should\n    be used to prefix name of all simpler components.\n\n    Insert self as parent in each child.\n\n    Transfer metadata to each child.\n    \"\"\"\n    self._check_type(base_name, str)\n    components = self._get_simpler_components(base_name)\n    assert base_name not in components, f\"base_name: {base_name} should not be in \\ncomponent: {self}\"\n    components: dict[str, Component]\n    self._check_type(components, dict)\n    for name, c in components.items():\n        self._check_type(name, str)\n        self._check_type(c, Component)\n        self._check_component_not_self(c)\n        c: Component\n        c._parent = self  # noqa: SLF001\n    for key in self.get_meta_keys():\n        value = self.get_meta(key)\n        for c in components.values():\n            c.add_meta(key, value)\n    return components\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.get_top_parent","title":"<code>get_top_parent() -&gt; Component</code>","text":"<p>Return topmost parent. (May be object self).</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def get_top_parent(self) -&gt; Component:\n    \"\"\"Return topmost parent. (May be object self).\"\"\"\n    parents = self.get_parents()\n    return parents[-1]\n</code></pre>"},{"location":"reference/#framcore.components.Component.Component.replace_node","title":"<code>replace_node(old: str, new: str) -&gt; None</code>","text":"<p>Replace old Node with new. Not error if no match.</p> Source code in <code>framcore/components/Component.py</code> <pre><code>def replace_node(self, old: str, new: str) -&gt; None:\n    \"\"\"Replace old Node with new. Not error if no match.\"\"\"\n    self._check_type(old, str)\n    self._check_type(new, str)\n    self._replace_node(old, new)\n</code></pre>"},{"location":"reference/#framcore.components.Demand","title":"<code>Demand</code>","text":"<p>Demand class.</p>"},{"location":"reference/#framcore.components.Demand.Demand","title":"<code>Demand</code>","text":"<p>               Bases: <code>Component</code></p> <p>Demand class representing a simple demand with possible reserve price. Subclass of Component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>class Demand(Component):\n    \"\"\"Demand class representing a simple demand with possible reserve price. Subclass of Component.\"\"\"\n\n    def __init__(\n        self,\n        node: str,\n        capacity: FlowVolume | None = None,\n        reserve_price: ReservePrice | None = None,\n        elastic_demand: ElasticDemand | None = None,\n        temperature_profile: Expr | str | TimeVector | None = None,\n        consumption: AvgFlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Demand class.\n\n        Args:\n            node (str): Node which this Demand consumes power on.\n            capacity (FlowVolume | None, optional): Maximum consumption capacity. Defaults to None.\n            reserve_price (ReservePrice | None, optional): Price in node at which the Demand will stop consumption. Defaults to None.\n            elastic_demand (ElasticDemand | None, optional): Describe changes in consumption based on commodity price in node. Defaults to None.\n            temperature_profile (Expr | str | TimeVector | None, optional): Describe changes in consumption based on temperatures. Defaults to None.\n            consumption (AvgFlowVolume | None, optional): Actual calculated consumption. Defaults to None.\n\n        Raises:\n            ValueError: When both reserve_price and elastic_demand is passed as arguments. This is ambiguous.\n\n        \"\"\"\n        super().__init__()\n        self._check_type(node, str)\n        self._check_type(capacity, (FlowVolume, type(None)))\n        self._check_type(reserve_price, (ReservePrice, type(None)))\n        self._check_type(elastic_demand, (ElasticDemand, type(None)))\n        self._check_type(consumption, (AvgFlowVolume, type(None)))\n\n        if reserve_price is not None and elastic_demand is not None:\n            message = \"Cannot have 'reserve_price' and 'elastic_demand' at the same time.\"\n            raise ValueError(message)\n\n        self._node = node\n        self._capacity = capacity\n        self._reserve_price = reserve_price\n        self._elastic_demand = elastic_demand\n        self._temperature_profile = ensure_expr(temperature_profile, is_profile=True)\n\n        if consumption is None:\n            consumption = AvgFlowVolume()\n\n        self._consumption: AvgFlowVolume = consumption\n\n    def get_capacity(self) -&gt; FlowVolume:\n        \"\"\"Get the capacity of the demand component.\"\"\"\n        return self._capacity\n\n    def get_consumption(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the consumption of the demand component.\"\"\"\n        return self._consumption\n\n    def get_node(self) -&gt; str:\n        \"\"\"Get the node of the demand component.\"\"\"\n        return self._node\n\n    def set_node(self, node: str) -&gt; None:\n        \"\"\"Set the node of the demand component.\"\"\"\n        self._check_type(node, str)\n        self.node = node\n\n    def get_reserve_price(self) -&gt; ReservePrice | None:\n        \"\"\"Get the reserve price level of the demand component.\"\"\"\n        return self._reserve_price\n\n    def set_reserve_price(self, reserve_price: ReservePrice | None) -&gt; None:\n        \"\"\"Set the reserve price level of the demand component.\"\"\"\n        self._check_type(reserve_price, (ReservePrice, type(None)))\n        if self._elastic_demand and reserve_price:\n            message = \"Cannot set reserve_price when elastic_demand is not None.\"\n            raise ValueError(message)\n        self._reserve_price = reserve_price\n\n    def get_elastic_demand(self) -&gt; ElasticDemand | None:\n        \"\"\"Get the elastic demand of the demand component.\"\"\"\n        return self._elastic_demand\n\n    def set_elastic_demand(self, elastic_demand: ElasticDemand | None) -&gt; None:\n        \"\"\"Set the elastic demand of the demand component.\"\"\"\n        self._check_type(elastic_demand, (ElasticDemand, type(None)))\n        if self._reserve_price is not None and elastic_demand is not None:\n            message = \"Cannot set elastic_demand when reserve_price is not None.\"\n            raise ValueError(message)\n        self._elastic_demand = elastic_demand\n\n    def get_temperature_profile(self) -&gt; Expr | None:\n        \"\"\"Get the temperature profile of the demand component.\"\"\"\n        return self._temperature_profile\n\n    def set_temperature_profile(self, temperature_profile: Expr | str | None) -&gt; None:\n        \"\"\"Set the temperature profile of the demand component.\"\"\"\n        self._check_type(temperature_profile, (Expr, str, TimeVector, type(None)))\n        self._temperature_profile = ensure_expr(temperature_profile, is_profile=True)\n\n    \"\"\"Implementation of Component interface\"\"\"\n\n    def _replace_node(self, old: str, new: str) -&gt; None:\n        if old == self._node:\n            self._node = new\n        else:\n            message = f\"{old} not found in {self}. Expected existing node {self._node}.\"\n            raise ValueError(message)\n\n    def _get_simpler_components(self, base_name: str) -&gt; dict[str, Component]:\n        return {base_name + \"_Flow\": self._create_flow()}\n\n    def _create_flow(self) -&gt; Flow:\n        is_exogenous = self._elastic_demand is None and self._reserve_price is None\n\n        flow = Flow(\n            main_node=self._node,\n            max_capacity=self._capacity,\n            min_capacity=self._capacity if is_exogenous else None,\n            volume=self._consumption,\n            arrow_volumes=None,\n            is_exogenous=is_exogenous,\n        )\n\n        power_arrow = Arrow(self._node, False, conversion=Conversion(value=1))\n        flow.add_arrow(power_arrow)\n\n        if self._reserve_price is not None:\n            flow.add_cost_term(\"reserve_price\", self._reserve_price)\n\n        # TODO: Implement correctly when Curve is ready. For now, model as inelastic consumer w. reserve_price\n        elif self._elastic_demand is not None:\n            price = self._elastic_demand.get_max_price()\n            reserve_price = ReservePrice(level=price.get_level(), profile=price.get_profile())\n            flow.add_cost_term(\"reserve_price\", cost_term=reserve_price)\n\n        return flow\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.__init__","title":"<code>__init__(node: str, capacity: FlowVolume | None = None, reserve_price: ReservePrice | None = None, elastic_demand: ElasticDemand | None = None, temperature_profile: Expr | str | TimeVector | None = None, consumption: AvgFlowVolume | None = None) -&gt; None</code>","text":"<p>Initialize the Demand class.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Node which this Demand consumes power on.</p> required <code>capacity</code> <code>FlowVolume | None</code> <p>Maximum consumption capacity. Defaults to None.</p> <code>None</code> <code>reserve_price</code> <code>ReservePrice | None</code> <p>Price in node at which the Demand will stop consumption. Defaults to None.</p> <code>None</code> <code>elastic_demand</code> <code>ElasticDemand | None</code> <p>Describe changes in consumption based on commodity price in node. Defaults to None.</p> <code>None</code> <code>temperature_profile</code> <code>Expr | str | TimeVector | None</code> <p>Describe changes in consumption based on temperatures. Defaults to None.</p> <code>None</code> <code>consumption</code> <code>AvgFlowVolume | None</code> <p>Actual calculated consumption. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When both reserve_price and elastic_demand is passed as arguments. This is ambiguous.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def __init__(\n    self,\n    node: str,\n    capacity: FlowVolume | None = None,\n    reserve_price: ReservePrice | None = None,\n    elastic_demand: ElasticDemand | None = None,\n    temperature_profile: Expr | str | TimeVector | None = None,\n    consumption: AvgFlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Demand class.\n\n    Args:\n        node (str): Node which this Demand consumes power on.\n        capacity (FlowVolume | None, optional): Maximum consumption capacity. Defaults to None.\n        reserve_price (ReservePrice | None, optional): Price in node at which the Demand will stop consumption. Defaults to None.\n        elastic_demand (ElasticDemand | None, optional): Describe changes in consumption based on commodity price in node. Defaults to None.\n        temperature_profile (Expr | str | TimeVector | None, optional): Describe changes in consumption based on temperatures. Defaults to None.\n        consumption (AvgFlowVolume | None, optional): Actual calculated consumption. Defaults to None.\n\n    Raises:\n        ValueError: When both reserve_price and elastic_demand is passed as arguments. This is ambiguous.\n\n    \"\"\"\n    super().__init__()\n    self._check_type(node, str)\n    self._check_type(capacity, (FlowVolume, type(None)))\n    self._check_type(reserve_price, (ReservePrice, type(None)))\n    self._check_type(elastic_demand, (ElasticDemand, type(None)))\n    self._check_type(consumption, (AvgFlowVolume, type(None)))\n\n    if reserve_price is not None and elastic_demand is not None:\n        message = \"Cannot have 'reserve_price' and 'elastic_demand' at the same time.\"\n        raise ValueError(message)\n\n    self._node = node\n    self._capacity = capacity\n    self._reserve_price = reserve_price\n    self._elastic_demand = elastic_demand\n    self._temperature_profile = ensure_expr(temperature_profile, is_profile=True)\n\n    if consumption is None:\n        consumption = AvgFlowVolume()\n\n    self._consumption: AvgFlowVolume = consumption\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.get_capacity","title":"<code>get_capacity() -&gt; FlowVolume</code>","text":"<p>Get the capacity of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def get_capacity(self) -&gt; FlowVolume:\n    \"\"\"Get the capacity of the demand component.\"\"\"\n    return self._capacity\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.get_consumption","title":"<code>get_consumption() -&gt; AvgFlowVolume</code>","text":"<p>Get the consumption of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def get_consumption(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the consumption of the demand component.\"\"\"\n    return self._consumption\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.get_elastic_demand","title":"<code>get_elastic_demand() -&gt; ElasticDemand | None</code>","text":"<p>Get the elastic demand of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def get_elastic_demand(self) -&gt; ElasticDemand | None:\n    \"\"\"Get the elastic demand of the demand component.\"\"\"\n    return self._elastic_demand\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.get_node","title":"<code>get_node() -&gt; str</code>","text":"<p>Get the node of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def get_node(self) -&gt; str:\n    \"\"\"Get the node of the demand component.\"\"\"\n    return self._node\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.get_reserve_price","title":"<code>get_reserve_price() -&gt; ReservePrice | None</code>","text":"<p>Get the reserve price level of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def get_reserve_price(self) -&gt; ReservePrice | None:\n    \"\"\"Get the reserve price level of the demand component.\"\"\"\n    return self._reserve_price\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.get_temperature_profile","title":"<code>get_temperature_profile() -&gt; Expr | None</code>","text":"<p>Get the temperature profile of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def get_temperature_profile(self) -&gt; Expr | None:\n    \"\"\"Get the temperature profile of the demand component.\"\"\"\n    return self._temperature_profile\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.set_elastic_demand","title":"<code>set_elastic_demand(elastic_demand: ElasticDemand | None) -&gt; None</code>","text":"<p>Set the elastic demand of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def set_elastic_demand(self, elastic_demand: ElasticDemand | None) -&gt; None:\n    \"\"\"Set the elastic demand of the demand component.\"\"\"\n    self._check_type(elastic_demand, (ElasticDemand, type(None)))\n    if self._reserve_price is not None and elastic_demand is not None:\n        message = \"Cannot set elastic_demand when reserve_price is not None.\"\n        raise ValueError(message)\n    self._elastic_demand = elastic_demand\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.set_node","title":"<code>set_node(node: str) -&gt; None</code>","text":"<p>Set the node of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def set_node(self, node: str) -&gt; None:\n    \"\"\"Set the node of the demand component.\"\"\"\n    self._check_type(node, str)\n    self.node = node\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.set_reserve_price","title":"<code>set_reserve_price(reserve_price: ReservePrice | None) -&gt; None</code>","text":"<p>Set the reserve price level of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def set_reserve_price(self, reserve_price: ReservePrice | None) -&gt; None:\n    \"\"\"Set the reserve price level of the demand component.\"\"\"\n    self._check_type(reserve_price, (ReservePrice, type(None)))\n    if self._elastic_demand and reserve_price:\n        message = \"Cannot set reserve_price when elastic_demand is not None.\"\n        raise ValueError(message)\n    self._reserve_price = reserve_price\n</code></pre>"},{"location":"reference/#framcore.components.Demand.Demand.set_temperature_profile","title":"<code>set_temperature_profile(temperature_profile: Expr | str | None) -&gt; None</code>","text":"<p>Set the temperature profile of the demand component.</p> Source code in <code>framcore/components/Demand.py</code> <pre><code>def set_temperature_profile(self, temperature_profile: Expr | str | None) -&gt; None:\n    \"\"\"Set the temperature profile of the demand component.\"\"\"\n    self._check_type(temperature_profile, (Expr, str, TimeVector, type(None)))\n    self._temperature_profile = ensure_expr(temperature_profile, is_profile=True)\n</code></pre>"},{"location":"reference/#framcore.components.Flow","title":"<code>Flow</code>","text":""},{"location":"reference/#framcore.components.Flow.Flow","title":"<code>Flow</code>","text":"<p>               Bases: <code>Component</code></p> <p>Represents a commodity flow in or out of one or more nodes. Can have Attributes and Metadata.</p> <p>Main attributes are arrows, main_node, max_capacity, min_capacity, startupcost and if it is exogenous.</p> <p>Arrows describes contribution of a Flow into a Node. Has direction to determine input or output, and parameters for the contribution of the Flow to the Node (conversion, efficiency, loss). Nodes, Flows and Arrows are the main building blocks in FRAM's low-level representation of energy systems.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>class Flow(Component):\n    \"\"\"\n    Represents a commodity flow in or out of one or more nodes. Can have Attributes and Metadata.\n\n    Main attributes are arrows, main_node, max_capacity, min_capacity, startupcost and if it is exogenous.\n\n    Arrows describes contribution of a Flow into a Node. Has direction to determine input or output,\n    and parameters for the contribution of the Flow to the Node (conversion, efficiency, loss).\n    Nodes, Flows and Arrows are the main building blocks in FRAM's low-level representation of energy systems.\n    \"\"\"\n\n    def __init__(\n        self,\n        main_node: str,\n        max_capacity: FlowVolume | None = None,\n        min_capacity: FlowVolume | None = None,\n        startupcost: StartUpCost | None = None,\n        volume: AvgFlowVolume | None = None,\n        arrow_volumes: dict[Arrow, AvgFlowVolume] | None = None,\n        is_exogenous: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initialize Flow with main node, capacity, and startup cost.\n\n        Args:\n            main_node (str): Node which the Flow is primarily associated with.\n            max_capacity (FlowVolume | None, optional): Maximum capacity of the Flow. Defaults to None.\n            min_capacity (FlowVolume | None, optional): Minimum capacity of the Flow. Defaults to None.\n            startupcost (StartUpCost | None, optional): Costs associated with starting up this Flow. Defaults to None.\n            volume (AvgFlowVolume | None, optional): The actual volume carried by this Flow at a given moment. Defaults to None.\n            arrow_volumes (dict[Arrow, AvgFlowVolume] | None, optional): Possibility to store a version of volume for each Arrow. Can account for conversion,\n            efficiency and loss to represent the result for different commodities and units. Defaults to None.\n            is_exogenous (bool, optional): Flag denoting if a Solver should calculate the volumes associated with this flow or use its predefined volume.\n                                           Defaults to False.\n\n        \"\"\"\n        super().__init__()\n        self._check_type(main_node, str)\n        self._check_type(max_capacity, (FlowVolume, type(None)))\n        self._check_type(min_capacity, (FlowVolume, type(None)))\n        self._check_type(startupcost, (StartUpCost, type(None)))\n        self._check_type(volume, (FlowVolume, type(None)))\n        self._check_type(arrow_volumes, (dict, type(None)))\n        self._main_node: str = main_node\n        self._max_capacity = max_capacity\n        self._min_capacity = min_capacity\n        self._startupcost = startupcost\n        self._arrows: set[Arrow] = set()\n        self._cost_terms: dict[str, ObjectiveCoefficient] = dict()\n        self._is_exogenous: bool = is_exogenous\n\n        if not volume:\n            volume = AvgFlowVolume()\n        self._volume: AvgFlowVolume = volume\n\n        if arrow_volumes is None:\n            arrow_volumes = dict()\n        self._arrow_volumes: dict[Arrow, AvgFlowVolume] = arrow_volumes\n\n    def is_exogenous(self) -&gt; bool:\n        \"\"\"Return True if Flow is exogenous.\"\"\"\n        return self._is_exogenous\n\n    def set_exogenous(self) -&gt; None:\n        \"\"\"\n        Treat flow as fixed variable.\n\n        Use volume if it exists.\n        If no volume, then try to use\n        min_capacity and max_capacity, which must\n        be equal. Error if this fails.\n        \"\"\"\n        self._is_exogenous = True\n\n    def set_endogenous(self) -&gt; None:\n        \"\"\"\n        Treat flow as decision variable.\n\n        Volume should be updated with results after a solve.\n        \"\"\"\n        self._is_exogenous = False\n\n    def get_main_node(self) -&gt; str:\n        \"\"\"Get the main node of the flow.\"\"\"\n        return self._main_node\n\n    def get_volume(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the volume of the flow.\"\"\"\n        return self._volume\n\n    def get_arrow_volumes(self) -&gt; dict[Arrow, AvgFlowVolume]:\n        \"\"\"Get dict of volume converted to volume at node pointed to by Arrow.\"\"\"\n        return self._arrow_volumes\n\n    def get_max_capacity(self) -&gt; FlowVolume | None:\n        \"\"\"Get the maximum capacity of the flow.\"\"\"\n        return self._max_capacity\n\n    def set_max_capacity(self, capacity: FlowVolume | None) -&gt; None:\n        \"\"\"Set the maximum capacity of the flow.\"\"\"\n        self._check_type(capacity, (FlowVolume, type(None)))\n        self._max_capacity = capacity\n\n    def get_min_capacity(self) -&gt; FlowVolume | None:\n        \"\"\"Get the minimum capacity of the flow.\"\"\"\n        return self._min_capacity\n\n    def set_min_capacity(self, capacity: FlowVolume | None) -&gt; None:\n        \"\"\"Set the minimum capacity of the flow.\"\"\"\n        self._check_type(capacity, (FlowVolume, type(None)))\n        self._min_capacity = capacity\n\n    def get_startupcost(self) -&gt; StartUpCost | None:\n        \"\"\"Get the startup cost of the flow.\"\"\"\n        self._check_type(self._startupcost, (StartUpCost, type(None)))\n        return self._startupcost\n\n    def set_startupcost(self, startupcost: StartUpCost | None) -&gt; None:\n        \"\"\"Set the startup cost of the flow.\"\"\"\n        self._check_type(startupcost, (StartUpCost, type(None)))\n        self._startupcost = startupcost\n\n    def get_arrows(self) -&gt; set[Arrow]:\n        \"\"\"Get the arrows of the flow.\"\"\"\n        return self._arrows\n\n    def add_arrow(self, arrow: Arrow) -&gt; None:\n        \"\"\"Add an arrow to the flow.\"\"\"\n        self._check_type(arrow, Arrow)\n        self._arrows.add(arrow)\n\n    def add_cost_term(self, key: str, cost_term: ObjectiveCoefficient) -&gt; None:\n        \"\"\"Add a cost term to the flow.\"\"\"\n        self._check_type(key, str)\n        self._check_type(cost_term, ObjectiveCoefficient)\n        self._cost_terms[key] = cost_term\n\n    def get_cost_terms(self) -&gt; dict[str, ObjectiveCoefficient]:\n        \"\"\"Get the cost terms of the flow.\"\"\"\n        return self._cost_terms\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add loaders stored in attributes to loaders.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self.get_volume())\n        add_loaders_if(loaders, self.get_max_capacity())\n        add_loaders_if(loaders, self.get_min_capacity())\n\n        for cost in self.get_cost_terms().values():\n            add_loaders_if(loaders, cost)\n\n        for arrow in self.get_arrows():\n            add_loaders_if(loaders, arrow)\n\n        for volume in self.get_arrow_volumes().values():\n            add_loaders_if(loaders, volume)\n\n    def _replace_node(self, old: str, new: str) -&gt; None:\n        # Component.replace_node does input type check\n        if old == self._main_node:\n            self._main_node = new\n        for a in self._arrows:\n            a: Arrow\n            if a.get_node() == old:\n                a.set_node(new)\n                return\n\n    def _get_simpler_components(self, _: str) -&gt; dict[str, Component]:\n        return dict()\n\n    def _get_fingerprint(self) -&gt; Fingerprint:\n        refs = {}\n        refs[\"_main_node\"] = self._main_node\n\n        return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.__init__","title":"<code>__init__(main_node: str, max_capacity: FlowVolume | None = None, min_capacity: FlowVolume | None = None, startupcost: StartUpCost | None = None, volume: AvgFlowVolume | None = None, arrow_volumes: dict[Arrow, AvgFlowVolume] | None = None, is_exogenous: bool = False) -&gt; None</code>","text":"<p>Initialize Flow with main node, capacity, and startup cost.</p> <p>Parameters:</p> Name Type Description Default <code>main_node</code> <code>str</code> <p>Node which the Flow is primarily associated with.</p> required <code>max_capacity</code> <code>FlowVolume | None</code> <p>Maximum capacity of the Flow. Defaults to None.</p> <code>None</code> <code>min_capacity</code> <code>FlowVolume | None</code> <p>Minimum capacity of the Flow. Defaults to None.</p> <code>None</code> <code>startupcost</code> <code>StartUpCost | None</code> <p>Costs associated with starting up this Flow. Defaults to None.</p> <code>None</code> <code>volume</code> <code>AvgFlowVolume | None</code> <p>The actual volume carried by this Flow at a given moment. Defaults to None.</p> <code>None</code> <code>arrow_volumes</code> <code>dict[Arrow, AvgFlowVolume] | None</code> <p>Possibility to store a version of volume for each Arrow. Can account for conversion,</p> <code>None</code> <code>is_exogenous</code> <code>bool</code> <p>Flag denoting if a Solver should calculate the volumes associated with this flow or use its predefined volume.                            Defaults to False.</p> <code>False</code> Source code in <code>framcore/components/Flow.py</code> <pre><code>def __init__(\n    self,\n    main_node: str,\n    max_capacity: FlowVolume | None = None,\n    min_capacity: FlowVolume | None = None,\n    startupcost: StartUpCost | None = None,\n    volume: AvgFlowVolume | None = None,\n    arrow_volumes: dict[Arrow, AvgFlowVolume] | None = None,\n    is_exogenous: bool = False,\n) -&gt; None:\n    \"\"\"\n    Initialize Flow with main node, capacity, and startup cost.\n\n    Args:\n        main_node (str): Node which the Flow is primarily associated with.\n        max_capacity (FlowVolume | None, optional): Maximum capacity of the Flow. Defaults to None.\n        min_capacity (FlowVolume | None, optional): Minimum capacity of the Flow. Defaults to None.\n        startupcost (StartUpCost | None, optional): Costs associated with starting up this Flow. Defaults to None.\n        volume (AvgFlowVolume | None, optional): The actual volume carried by this Flow at a given moment. Defaults to None.\n        arrow_volumes (dict[Arrow, AvgFlowVolume] | None, optional): Possibility to store a version of volume for each Arrow. Can account for conversion,\n        efficiency and loss to represent the result for different commodities and units. Defaults to None.\n        is_exogenous (bool, optional): Flag denoting if a Solver should calculate the volumes associated with this flow or use its predefined volume.\n                                       Defaults to False.\n\n    \"\"\"\n    super().__init__()\n    self._check_type(main_node, str)\n    self._check_type(max_capacity, (FlowVolume, type(None)))\n    self._check_type(min_capacity, (FlowVolume, type(None)))\n    self._check_type(startupcost, (StartUpCost, type(None)))\n    self._check_type(volume, (FlowVolume, type(None)))\n    self._check_type(arrow_volumes, (dict, type(None)))\n    self._main_node: str = main_node\n    self._max_capacity = max_capacity\n    self._min_capacity = min_capacity\n    self._startupcost = startupcost\n    self._arrows: set[Arrow] = set()\n    self._cost_terms: dict[str, ObjectiveCoefficient] = dict()\n    self._is_exogenous: bool = is_exogenous\n\n    if not volume:\n        volume = AvgFlowVolume()\n    self._volume: AvgFlowVolume = volume\n\n    if arrow_volumes is None:\n        arrow_volumes = dict()\n    self._arrow_volumes: dict[Arrow, AvgFlowVolume] = arrow_volumes\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.add_arrow","title":"<code>add_arrow(arrow: Arrow) -&gt; None</code>","text":"<p>Add an arrow to the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def add_arrow(self, arrow: Arrow) -&gt; None:\n    \"\"\"Add an arrow to the flow.\"\"\"\n    self._check_type(arrow, Arrow)\n    self._arrows.add(arrow)\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.add_cost_term","title":"<code>add_cost_term(key: str, cost_term: ObjectiveCoefficient) -&gt; None</code>","text":"<p>Add a cost term to the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def add_cost_term(self, key: str, cost_term: ObjectiveCoefficient) -&gt; None:\n    \"\"\"Add a cost term to the flow.\"\"\"\n    self._check_type(key, str)\n    self._check_type(cost_term, ObjectiveCoefficient)\n    self._cost_terms[key] = cost_term\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add loaders stored in attributes to loaders.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add loaders stored in attributes to loaders.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self.get_volume())\n    add_loaders_if(loaders, self.get_max_capacity())\n    add_loaders_if(loaders, self.get_min_capacity())\n\n    for cost in self.get_cost_terms().values():\n        add_loaders_if(loaders, cost)\n\n    for arrow in self.get_arrows():\n        add_loaders_if(loaders, arrow)\n\n    for volume in self.get_arrow_volumes().values():\n        add_loaders_if(loaders, volume)\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_arrow_volumes","title":"<code>get_arrow_volumes() -&gt; dict[Arrow, AvgFlowVolume]</code>","text":"<p>Get dict of volume converted to volume at node pointed to by Arrow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_arrow_volumes(self) -&gt; dict[Arrow, AvgFlowVolume]:\n    \"\"\"Get dict of volume converted to volume at node pointed to by Arrow.\"\"\"\n    return self._arrow_volumes\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_arrows","title":"<code>get_arrows() -&gt; set[Arrow]</code>","text":"<p>Get the arrows of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_arrows(self) -&gt; set[Arrow]:\n    \"\"\"Get the arrows of the flow.\"\"\"\n    return self._arrows\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_cost_terms","title":"<code>get_cost_terms() -&gt; dict[str, ObjectiveCoefficient]</code>","text":"<p>Get the cost terms of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_cost_terms(self) -&gt; dict[str, ObjectiveCoefficient]:\n    \"\"\"Get the cost terms of the flow.\"\"\"\n    return self._cost_terms\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_main_node","title":"<code>get_main_node() -&gt; str</code>","text":"<p>Get the main node of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_main_node(self) -&gt; str:\n    \"\"\"Get the main node of the flow.\"\"\"\n    return self._main_node\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_max_capacity","title":"<code>get_max_capacity() -&gt; FlowVolume | None</code>","text":"<p>Get the maximum capacity of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_max_capacity(self) -&gt; FlowVolume | None:\n    \"\"\"Get the maximum capacity of the flow.\"\"\"\n    return self._max_capacity\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_min_capacity","title":"<code>get_min_capacity() -&gt; FlowVolume | None</code>","text":"<p>Get the minimum capacity of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_min_capacity(self) -&gt; FlowVolume | None:\n    \"\"\"Get the minimum capacity of the flow.\"\"\"\n    return self._min_capacity\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_startupcost","title":"<code>get_startupcost() -&gt; StartUpCost | None</code>","text":"<p>Get the startup cost of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_startupcost(self) -&gt; StartUpCost | None:\n    \"\"\"Get the startup cost of the flow.\"\"\"\n    self._check_type(self._startupcost, (StartUpCost, type(None)))\n    return self._startupcost\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.get_volume","title":"<code>get_volume() -&gt; AvgFlowVolume</code>","text":"<p>Get the volume of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def get_volume(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the volume of the flow.\"\"\"\n    return self._volume\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.is_exogenous","title":"<code>is_exogenous() -&gt; bool</code>","text":"<p>Return True if Flow is exogenous.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def is_exogenous(self) -&gt; bool:\n    \"\"\"Return True if Flow is exogenous.\"\"\"\n    return self._is_exogenous\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.set_endogenous","title":"<code>set_endogenous() -&gt; None</code>","text":"<p>Treat flow as decision variable.</p> <p>Volume should be updated with results after a solve.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def set_endogenous(self) -&gt; None:\n    \"\"\"\n    Treat flow as decision variable.\n\n    Volume should be updated with results after a solve.\n    \"\"\"\n    self._is_exogenous = False\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.set_exogenous","title":"<code>set_exogenous() -&gt; None</code>","text":"<p>Treat flow as fixed variable.</p> <p>Use volume if it exists. If no volume, then try to use min_capacity and max_capacity, which must be equal. Error if this fails.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def set_exogenous(self) -&gt; None:\n    \"\"\"\n    Treat flow as fixed variable.\n\n    Use volume if it exists.\n    If no volume, then try to use\n    min_capacity and max_capacity, which must\n    be equal. Error if this fails.\n    \"\"\"\n    self._is_exogenous = True\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.set_max_capacity","title":"<code>set_max_capacity(capacity: FlowVolume | None) -&gt; None</code>","text":"<p>Set the maximum capacity of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def set_max_capacity(self, capacity: FlowVolume | None) -&gt; None:\n    \"\"\"Set the maximum capacity of the flow.\"\"\"\n    self._check_type(capacity, (FlowVolume, type(None)))\n    self._max_capacity = capacity\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.set_min_capacity","title":"<code>set_min_capacity(capacity: FlowVolume | None) -&gt; None</code>","text":"<p>Set the minimum capacity of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def set_min_capacity(self, capacity: FlowVolume | None) -&gt; None:\n    \"\"\"Set the minimum capacity of the flow.\"\"\"\n    self._check_type(capacity, (FlowVolume, type(None)))\n    self._min_capacity = capacity\n</code></pre>"},{"location":"reference/#framcore.components.Flow.Flow.set_startupcost","title":"<code>set_startupcost(startupcost: StartUpCost | None) -&gt; None</code>","text":"<p>Set the startup cost of the flow.</p> Source code in <code>framcore/components/Flow.py</code> <pre><code>def set_startupcost(self, startupcost: StartUpCost | None) -&gt; None:\n    \"\"\"Set the startup cost of the flow.\"\"\"\n    self._check_type(startupcost, (StartUpCost, type(None)))\n    self._startupcost = startupcost\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule","title":"<code>HydroModule</code>","text":""},{"location":"reference/#framcore.components.HydroModule.HydroModule","title":"<code>HydroModule</code>","text":"<p>               Bases: <code>Component</code></p> <p>HydroModules represents a physical element in a river system, with its topology and other attributes.</p> <p>The hydromodule can contain a HydroReservoir, HydroGenerator, HydroPump, HydroBypass and local inflow, aswell as the topological attributes release_to and spill_to:</p> <ul> <li>HydroGenerator uses the release pathway of the HydroModule to generate power, while HydroPump has its own water way that consumes   power. Both HydroGenerator and HydroPump connects to power nodes.</li> <li>HydroBypass also have attributes that define the topology of the river system.</li> <li>HydroReservoir represents the water storage of the HydroModule.</li> <li>The hydraulic_coupling attribute is used to identify which HydroModules have hydraulic coupled reservoirs.</li> </ul> <p>Results for the release volume, spill volume and the water value are stored directly in the HydroModule, while the production, pumping, reservoir volume and bypass volume are stored in the attributes.</p> <p>HydroModule is compatible with HydroAggregator for aggregation of multiple HydroModules into one.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>class HydroModule(Component):\n    \"\"\"\n    HydroModules represents a physical element in a river system, with its topology and other attributes.\n\n    The hydromodule can contain a HydroReservoir, HydroGenerator, HydroPump, HydroBypass and local inflow, aswell as the topological attributes release_to\n    and spill_to:\n\n    - HydroGenerator uses the release pathway of the HydroModule to generate power, while HydroPump has its own water way that consumes\n      power. Both HydroGenerator and HydroPump connects to power nodes.\n    - HydroBypass also have attributes that define the topology of the river system.\n    - HydroReservoir represents the water storage of the HydroModule.\n    - The hydraulic_coupling attribute is used to identify which HydroModules have hydraulic coupled reservoirs.\n\n\n    Results for the release volume, spill volume and the water value are stored directly in the HydroModule, while the production, pumping,\n    reservoir volume and bypass volume are stored in the attributes.\n\n    HydroModule is compatible with HydroAggregator for aggregation of multiple HydroModules into one.\n\n    \"\"\"\n\n    # We add this to module name to get corresponding node name\n    _NODE_NAME_POSTFIX = \"_node\"\n\n    def __init__(\n        self,\n        release_to: str | None = None,  # Must be reference to another HydroModule\n        release_capacity: FlowVolume | None = None,\n        generator: HydroGenerator | None = None,  # attribute\n        pump: HydroPump | None = None,\n        inflow: AvgFlowVolume | None = None,\n        reservoir: HydroReservoir | None = None,  # attribute\n        hydraulic_coupling: int = 0,\n        bypass: HydroBypass | None = None,  # attribute\n        spill_to: str | None = None,  # Must be reference to another HydroModule\n        commodity: str = \"Hydro\",\n        water_value: WaterValue | None = None,\n        release_volume: AvgFlowVolume | None = None,\n        spill_volume: AvgFlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the HydroModule with its parameters.\n\n        Args:\n            release_to (str | None, optional): Reference to another HydroModule which recieves the water releases through the main release. Defaults to None.\n            release_capacity (FlowVolume | None): Amount of water which can be released via main release at a given moment. Defaults to None.\n            generator (HydroGenerator | None, optional): Represents generation of electricity from the movement of water through the Modules main release\n                                                        pathway. Defaults to None.\n            pump (HydroPump | None): Pump associated with this Module. Can move water to another using power. Defaults to None.\n            inflow (AvgFlowVolume | None, optional): The local inflow of the HydroModule. Defaults to None.\n            reservoir (HydroReservoir | None, optional): The Modules water storage. Defaults to None.\n            hydraulic_coupling (int): Number other than 0 if the HydroModules reservoir is hydraulic coupled to another reservoir. Defaults to 0.\n                                                        TODO: Replace with HydraulicCoupling class\n            bypass (HydroBypass | None, optional): Bypass water way. Defaults to None.\n            spill_to (str | None): Reference to another Module recieving this ones spill volume. Defaults to None.\n            commodity (str, optional): Commodity of the hydro node. Defaults to \"Hydro\".\n            water_value (WaterValue | None, optional): Water value of the reservoir in currency per water volume. Defaults to None.\n                                                        TODO: Allow water values with multiple demimensions?\n            release_volume (AvgFlowVolume | None, optional): Volume of water released via main waterway. Defaults to None.\n            spill_volume (AvgFlowVolume | None, optional): Volume of water spilled. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n        self._check_type(release_to, (str, type(None)))\n        self._check_type(release_capacity, (FlowVolume, type(None)))\n        self._check_type(generator, (HydroGenerator, type(None)))\n        self._check_type(pump, (HydroPump, type(None)))\n        self._check_type(inflow, (AvgFlowVolume, type(None)))\n        self._check_type(reservoir, (HydroReservoir, type(None)))\n        self._check_type(hydraulic_coupling, int)\n        self._check_type(bypass, (HydroBypass, type(None)))\n        self._check_type(spill_to, (str, type(None)))\n        self._check_type(commodity, str)\n        self._check_type(water_value, (WaterValue, type(None)))\n        self._check_type(release_volume, (AvgFlowVolume, type(None)))\n        self._check_type(spill_volume, (AvgFlowVolume, type(None)))\n\n        self._release_to = release_to\n        self._release_capacity = release_capacity\n        self._generator = generator\n        self._pump = pump\n        self._inflow = inflow\n        self._reservoir = reservoir\n        self._hydraulic_coupling = hydraulic_coupling\n        self._bypass = bypass\n        self._spill_to = spill_to\n        self._commodity = commodity\n\n        if not water_value:\n            water_value = WaterValue()\n\n        if not release_volume:\n            release_volume = AvgFlowVolume()\n\n        if not spill_volume:\n            spill_volume = AvgFlowVolume()\n\n        self._water_value: WaterValue = water_value\n        self._release_volume: AvgFlowVolume = release_volume\n        self._spill_volume: AvgFlowVolume = spill_volume\n\n    def get_release_capacity(self) -&gt; FlowVolume | None:\n        \"\"\"Get the capacity of the thermal unit.\"\"\"\n        return self._release_capacity\n\n    def get_hydraulic_coupling(self) -&gt; int:\n        \"\"\"Get the Modules hydraulic code.\"\"\"\n        return self._hydraulic_coupling\n\n    def get_reservoir(self) -&gt; HydroReservoir | None:\n        \"\"\"Get the reservoir of the hydro module.\"\"\"\n        return self._reservoir\n\n    def set_reservoir(self, reservoir: HydroReservoir | None) -&gt; None:\n        \"\"\"Set the reservoir of the hydro module.\"\"\"\n        self._check_type(reservoir, (HydroReservoir, type(None)))\n        self._reservoir = reservoir\n\n    def get_pump(self) -&gt; HydroPump | None:\n        \"\"\"Get the pump of the hydro module.\"\"\"\n        return self._pump\n\n    def set_pump(self, pump: HydroPump | None) -&gt; None:\n        \"\"\"Set the pump of the hydro module.\"\"\"\n        self._check_type(pump, (HydroPump, type(None)))\n        self._pump = pump\n\n    def get_generator(self) -&gt; HydroGenerator | None:\n        \"\"\"Get the generator of the hydro module.\"\"\"\n        return self._generator\n\n    def set_generator(self, generator: HydroGenerator | None) -&gt; None:\n        \"\"\"Set the generator of the hydro module.\"\"\"\n        self._check_type(generator, (HydroGenerator, type(None)))\n        self._generator = generator\n\n    def get_bypass(self) -&gt; HydroBypass | None:\n        \"\"\"Get the bypass of the hydro module.\"\"\"\n        return self._bypass\n\n    def set_bypass(self, bypass: HydroBypass | None) -&gt; None:\n        \"\"\"Set the bypass of the hydro module.\"\"\"\n        self._check_type(bypass, (HydroBypass, type(None)))\n        self._bypass = bypass\n\n    def get_inflow(self) -&gt; AvgFlowVolume | None:\n        \"\"\"Get the inflow of the hydro module.\"\"\"\n        return self._inflow\n\n    def set_inflow(self, inflow: AvgFlowVolume | None) -&gt; None:\n        \"\"\"Set the inflow of the hydro module.\"\"\"\n        self._check_type(inflow, (AvgFlowVolume, type(None)))\n        self._inflow = inflow\n\n    def get_release_to(self) -&gt; str | None:\n        \"\"\"Get the release_to module of the hydro module.\"\"\"\n        return self._release_to\n\n    def set_release_to(self, release_to: str | None) -&gt; None:\n        \"\"\"Set the release_to module of the hydro module.\"\"\"\n        self._check_type(release_to, (str, type(None)))\n        self._release_to = release_to\n\n    def get_spill_to(self) -&gt; str | None:\n        \"\"\"Get the spill_to module of the hydro module.\"\"\"\n        return self._spill_to\n\n    def get_water_value(self) -&gt; WaterValue:\n        \"\"\"Get water value at the hydro node.\"\"\"\n        return self._water_value\n\n    def get_release_volume(self) -&gt; FlowVolume:\n        \"\"\"Get the release_volume volume of the thermal unit.\"\"\"\n        return self._release_volume\n\n    def get_spill_volume(self) -&gt; FlowVolume:\n        \"\"\"Get the spill_volume volume of the thermal unit.\"\"\"\n        return self._spill_volume\n\n    \"\"\"Implementation of Component interface\"\"\"\n\n    def _replace_node(self, old: str, new: str) -&gt; None:\n        if self._pump and old == self._pump.get_power_node():\n            self._pump.set_power_node(new)\n        if self._generator and old == self._generator.get_power_node():\n            self._generator.set_power_node(new)\n\n    def _get_simpler_components(self, module_name: str) -&gt; dict[str, Component]:\n        out: dict[str, Component] = {}\n\n        node_name = module_name + self._NODE_NAME_POSTFIX\n\n        out[node_name] = self._create_hydro_node()\n        out[module_name + \"_release_flow\"] = self._create_release_flow(node_name)\n        out[module_name + \"_spill_flow\"] = self._create_spill_flow(node_name)\n\n        if self._inflow is not None:\n            out[module_name + \"_inflow_flow\"] = self._create_inflow_flow(node_name)\n\n        if self._bypass is not None:\n            out[module_name + \"_bypass_flow\"] = self._create_bypass_flow(node_name)\n\n        if self._pump is not None:\n            out[module_name + \"_pump_flow\"] = self._create_pump_flow(node_name)\n\n        return out\n\n    def _create_hydro_node(self) -&gt; Node:\n        return Node(\n            commodity=self._commodity,\n            price=self._water_value,\n            storage=self._reservoir,\n        )\n\n    def _create_release_flow(self, node_name: str) -&gt; Flow:\n        # TODO: pq_curve, nominal_head, tailwater_elevation\n        flow = Flow(\n            main_node=node_name,\n            max_capacity=self._release_capacity,\n            volume=self._release_volume,\n            startupcost=None,\n            arrow_volumes=None,\n            is_exogenous=False,\n        )\n\n        arrow_volumes = flow.get_arrow_volumes()\n\n        outgoing_arrow = Arrow(\n            node=node_name,\n            is_ingoing=False,\n            conversion=Conversion(value=1),\n        )\n\n        flow.add_arrow(outgoing_arrow)\n\n        if self._release_to:\n            flow.add_arrow(\n                Arrow(\n                    node=self._release_to + self._NODE_NAME_POSTFIX,\n                    is_ingoing=True,\n                    conversion=Conversion(value=1),\n                ),\n            )\n\n        if self._generator:\n            production_arrow = Arrow(\n                node=self._generator.get_power_node(),\n                is_ingoing=True,\n                conversion=self._generator.get_energy_equivalent(),\n            )\n            flow.add_arrow(production_arrow)\n            arrow_volumes[production_arrow] = self._generator.get_production()\n\n            if self._generator.get_voc() is not None:\n                flow.add_cost_term(\"VOC\", self._generator.get_voc())\n\n        return flow\n\n    def _create_spill_flow(self, node_name: str) -&gt; Flow:\n        flow = Flow(\n            main_node=node_name,\n            max_capacity=None,\n            volume=self._spill_volume,\n        )\n\n        flow.add_arrow(\n            Arrow(\n                node=node_name,\n                is_ingoing=False,\n                conversion=Conversion(value=1),\n            ),\n        )\n\n        if self._spill_to is not None:\n            flow.add_arrow(\n                Arrow(\n                    node=self._spill_to + self._NODE_NAME_POSTFIX,\n                    is_ingoing=True,\n                    conversion=Conversion(value=1),\n                ),\n            )\n\n        return flow\n\n    def _create_bypass_flow(self, node_name: str) -&gt; Flow:\n        flow = Flow(\n            main_node=node_name,\n            max_capacity=self._bypass.get_capacity(),\n            volume=self._bypass.get_volume(),\n            is_exogenous=False,\n        )\n\n        flow.add_arrow(\n            Arrow(\n                node=node_name,\n                is_ingoing=False,\n                conversion=Conversion(value=1),\n            ),\n        )\n\n        if self._bypass.get_to_module() is not None:\n            flow.add_arrow(\n                Arrow(\n                    node=self._bypass.get_to_module() + self._NODE_NAME_POSTFIX,\n                    is_ingoing=True,\n                    conversion=Conversion(value=1),\n                ),\n            )\n\n        return flow\n\n    def _create_inflow_flow(self, node_name: str) -&gt; Flow:\n        flow = Flow(\n            main_node=node_name,\n            max_capacity=None,\n            volume=self._inflow,\n            is_exogenous=True,\n        )\n\n        flow.add_arrow(\n            Arrow(\n                node=node_name,\n                is_ingoing=True,\n                conversion=Conversion(value=1),\n            ),\n        )\n\n        return flow\n\n    def _create_pump_flow(self, node_name: str) -&gt; Flow:\n        # TODO: add rest of attributes\n\n        arrow_volumes: dict[Arrow, FlowVolume] = dict()\n\n        flow = Flow(\n            main_node=node_name,\n            max_capacity=self._pump.get_water_capacity(),\n            volume=self._pump.get_water_consumption(),\n            arrow_volumes=arrow_volumes,\n            is_exogenous=False,\n        )\n\n        flow.add_arrow(\n            Arrow(\n                node=self._pump.get_to_module() + self._NODE_NAME_POSTFIX,\n                is_ingoing=True,\n                conversion=Conversion(value=1),\n            ),\n        )\n\n        flow.add_arrow(\n            Arrow(\n                node=self._pump.get_from_module() + self._NODE_NAME_POSTFIX,\n                is_ingoing=False,\n                conversion=Conversion(value=1),\n            ),\n        )\n\n        pump_arrow = Arrow(\n            node=self._pump.get_power_node(),\n            is_ingoing=False,\n            conversion=self._pump.get_energy_equivalent(),\n        )\n        flow.add_arrow(pump_arrow)\n        arrow_volumes[pump_arrow] = self._pump.get_power_consumption()\n\n        return flow\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.__init__","title":"<code>__init__(release_to: str | None = None, release_capacity: FlowVolume | None = None, generator: HydroGenerator | None = None, pump: HydroPump | None = None, inflow: AvgFlowVolume | None = None, reservoir: HydroReservoir | None = None, hydraulic_coupling: int = 0, bypass: HydroBypass | None = None, spill_to: str | None = None, commodity: str = 'Hydro', water_value: WaterValue | None = None, release_volume: AvgFlowVolume | None = None, spill_volume: AvgFlowVolume | None = None) -&gt; None</code>","text":"<p>Initialize the HydroModule with its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>release_to</code> <code>str | None</code> <p>Reference to another HydroModule which recieves the water releases through the main release. Defaults to None.</p> <code>None</code> <code>release_capacity</code> <code>FlowVolume | None</code> <p>Amount of water which can be released via main release at a given moment. Defaults to None.</p> <code>None</code> <code>generator</code> <code>HydroGenerator | None</code> <p>Represents generation of electricity from the movement of water through the Modules main release                                         pathway. Defaults to None.</p> <code>None</code> <code>pump</code> <code>HydroPump | None</code> <p>Pump associated with this Module. Can move water to another using power. Defaults to None.</p> <code>None</code> <code>inflow</code> <code>AvgFlowVolume | None</code> <p>The local inflow of the HydroModule. Defaults to None.</p> <code>None</code> <code>reservoir</code> <code>HydroReservoir | None</code> <p>The Modules water storage. Defaults to None.</p> <code>None</code> <code>hydraulic_coupling</code> <code>int</code> <p>Number other than 0 if the HydroModules reservoir is hydraulic coupled to another reservoir. Defaults to 0.                                         TODO: Replace with HydraulicCoupling class</p> <code>0</code> <code>bypass</code> <code>HydroBypass | None</code> <p>Bypass water way. Defaults to None.</p> <code>None</code> <code>spill_to</code> <code>str | None</code> <p>Reference to another Module recieving this ones spill volume. Defaults to None.</p> <code>None</code> <code>commodity</code> <code>str</code> <p>Commodity of the hydro node. Defaults to \"Hydro\".</p> <code>'Hydro'</code> <code>water_value</code> <code>WaterValue | None</code> <p>Water value of the reservoir in currency per water volume. Defaults to None.                                         TODO: Allow water values with multiple demimensions?</p> <code>None</code> <code>release_volume</code> <code>AvgFlowVolume | None</code> <p>Volume of water released via main waterway. Defaults to None.</p> <code>None</code> <code>spill_volume</code> <code>AvgFlowVolume | None</code> <p>Volume of water spilled. Defaults to None.</p> <code>None</code> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def __init__(\n    self,\n    release_to: str | None = None,  # Must be reference to another HydroModule\n    release_capacity: FlowVolume | None = None,\n    generator: HydroGenerator | None = None,  # attribute\n    pump: HydroPump | None = None,\n    inflow: AvgFlowVolume | None = None,\n    reservoir: HydroReservoir | None = None,  # attribute\n    hydraulic_coupling: int = 0,\n    bypass: HydroBypass | None = None,  # attribute\n    spill_to: str | None = None,  # Must be reference to another HydroModule\n    commodity: str = \"Hydro\",\n    water_value: WaterValue | None = None,\n    release_volume: AvgFlowVolume | None = None,\n    spill_volume: AvgFlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the HydroModule with its parameters.\n\n    Args:\n        release_to (str | None, optional): Reference to another HydroModule which recieves the water releases through the main release. Defaults to None.\n        release_capacity (FlowVolume | None): Amount of water which can be released via main release at a given moment. Defaults to None.\n        generator (HydroGenerator | None, optional): Represents generation of electricity from the movement of water through the Modules main release\n                                                    pathway. Defaults to None.\n        pump (HydroPump | None): Pump associated with this Module. Can move water to another using power. Defaults to None.\n        inflow (AvgFlowVolume | None, optional): The local inflow of the HydroModule. Defaults to None.\n        reservoir (HydroReservoir | None, optional): The Modules water storage. Defaults to None.\n        hydraulic_coupling (int): Number other than 0 if the HydroModules reservoir is hydraulic coupled to another reservoir. Defaults to 0.\n                                                    TODO: Replace with HydraulicCoupling class\n        bypass (HydroBypass | None, optional): Bypass water way. Defaults to None.\n        spill_to (str | None): Reference to another Module recieving this ones spill volume. Defaults to None.\n        commodity (str, optional): Commodity of the hydro node. Defaults to \"Hydro\".\n        water_value (WaterValue | None, optional): Water value of the reservoir in currency per water volume. Defaults to None.\n                                                    TODO: Allow water values with multiple demimensions?\n        release_volume (AvgFlowVolume | None, optional): Volume of water released via main waterway. Defaults to None.\n        spill_volume (AvgFlowVolume | None, optional): Volume of water spilled. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self._check_type(release_to, (str, type(None)))\n    self._check_type(release_capacity, (FlowVolume, type(None)))\n    self._check_type(generator, (HydroGenerator, type(None)))\n    self._check_type(pump, (HydroPump, type(None)))\n    self._check_type(inflow, (AvgFlowVolume, type(None)))\n    self._check_type(reservoir, (HydroReservoir, type(None)))\n    self._check_type(hydraulic_coupling, int)\n    self._check_type(bypass, (HydroBypass, type(None)))\n    self._check_type(spill_to, (str, type(None)))\n    self._check_type(commodity, str)\n    self._check_type(water_value, (WaterValue, type(None)))\n    self._check_type(release_volume, (AvgFlowVolume, type(None)))\n    self._check_type(spill_volume, (AvgFlowVolume, type(None)))\n\n    self._release_to = release_to\n    self._release_capacity = release_capacity\n    self._generator = generator\n    self._pump = pump\n    self._inflow = inflow\n    self._reservoir = reservoir\n    self._hydraulic_coupling = hydraulic_coupling\n    self._bypass = bypass\n    self._spill_to = spill_to\n    self._commodity = commodity\n\n    if not water_value:\n        water_value = WaterValue()\n\n    if not release_volume:\n        release_volume = AvgFlowVolume()\n\n    if not spill_volume:\n        spill_volume = AvgFlowVolume()\n\n    self._water_value: WaterValue = water_value\n    self._release_volume: AvgFlowVolume = release_volume\n    self._spill_volume: AvgFlowVolume = spill_volume\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_bypass","title":"<code>get_bypass() -&gt; HydroBypass | None</code>","text":"<p>Get the bypass of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_bypass(self) -&gt; HydroBypass | None:\n    \"\"\"Get the bypass of the hydro module.\"\"\"\n    return self._bypass\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_generator","title":"<code>get_generator() -&gt; HydroGenerator | None</code>","text":"<p>Get the generator of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_generator(self) -&gt; HydroGenerator | None:\n    \"\"\"Get the generator of the hydro module.\"\"\"\n    return self._generator\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_hydraulic_coupling","title":"<code>get_hydraulic_coupling() -&gt; int</code>","text":"<p>Get the Modules hydraulic code.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_hydraulic_coupling(self) -&gt; int:\n    \"\"\"Get the Modules hydraulic code.\"\"\"\n    return self._hydraulic_coupling\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_inflow","title":"<code>get_inflow() -&gt; AvgFlowVolume | None</code>","text":"<p>Get the inflow of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_inflow(self) -&gt; AvgFlowVolume | None:\n    \"\"\"Get the inflow of the hydro module.\"\"\"\n    return self._inflow\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_pump","title":"<code>get_pump() -&gt; HydroPump | None</code>","text":"<p>Get the pump of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_pump(self) -&gt; HydroPump | None:\n    \"\"\"Get the pump of the hydro module.\"\"\"\n    return self._pump\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_release_capacity","title":"<code>get_release_capacity() -&gt; FlowVolume | None</code>","text":"<p>Get the capacity of the thermal unit.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_release_capacity(self) -&gt; FlowVolume | None:\n    \"\"\"Get the capacity of the thermal unit.\"\"\"\n    return self._release_capacity\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_release_to","title":"<code>get_release_to() -&gt; str | None</code>","text":"<p>Get the release_to module of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_release_to(self) -&gt; str | None:\n    \"\"\"Get the release_to module of the hydro module.\"\"\"\n    return self._release_to\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_release_volume","title":"<code>get_release_volume() -&gt; FlowVolume</code>","text":"<p>Get the release_volume volume of the thermal unit.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_release_volume(self) -&gt; FlowVolume:\n    \"\"\"Get the release_volume volume of the thermal unit.\"\"\"\n    return self._release_volume\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_reservoir","title":"<code>get_reservoir() -&gt; HydroReservoir | None</code>","text":"<p>Get the reservoir of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_reservoir(self) -&gt; HydroReservoir | None:\n    \"\"\"Get the reservoir of the hydro module.\"\"\"\n    return self._reservoir\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_spill_to","title":"<code>get_spill_to() -&gt; str | None</code>","text":"<p>Get the spill_to module of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_spill_to(self) -&gt; str | None:\n    \"\"\"Get the spill_to module of the hydro module.\"\"\"\n    return self._spill_to\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_spill_volume","title":"<code>get_spill_volume() -&gt; FlowVolume</code>","text":"<p>Get the spill_volume volume of the thermal unit.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_spill_volume(self) -&gt; FlowVolume:\n    \"\"\"Get the spill_volume volume of the thermal unit.\"\"\"\n    return self._spill_volume\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.get_water_value","title":"<code>get_water_value() -&gt; WaterValue</code>","text":"<p>Get water value at the hydro node.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def get_water_value(self) -&gt; WaterValue:\n    \"\"\"Get water value at the hydro node.\"\"\"\n    return self._water_value\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.set_bypass","title":"<code>set_bypass(bypass: HydroBypass | None) -&gt; None</code>","text":"<p>Set the bypass of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def set_bypass(self, bypass: HydroBypass | None) -&gt; None:\n    \"\"\"Set the bypass of the hydro module.\"\"\"\n    self._check_type(bypass, (HydroBypass, type(None)))\n    self._bypass = bypass\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.set_generator","title":"<code>set_generator(generator: HydroGenerator | None) -&gt; None</code>","text":"<p>Set the generator of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def set_generator(self, generator: HydroGenerator | None) -&gt; None:\n    \"\"\"Set the generator of the hydro module.\"\"\"\n    self._check_type(generator, (HydroGenerator, type(None)))\n    self._generator = generator\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.set_inflow","title":"<code>set_inflow(inflow: AvgFlowVolume | None) -&gt; None</code>","text":"<p>Set the inflow of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def set_inflow(self, inflow: AvgFlowVolume | None) -&gt; None:\n    \"\"\"Set the inflow of the hydro module.\"\"\"\n    self._check_type(inflow, (AvgFlowVolume, type(None)))\n    self._inflow = inflow\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.set_pump","title":"<code>set_pump(pump: HydroPump | None) -&gt; None</code>","text":"<p>Set the pump of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def set_pump(self, pump: HydroPump | None) -&gt; None:\n    \"\"\"Set the pump of the hydro module.\"\"\"\n    self._check_type(pump, (HydroPump, type(None)))\n    self._pump = pump\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.set_release_to","title":"<code>set_release_to(release_to: str | None) -&gt; None</code>","text":"<p>Set the release_to module of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def set_release_to(self, release_to: str | None) -&gt; None:\n    \"\"\"Set the release_to module of the hydro module.\"\"\"\n    self._check_type(release_to, (str, type(None)))\n    self._release_to = release_to\n</code></pre>"},{"location":"reference/#framcore.components.HydroModule.HydroModule.set_reservoir","title":"<code>set_reservoir(reservoir: HydroReservoir | None) -&gt; None</code>","text":"<p>Set the reservoir of the hydro module.</p> Source code in <code>framcore/components/HydroModule.py</code> <pre><code>def set_reservoir(self, reservoir: HydroReservoir | None) -&gt; None:\n    \"\"\"Set the reservoir of the hydro module.\"\"\"\n    self._check_type(reservoir, (HydroReservoir, type(None)))\n    self._reservoir = reservoir\n</code></pre>"},{"location":"reference/#framcore.components.Node","title":"<code>Node</code>","text":""},{"location":"reference/#framcore.components.Node.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>Component</code></p> <p>Represents a point in the energy system where a commodity can possibly be traded, stored or pass through.</p> <p>A node is characterized by the commodity it handles, its price, and optionally storage capabilities. If the node is exogenous, the commodity can be bought and sold at a fixed price determined by the user. If the node is endogenous, the price is determined by the market dynamics at the Node.</p> <p>Nodes, Flows and Arrows are the main building blocks in FRAM's low-level representation of energy systems. Movement between Nodes is represented by Flows and Arrows. Flows represent a commodity flow, and can have Arrows that each describe contribution of the Flow into a Node. The Arrows have direction to determine input or output, and parameters for the contribution of the Flow to the Node (conversion, efficiency and loss).</p> Source code in <code>framcore/components/Node.py</code> <pre><code>class Node(Component):\n    \"\"\"\n    Represents a point in the energy system where a commodity can possibly be traded, stored or pass through.\n\n    A node is characterized by the commodity it handles, its price, and optionally storage capabilities. If the\n    node is exogenous, the commodity can be bought and sold at a fixed price determined by the user.\n    If the node is endogenous, the price is determined by the market dynamics at the Node.\n\n    Nodes, Flows and Arrows are the main building blocks in FRAM's low-level representation of energy systems.\n    Movement between Nodes is represented by Flows and Arrows. Flows represent a commodity flow,\n    and can have Arrows that each describe contribution of the Flow into a Node.\n    The Arrows have direction to determine input or output,\n    and parameters for the contribution of the Flow to the Node (conversion, efficiency and loss).\n\n    \"\"\"\n\n    def __init__(\n        self,\n        commodity: str,\n        is_exogenous: bool = False,  # TODO\n        price: ShadowPrice | None = None,\n        storage: Storage | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Node class.\n\n        Args:\n            commodity (str): Commodity at the Node. Power/electricity, gas, heat, etc.\n            is_exogenous (bool, optional): Flag used to signal Solvers whether they should simulate the node endogenously or use the pre-set price.\n                                           Defaults to False.\n            price (ShadowPrice | None): Actual, calculated price of Commodity in this Node for each moment of simulation. Defaulta to None.\n            storage (Storage | None, optional): The amount of the Commodity stored on this Node. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n        self._check_type(commodity, str)\n        self._check_type(is_exogenous, bool)\n        self._check_type(price, (ShadowPrice, type(None)))\n        self._check_type(storage, (Storage, type(None)))\n\n        self._commodity = commodity\n        self._is_exogenous = is_exogenous\n\n        self._storage = storage\n\n        if price is None:\n            price = Price()\n\n        self._price: Price = price\n\n    def set_exogenous(self) -&gt; None:\n        \"\"\"Set the Node to be exogenous.\"\"\"\n        self._check_type(self._is_exogenous, bool)\n        self._is_exogenous = True\n\n    def set_endogenous(self) -&gt; None:\n        \"\"\"Set the Node to be endogenous.\"\"\"\n        self._check_type(self._is_exogenous, bool)\n        self._is_exogenous = False\n\n    def is_exogenous(self) -&gt; bool:\n        \"\"\"Return True if Node is exogenous (i.e. has fixed prices determined outside the model) else False.\"\"\"\n        return self._is_exogenous\n\n    def get_price(self) -&gt; ShadowPrice:\n        \"\"\"Return price.\"\"\"\n        return self._price\n\n    def get_storage(self) -&gt; Storage | None:\n        \"\"\"Get Storage if any.\"\"\"\n        return self._storage\n\n    def get_commodity(self) -&gt; str:\n        \"\"\"Return commodity.\"\"\"\n        return self._commodity\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add loaders stored in attributes to loaders.\"\"\"\n        from framcore.utils import add_loaders_if\n\n        add_loaders_if(loaders, self.get_price())\n        add_loaders_if(loaders, self.get_storage())\n\n    def _replace_node(self, old: str, new: str) -&gt; None:\n        return None\n\n    def _get_simpler_components(self, _: str) -&gt; dict[str, Component]:\n        return dict()\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.__init__","title":"<code>__init__(commodity: str, is_exogenous: bool = False, price: ShadowPrice | None = None, storage: Storage | None = None) -&gt; None</code>","text":"<p>Initialize the Node class.</p> <p>Parameters:</p> Name Type Description Default <code>commodity</code> <code>str</code> <p>Commodity at the Node. Power/electricity, gas, heat, etc.</p> required <code>is_exogenous</code> <code>bool</code> <p>Flag used to signal Solvers whether they should simulate the node endogenously or use the pre-set price.                            Defaults to False.</p> <code>False</code> <code>price</code> <code>ShadowPrice | None</code> <p>Actual, calculated price of Commodity in this Node for each moment of simulation. Defaulta to None.</p> <code>None</code> <code>storage</code> <code>Storage | None</code> <p>The amount of the Commodity stored on this Node. Defaults to None.</p> <code>None</code> Source code in <code>framcore/components/Node.py</code> <pre><code>def __init__(\n    self,\n    commodity: str,\n    is_exogenous: bool = False,  # TODO\n    price: ShadowPrice | None = None,\n    storage: Storage | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Node class.\n\n    Args:\n        commodity (str): Commodity at the Node. Power/electricity, gas, heat, etc.\n        is_exogenous (bool, optional): Flag used to signal Solvers whether they should simulate the node endogenously or use the pre-set price.\n                                       Defaults to False.\n        price (ShadowPrice | None): Actual, calculated price of Commodity in this Node for each moment of simulation. Defaulta to None.\n        storage (Storage | None, optional): The amount of the Commodity stored on this Node. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self._check_type(commodity, str)\n    self._check_type(is_exogenous, bool)\n    self._check_type(price, (ShadowPrice, type(None)))\n    self._check_type(storage, (Storage, type(None)))\n\n    self._commodity = commodity\n    self._is_exogenous = is_exogenous\n\n    self._storage = storage\n\n    if price is None:\n        price = Price()\n\n    self._price: Price = price\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add loaders stored in attributes to loaders.</p> Source code in <code>framcore/components/Node.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add loaders stored in attributes to loaders.\"\"\"\n    from framcore.utils import add_loaders_if\n\n    add_loaders_if(loaders, self.get_price())\n    add_loaders_if(loaders, self.get_storage())\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.get_commodity","title":"<code>get_commodity() -&gt; str</code>","text":"<p>Return commodity.</p> Source code in <code>framcore/components/Node.py</code> <pre><code>def get_commodity(self) -&gt; str:\n    \"\"\"Return commodity.\"\"\"\n    return self._commodity\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.get_price","title":"<code>get_price() -&gt; ShadowPrice</code>","text":"<p>Return price.</p> Source code in <code>framcore/components/Node.py</code> <pre><code>def get_price(self) -&gt; ShadowPrice:\n    \"\"\"Return price.\"\"\"\n    return self._price\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.get_storage","title":"<code>get_storage() -&gt; Storage | None</code>","text":"<p>Get Storage if any.</p> Source code in <code>framcore/components/Node.py</code> <pre><code>def get_storage(self) -&gt; Storage | None:\n    \"\"\"Get Storage if any.\"\"\"\n    return self._storage\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.is_exogenous","title":"<code>is_exogenous() -&gt; bool</code>","text":"<p>Return True if Node is exogenous (i.e. has fixed prices determined outside the model) else False.</p> Source code in <code>framcore/components/Node.py</code> <pre><code>def is_exogenous(self) -&gt; bool:\n    \"\"\"Return True if Node is exogenous (i.e. has fixed prices determined outside the model) else False.\"\"\"\n    return self._is_exogenous\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.set_endogenous","title":"<code>set_endogenous() -&gt; None</code>","text":"<p>Set the Node to be endogenous.</p> Source code in <code>framcore/components/Node.py</code> <pre><code>def set_endogenous(self) -&gt; None:\n    \"\"\"Set the Node to be endogenous.\"\"\"\n    self._check_type(self._is_exogenous, bool)\n    self._is_exogenous = False\n</code></pre>"},{"location":"reference/#framcore.components.Node.Node.set_exogenous","title":"<code>set_exogenous() -&gt; None</code>","text":"<p>Set the Node to be exogenous.</p> Source code in <code>framcore/components/Node.py</code> <pre><code>def set_exogenous(self) -&gt; None:\n    \"\"\"Set the Node to be exogenous.\"\"\"\n    self._check_type(self._is_exogenous, bool)\n    self._is_exogenous = True\n</code></pre>"},{"location":"reference/#framcore.components.Thermal","title":"<code>Thermal</code>","text":""},{"location":"reference/#framcore.components.Thermal.Thermal","title":"<code>Thermal</code>","text":"<p>               Bases: <code>_PowerPlant</code></p> <p>Represents a thermal power plant, subclassing PowerPlant.</p> <p>This class models a thermal power plant with attributes inherited from PowerPlant. Additionally, it includes specific attributes such as:</p> <ul> <li>fuel node</li> <li>efficiency</li> <li>emission node</li> <li>emission coefficient</li> <li>startup costs</li> </ul> <p>This class is compatible with ThermalAggregator.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>class Thermal(_PowerPlant):\n    \"\"\"\n    Represents a thermal power plant, subclassing PowerPlant.\n\n    This class models a thermal power plant with attributes inherited from PowerPlant.\n    Additionally, it includes specific attributes such as:\n\n    - fuel node\n    - efficiency\n    - emission node\n    - emission coefficient\n    - startup costs\n\n\n    This class is compatible with ThermalAggregator.\n    \"\"\"\n\n    def __init__(\n        self,\n        power_node: str,\n        fuel_node: str,\n        efficiency: Efficiency,\n        max_capacity: FlowVolume,\n        emission_node: str | None = None,\n        emission_coefficient: Conversion | None = None,\n        startupcost: StartUpCost | None = None,\n        min_capacity: FlowVolume | None = None,\n        voc: Cost | None = None,\n        production: AvgFlowVolume | None = None,\n        fuel_demand: AvgFlowVolume | None = None,\n        emission_demand: AvgFlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a Thermal power plant instance.\n\n        Args:\n            power_node (str): The power node of the plant.\n            fuel_node (str): The fuel node of the plant.\n            efficiency (Efficiency): Efficiency of the plant.\n            emission_node (str | None, optional): Emission node.\n            emission_coefficient (Conversion | None, optional): Emission coefficient.\n            startupcost (StartUpCost | None, optional): Cost associated with starting up the Plant.\n            max_capacity (FlowVolume | None, optional): Maximum production capacity.\n            min_capacity (FlowVolume | None, optional): Minimum production capacity.\n            voc (Cost | None, optional): Variable operating cost.\n            production (AvgFlowVolume | None, optional): Production volume.\n            fuel_demand (AvgFlowVolume | None, optional): Fuel demand.\n            emission_demand (AvgFlowVolume | None, optional): Emission demand.\n\n        \"\"\"\n        super().__init__(\n            power_node=power_node,\n            max_capacity=max_capacity,\n            min_capacity=min_capacity,\n            voc=voc,\n            production=production,\n        )\n\n        self._check_type(fuel_node, str)\n        self._check_type(emission_node, (str, type(None)))\n        self._check_type(emission_coefficient, (Conversion, type(None)))\n        self._check_type(startupcost, (StartUpCost, type(None)))\n        self._check_type(production, (AvgFlowVolume, type(None)))\n        self._check_type(fuel_demand, (AvgFlowVolume, type(None)))\n        self._check_type(emission_demand, (AvgFlowVolume, type(None)))\n\n        self._fuel_node = fuel_node\n        self._efficiency = efficiency\n        self._emission_node = emission_node\n        self._emission_coefficient = emission_coefficient\n        self._startupcost = startupcost\n\n        if production is None:\n            production = AvgFlowVolume()\n\n        if fuel_demand is None:\n            fuel_demand = AvgFlowVolume()\n\n        if emission_demand is None and emission_node is not None:\n            emission_demand = AvgFlowVolume()\n\n        self._production = production\n        self._fuel_demand = fuel_demand\n        self._emission_demand = emission_demand\n\n    def get_fuel_node(self) -&gt; str:\n        \"\"\"Get the fuel node of the thermal unit.\"\"\"\n        return self._fuel_node\n\n    def set_fuel_node(self, fuel_node: str) -&gt; None:\n        \"\"\"Set the fuel node of the thermal unit.\"\"\"\n        self._check_type(fuel_node, str)\n        self._fuel_node = fuel_node\n\n    def get_emission_node(self) -&gt; str | None:\n        \"\"\"Get the emission node of the thermal unit.\"\"\"\n        return self._emission_node\n\n    def set_emission_node(self, emission_node: str | None) -&gt; None:\n        \"\"\"Set the emission node of the thermal unit.\"\"\"\n        self._check_type(emission_node, (str, type(None)))\n        self._emission_node = emission_node\n\n    def get_emission_coefficient(self) -&gt; Conversion | None:\n        \"\"\"Get the emission coefficient of the thermal unit.\"\"\"\n        return self._emission_coefficient\n\n    def set_emission_coefficient(self, emission_coefficient: Conversion | None) -&gt; None:\n        \"\"\"Set the emission coefficient of the thermal unit.\"\"\"\n        self._check_type(emission_coefficient, (Conversion, type(None)))\n        self._emission_coefficient = emission_coefficient\n\n    def get_fuel_demand(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the fuel demand of the thermal unit.\"\"\"\n        return self._fuel_demand\n\n    def get_emission_demand(self) -&gt; AvgFlowVolume | None:\n        \"\"\"Get the emission demand of the thermal unit.\"\"\"\n        return self._emission_demand\n\n    def set_emission_demand(self, value: AvgFlowVolume | None) -&gt; None:\n        \"\"\"Set the emission demand of the thermal unit.\"\"\"\n        self._check_type(value, (AvgFlowVolume, type(None)))\n        self._emission_demand = value\n\n    def get_efficiency(self) -&gt; Efficiency:\n        \"\"\"Get the efficiency of the thermal unit.\"\"\"\n        return self._efficiency\n\n    def get_startupcost(self) -&gt; StartUpCost | None:\n        \"\"\"Get the startup cost of the thermal unit.\"\"\"\n        return self._startupcost\n\n    def set_startupcost(self, startupcost: StartUpCost | None) -&gt; None:\n        \"\"\"Set the startup cost of the thermal unit.\"\"\"\n        self._check_type(startupcost, (StartUpCost, type(None)))\n        self._startupcost = startupcost\n\n    \"\"\"Implementation of Component interface\"\"\"\n\n    def _get_simpler_components(self, base_name: str) -&gt; dict[str, Component]:\n        return {base_name + \"_Flow\": self._create_flow()}\n\n    def _replace_node(self, old: str, new: str) -&gt; None:\n        existing_nodes = [self._power_node, self._fuel_node]\n        existing_nodes = existing_nodes if self._emission_node is None else [*existing_nodes, self._emission_node]\n        if old not in existing_nodes:\n            message = f\"{old} not found in {self}. Expected one of the existing nodes {existing_nodes}.\"\n            raise ValueError(message)\n\n        if self._power_node == old:\n            self._power_node = new\n        if self._fuel_node == old:\n            self._fuel_node = new\n        if (self._emission_node is not None) and (old == self._emission_node):\n            self._emission_node = new\n\n    def _create_flow(self) -&gt; Flow:\n        arrow_volumes: dict[Arrow, AvgFlowVolume] = dict()\n\n        is_exogenous = self._max_capacity == self._min_capacity\n\n        flow = Flow(\n            main_node=self._power_node,\n            max_capacity=self._max_capacity,\n            min_capacity=self._min_capacity,\n            startupcost=self._startupcost,\n            volume=self._production,\n            arrow_volumes=arrow_volumes,\n            is_exogenous=is_exogenous,\n        )\n\n        power_arrow = Arrow(\n            node=self._power_node,\n            is_ingoing=True,\n            conversion=Conversion(value=1),\n        )\n        flow.add_arrow(power_arrow)\n\n        fuel_arrow = Arrow(\n            node=self._fuel_node,\n            is_ingoing=False,\n            efficiency=self._efficiency,\n        )\n        flow.add_arrow(fuel_arrow)\n        arrow_volumes[fuel_arrow] = self._fuel_demand\n\n        if self._emission_node is not None:\n            if self._emission_demand is None:\n                self._emission_demand = AvgFlowVolume()\n            emission_arrow = Arrow(\n                node=self._emission_node,\n                is_ingoing=False,\n                conversion=self._emission_coefficient,\n                efficiency=self._efficiency,\n            )\n            flow.add_arrow(emission_arrow)\n            arrow_volumes[emission_arrow] = self._emission_demand\n\n        if self._voc:\n            flow.add_cost_term(\"VOC\", self._voc)\n\n        return flow\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.__init__","title":"<code>__init__(power_node: str, fuel_node: str, efficiency: Efficiency, max_capacity: FlowVolume, emission_node: str | None = None, emission_coefficient: Conversion | None = None, startupcost: StartUpCost | None = None, min_capacity: FlowVolume | None = None, voc: Cost | None = None, production: AvgFlowVolume | None = None, fuel_demand: AvgFlowVolume | None = None, emission_demand: AvgFlowVolume | None = None) -&gt; None</code>","text":"<p>Initialize a Thermal power plant instance.</p> <p>Parameters:</p> Name Type Description Default <code>power_node</code> <code>str</code> <p>The power node of the plant.</p> required <code>fuel_node</code> <code>str</code> <p>The fuel node of the plant.</p> required <code>efficiency</code> <code>Efficiency</code> <p>Efficiency of the plant.</p> required <code>emission_node</code> <code>str | None</code> <p>Emission node.</p> <code>None</code> <code>emission_coefficient</code> <code>Conversion | None</code> <p>Emission coefficient.</p> <code>None</code> <code>startupcost</code> <code>StartUpCost | None</code> <p>Cost associated with starting up the Plant.</p> <code>None</code> <code>max_capacity</code> <code>FlowVolume | None</code> <p>Maximum production capacity.</p> required <code>min_capacity</code> <code>FlowVolume | None</code> <p>Minimum production capacity.</p> <code>None</code> <code>voc</code> <code>Cost | None</code> <p>Variable operating cost.</p> <code>None</code> <code>production</code> <code>AvgFlowVolume | None</code> <p>Production volume.</p> <code>None</code> <code>fuel_demand</code> <code>AvgFlowVolume | None</code> <p>Fuel demand.</p> <code>None</code> <code>emission_demand</code> <code>AvgFlowVolume | None</code> <p>Emission demand.</p> <code>None</code> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def __init__(\n    self,\n    power_node: str,\n    fuel_node: str,\n    efficiency: Efficiency,\n    max_capacity: FlowVolume,\n    emission_node: str | None = None,\n    emission_coefficient: Conversion | None = None,\n    startupcost: StartUpCost | None = None,\n    min_capacity: FlowVolume | None = None,\n    voc: Cost | None = None,\n    production: AvgFlowVolume | None = None,\n    fuel_demand: AvgFlowVolume | None = None,\n    emission_demand: AvgFlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a Thermal power plant instance.\n\n    Args:\n        power_node (str): The power node of the plant.\n        fuel_node (str): The fuel node of the plant.\n        efficiency (Efficiency): Efficiency of the plant.\n        emission_node (str | None, optional): Emission node.\n        emission_coefficient (Conversion | None, optional): Emission coefficient.\n        startupcost (StartUpCost | None, optional): Cost associated with starting up the Plant.\n        max_capacity (FlowVolume | None, optional): Maximum production capacity.\n        min_capacity (FlowVolume | None, optional): Minimum production capacity.\n        voc (Cost | None, optional): Variable operating cost.\n        production (AvgFlowVolume | None, optional): Production volume.\n        fuel_demand (AvgFlowVolume | None, optional): Fuel demand.\n        emission_demand (AvgFlowVolume | None, optional): Emission demand.\n\n    \"\"\"\n    super().__init__(\n        power_node=power_node,\n        max_capacity=max_capacity,\n        min_capacity=min_capacity,\n        voc=voc,\n        production=production,\n    )\n\n    self._check_type(fuel_node, str)\n    self._check_type(emission_node, (str, type(None)))\n    self._check_type(emission_coefficient, (Conversion, type(None)))\n    self._check_type(startupcost, (StartUpCost, type(None)))\n    self._check_type(production, (AvgFlowVolume, type(None)))\n    self._check_type(fuel_demand, (AvgFlowVolume, type(None)))\n    self._check_type(emission_demand, (AvgFlowVolume, type(None)))\n\n    self._fuel_node = fuel_node\n    self._efficiency = efficiency\n    self._emission_node = emission_node\n    self._emission_coefficient = emission_coefficient\n    self._startupcost = startupcost\n\n    if production is None:\n        production = AvgFlowVolume()\n\n    if fuel_demand is None:\n        fuel_demand = AvgFlowVolume()\n\n    if emission_demand is None and emission_node is not None:\n        emission_demand = AvgFlowVolume()\n\n    self._production = production\n    self._fuel_demand = fuel_demand\n    self._emission_demand = emission_demand\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.get_efficiency","title":"<code>get_efficiency() -&gt; Efficiency</code>","text":"<p>Get the efficiency of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def get_efficiency(self) -&gt; Efficiency:\n    \"\"\"Get the efficiency of the thermal unit.\"\"\"\n    return self._efficiency\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.get_emission_coefficient","title":"<code>get_emission_coefficient() -&gt; Conversion | None</code>","text":"<p>Get the emission coefficient of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def get_emission_coefficient(self) -&gt; Conversion | None:\n    \"\"\"Get the emission coefficient of the thermal unit.\"\"\"\n    return self._emission_coefficient\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.get_emission_demand","title":"<code>get_emission_demand() -&gt; AvgFlowVolume | None</code>","text":"<p>Get the emission demand of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def get_emission_demand(self) -&gt; AvgFlowVolume | None:\n    \"\"\"Get the emission demand of the thermal unit.\"\"\"\n    return self._emission_demand\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.get_emission_node","title":"<code>get_emission_node() -&gt; str | None</code>","text":"<p>Get the emission node of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def get_emission_node(self) -&gt; str | None:\n    \"\"\"Get the emission node of the thermal unit.\"\"\"\n    return self._emission_node\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.get_fuel_demand","title":"<code>get_fuel_demand() -&gt; AvgFlowVolume</code>","text":"<p>Get the fuel demand of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def get_fuel_demand(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the fuel demand of the thermal unit.\"\"\"\n    return self._fuel_demand\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.get_fuel_node","title":"<code>get_fuel_node() -&gt; str</code>","text":"<p>Get the fuel node of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def get_fuel_node(self) -&gt; str:\n    \"\"\"Get the fuel node of the thermal unit.\"\"\"\n    return self._fuel_node\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.get_startupcost","title":"<code>get_startupcost() -&gt; StartUpCost | None</code>","text":"<p>Get the startup cost of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def get_startupcost(self) -&gt; StartUpCost | None:\n    \"\"\"Get the startup cost of the thermal unit.\"\"\"\n    return self._startupcost\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.set_emission_coefficient","title":"<code>set_emission_coefficient(emission_coefficient: Conversion | None) -&gt; None</code>","text":"<p>Set the emission coefficient of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def set_emission_coefficient(self, emission_coefficient: Conversion | None) -&gt; None:\n    \"\"\"Set the emission coefficient of the thermal unit.\"\"\"\n    self._check_type(emission_coefficient, (Conversion, type(None)))\n    self._emission_coefficient = emission_coefficient\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.set_emission_demand","title":"<code>set_emission_demand(value: AvgFlowVolume | None) -&gt; None</code>","text":"<p>Set the emission demand of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def set_emission_demand(self, value: AvgFlowVolume | None) -&gt; None:\n    \"\"\"Set the emission demand of the thermal unit.\"\"\"\n    self._check_type(value, (AvgFlowVolume, type(None)))\n    self._emission_demand = value\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.set_emission_node","title":"<code>set_emission_node(emission_node: str | None) -&gt; None</code>","text":"<p>Set the emission node of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def set_emission_node(self, emission_node: str | None) -&gt; None:\n    \"\"\"Set the emission node of the thermal unit.\"\"\"\n    self._check_type(emission_node, (str, type(None)))\n    self._emission_node = emission_node\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.set_fuel_node","title":"<code>set_fuel_node(fuel_node: str) -&gt; None</code>","text":"<p>Set the fuel node of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def set_fuel_node(self, fuel_node: str) -&gt; None:\n    \"\"\"Set the fuel node of the thermal unit.\"\"\"\n    self._check_type(fuel_node, str)\n    self._fuel_node = fuel_node\n</code></pre>"},{"location":"reference/#framcore.components.Thermal.Thermal.set_startupcost","title":"<code>set_startupcost(startupcost: StartUpCost | None) -&gt; None</code>","text":"<p>Set the startup cost of the thermal unit.</p> Source code in <code>framcore/components/Thermal.py</code> <pre><code>def set_startupcost(self, startupcost: StartUpCost | None) -&gt; None:\n    \"\"\"Set the startup cost of the thermal unit.\"\"\"\n    self._check_type(startupcost, (StartUpCost, type(None)))\n    self._startupcost = startupcost\n</code></pre>"},{"location":"reference/#framcore.components.Transmission","title":"<code>Transmission</code>","text":"<p>Contain class describing transmission of Power commodity between nodes.</p>"},{"location":"reference/#framcore.components.Transmission.Transmission","title":"<code>Transmission</code>","text":"<p>               Bases: <code>Component</code></p> <p>Transmission component representing a one directional transmission line. Subclass of Component.</p> <p>An object of this class represents one transmission line where power flows one direction (the other direction is represented by another Transmission object). However, the actual measured power being sent can be higher than the amount being recieved because of loss. One Transmission object therefore represents the viewpoints of both the sender and the reciever of power on this specific line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>class Transmission(Component):\n    \"\"\"\n    Transmission component representing a one directional transmission line. Subclass of Component.\n\n    An object of this class represents one transmission line where power flows one direction (the other direction is\n    represented by another Transmission object). However, the actual measured power being sent can be higher than the\n    amount being recieved because of loss. One Transmission object therefore represents the viewpoints of both the\n    sender and the reciever of power on this specific line.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        from_node: str,\n        to_node: str,\n        max_capacity: FlowVolume = None,\n        min_capacity: FlowVolume | None = None,\n        loss: Loss | None = None,\n        tariff: Cost | None = None,\n        ramp_up: Proportion | None = None,\n        ramp_down: Proportion | None = None,\n        ingoing_volume: AvgFlowVolume | None = None,\n        outgoing_volume: AvgFlowVolume | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize object of the Transmission class. Perform type checks and convert arguments to expressions.\n\n        Args:\n            from_node (str): Node which power is transported from.\n            to_node (str): Destination Node.\n            max_capacity (FlowVolume, optional): Maximum transmission capacity. Defaults to None.\n            min_capacity (FlowVolume | None, optional): Minimum transmission capacity. Defaults to None.\n            loss (Loss | None, optional): Amount of power lost while transmitting. Defaults to None.\n            tariff (Cost | None, optional): Costs associated with operating this transmission line. Defaults to None.\n            ramp_up (Proportion | None, optional): Max upwards change in transmission per time. Defaults to None.\n            ramp_down (Proportion | None, optional): Max downwards change in transmission per time. Defaults to None.\n            ingoing_volume (AvgFlowVolume | None, optional): Volume of power recieved by to_node. Defaults to None.\n            outgoing_volume (AvgFlowVolume | None, optional): Volume of power sent by from_node. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n\n        self._check_type(from_node, str)\n        self._check_type(to_node, str)\n        self._check_type(max_capacity, FlowVolume)\n        self._check_type(min_capacity, (FlowVolume, type(None)))\n        self._check_type(loss, (Loss, type(None)))\n        self._check_type(tariff, (Cost, type(None)))\n        self._check_type(ramp_up, (Proportion, type(None)))\n        self._check_type(ramp_down, (Proportion, type(None)))\n        self._check_type(ingoing_volume, (AvgFlowVolume, type(None)))\n        self._check_type(outgoing_volume, (AvgFlowVolume, type(None)))\n\n        self._from_node = from_node\n        self._to_node = to_node\n        self._max_capacity = max_capacity\n        self._min_capacity = min_capacity\n        self._loss = loss\n        self._tariff = tariff\n        self._ramp_up = ramp_up\n        self._ramp_down = ramp_down\n\n        if outgoing_volume is None:\n            outgoing_volume = AvgFlowVolume()\n\n        if ingoing_volume is None:\n            ingoing_volume = AvgFlowVolume()\n\n        self._outgoing_volume: AvgFlowVolume = outgoing_volume\n        self._ingoing_volume: AvgFlowVolume = ingoing_volume\n\n    def get_from_node(self) -&gt; str:\n        \"\"\"Get the from node of the transmission line.\"\"\"\n        return self._from_node\n\n    def set_from_node(self, node: str) -&gt; None:\n        \"\"\"Set the from node of the transmission line.\"\"\"\n        self._check_type(node, str)\n        self._from_node = node\n\n    def get_to_node(self) -&gt; str:\n        \"\"\"Get the to node of the transmission line.\"\"\"\n        return self._to_node\n\n    def set_to_node(self, node: str) -&gt; None:\n        \"\"\"Set the to node of the transmission line.\"\"\"\n        self._check_type(node, str)\n        self._to_node = node\n\n    def get_max_capacity(self) -&gt; FlowVolume:\n        \"\"\"Get the maximum capacity (before losses) of the transmission line.\"\"\"\n        return self._max_capacity\n\n    def get_min_capacity(self) -&gt; FlowVolume:\n        \"\"\"Get the minimum capacity (before losses) of the transmission line.\"\"\"\n        return self._min_capacity\n\n    def set_min_capacity(self, value: FlowVolume | None) -&gt; None:\n        \"\"\"Set the minimum capacity (before losses) of the transmission line.\"\"\"\n        self._check_type(value, (FlowVolume, type(None)))\n        self._min_capacity = value\n\n    def get_outgoing_volume(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the outgoing (before losses) flow volume of the transmission line.\"\"\"\n        return self._outgoing_volume\n\n    def get_ingoing_volume(self) -&gt; AvgFlowVolume:\n        \"\"\"Get the ingoing (after losses) flow volume of the transmission line.\"\"\"\n        return self._ingoing_volume\n\n    def get_loss(self) -&gt; Loss | None:\n        \"\"\"Get the loss of the transmission line.\"\"\"\n        return self._loss\n\n    def set_loss(self, loss: Loss | None) -&gt; None:\n        \"\"\"Set the loss of the transmission line.\"\"\"\n        self._check_type(loss, (Loss, type(None)))\n        self._loss = loss\n\n    def get_tariff(self) -&gt; Cost | None:\n        \"\"\"Get the tariff of the transmission line.\"\"\"\n        return self._tariff\n\n    def set_tariff(self, tariff: Cost | None) -&gt; None:\n        \"\"\"Set the tariff of the transmission line.\"\"\"\n        self._check_type(tariff, (Cost, type(None)))\n        self._tariff = tariff\n\n    def get_ramp_up(self) -&gt; Proportion | None:\n        \"\"\"Get the ramp up profile level of the transmission line.\"\"\"\n        return self._ramp_up\n\n    def set_ramp_up(self, value: Proportion | None) -&gt; None:\n        \"\"\"Set the ramp up of the transmission line.\"\"\"\n        self._check_type(value, (Proportion, type(None)))\n        self._ramp_up = value\n\n    def get_ramp_down(self) -&gt; Proportion | None:\n        \"\"\"Get the ramp down of the transmission line.\"\"\"\n        return self._ramp_down\n\n    def set_ramp_down(self, value: Proportion | None) -&gt; None:\n        \"\"\"Set the ramp down of the transmission line.\"\"\"\n        self._check_type(value, (Proportion, type(None)))\n        self._ramp_down = value\n\n    \"\"\"Implementation of Component interface\"\"\"\n\n    def _get_simpler_components(self, base_name: str) -&gt; dict[str, Component]:\n        return {base_name + \"_Flow\": self._create_flow()}\n\n    def _replace_node(self, old: str, new: str) -&gt; None:\n        if old == self._from_node:\n            self._from_node = new\n        if old == self._to_node:\n            self._to_node = new\n\n    def _create_flow(self) -&gt; Flow:\n        arrow_volumes: dict[Arrow, FlowVolume] = dict()\n\n        flow = Flow(\n            main_node=self._from_node,\n            max_capacity=self._max_capacity,\n            volume=self._outgoing_volume,\n            arrow_volumes=arrow_volumes,\n            # ramp_up=self._ramp_up,    # TODO\n            # ramp_down=self._ramp_up,  # TODO\n        )\n\n        outgoing_arrow = Arrow(\n            node=self._from_node,\n            is_ingoing=False,\n            conversion=Conversion(value=1),\n        )\n        flow.add_arrow(outgoing_arrow)\n        arrow_volumes[outgoing_arrow] = self._outgoing_volume\n\n        # TODO: Extend Loss to support more fetures, such as quadratic losses? Needs loss param in Arrow to do this\n\n        ingoing_arrow = Arrow(\n            node=self._to_node,\n            is_ingoing=True,\n            conversion=Conversion(value=1),\n            loss=self._loss,\n        )\n        flow.add_arrow(ingoing_arrow)\n        arrow_volumes[ingoing_arrow] = self._ingoing_volume\n\n        if self._tariff is not None:\n            flow.add_cost_term(\"tariff\", self._tariff)\n\n        return flow\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.__init__","title":"<code>__init__(from_node: str, to_node: str, max_capacity: FlowVolume = None, min_capacity: FlowVolume | None = None, loss: Loss | None = None, tariff: Cost | None = None, ramp_up: Proportion | None = None, ramp_down: Proportion | None = None, ingoing_volume: AvgFlowVolume | None = None, outgoing_volume: AvgFlowVolume | None = None) -&gt; None</code>","text":"<p>Initialize object of the Transmission class. Perform type checks and convert arguments to expressions.</p> <p>Parameters:</p> Name Type Description Default <code>from_node</code> <code>str</code> <p>Node which power is transported from.</p> required <code>to_node</code> <code>str</code> <p>Destination Node.</p> required <code>max_capacity</code> <code>FlowVolume</code> <p>Maximum transmission capacity. Defaults to None.</p> <code>None</code> <code>min_capacity</code> <code>FlowVolume | None</code> <p>Minimum transmission capacity. Defaults to None.</p> <code>None</code> <code>loss</code> <code>Loss | None</code> <p>Amount of power lost while transmitting. Defaults to None.</p> <code>None</code> <code>tariff</code> <code>Cost | None</code> <p>Costs associated with operating this transmission line. Defaults to None.</p> <code>None</code> <code>ramp_up</code> <code>Proportion | None</code> <p>Max upwards change in transmission per time. Defaults to None.</p> <code>None</code> <code>ramp_down</code> <code>Proportion | None</code> <p>Max downwards change in transmission per time. Defaults to None.</p> <code>None</code> <code>ingoing_volume</code> <code>AvgFlowVolume | None</code> <p>Volume of power recieved by to_node. Defaults to None.</p> <code>None</code> <code>outgoing_volume</code> <code>AvgFlowVolume | None</code> <p>Volume of power sent by from_node. Defaults to None.</p> <code>None</code> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def __init__(\n    self,\n    from_node: str,\n    to_node: str,\n    max_capacity: FlowVolume = None,\n    min_capacity: FlowVolume | None = None,\n    loss: Loss | None = None,\n    tariff: Cost | None = None,\n    ramp_up: Proportion | None = None,\n    ramp_down: Proportion | None = None,\n    ingoing_volume: AvgFlowVolume | None = None,\n    outgoing_volume: AvgFlowVolume | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize object of the Transmission class. Perform type checks and convert arguments to expressions.\n\n    Args:\n        from_node (str): Node which power is transported from.\n        to_node (str): Destination Node.\n        max_capacity (FlowVolume, optional): Maximum transmission capacity. Defaults to None.\n        min_capacity (FlowVolume | None, optional): Minimum transmission capacity. Defaults to None.\n        loss (Loss | None, optional): Amount of power lost while transmitting. Defaults to None.\n        tariff (Cost | None, optional): Costs associated with operating this transmission line. Defaults to None.\n        ramp_up (Proportion | None, optional): Max upwards change in transmission per time. Defaults to None.\n        ramp_down (Proportion | None, optional): Max downwards change in transmission per time. Defaults to None.\n        ingoing_volume (AvgFlowVolume | None, optional): Volume of power recieved by to_node. Defaults to None.\n        outgoing_volume (AvgFlowVolume | None, optional): Volume of power sent by from_node. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n\n    self._check_type(from_node, str)\n    self._check_type(to_node, str)\n    self._check_type(max_capacity, FlowVolume)\n    self._check_type(min_capacity, (FlowVolume, type(None)))\n    self._check_type(loss, (Loss, type(None)))\n    self._check_type(tariff, (Cost, type(None)))\n    self._check_type(ramp_up, (Proportion, type(None)))\n    self._check_type(ramp_down, (Proportion, type(None)))\n    self._check_type(ingoing_volume, (AvgFlowVolume, type(None)))\n    self._check_type(outgoing_volume, (AvgFlowVolume, type(None)))\n\n    self._from_node = from_node\n    self._to_node = to_node\n    self._max_capacity = max_capacity\n    self._min_capacity = min_capacity\n    self._loss = loss\n    self._tariff = tariff\n    self._ramp_up = ramp_up\n    self._ramp_down = ramp_down\n\n    if outgoing_volume is None:\n        outgoing_volume = AvgFlowVolume()\n\n    if ingoing_volume is None:\n        ingoing_volume = AvgFlowVolume()\n\n    self._outgoing_volume: AvgFlowVolume = outgoing_volume\n    self._ingoing_volume: AvgFlowVolume = ingoing_volume\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_from_node","title":"<code>get_from_node() -&gt; str</code>","text":"<p>Get the from node of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_from_node(self) -&gt; str:\n    \"\"\"Get the from node of the transmission line.\"\"\"\n    return self._from_node\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_ingoing_volume","title":"<code>get_ingoing_volume() -&gt; AvgFlowVolume</code>","text":"<p>Get the ingoing (after losses) flow volume of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_ingoing_volume(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the ingoing (after losses) flow volume of the transmission line.\"\"\"\n    return self._ingoing_volume\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_loss","title":"<code>get_loss() -&gt; Loss | None</code>","text":"<p>Get the loss of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_loss(self) -&gt; Loss | None:\n    \"\"\"Get the loss of the transmission line.\"\"\"\n    return self._loss\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_max_capacity","title":"<code>get_max_capacity() -&gt; FlowVolume</code>","text":"<p>Get the maximum capacity (before losses) of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_max_capacity(self) -&gt; FlowVolume:\n    \"\"\"Get the maximum capacity (before losses) of the transmission line.\"\"\"\n    return self._max_capacity\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_min_capacity","title":"<code>get_min_capacity() -&gt; FlowVolume</code>","text":"<p>Get the minimum capacity (before losses) of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_min_capacity(self) -&gt; FlowVolume:\n    \"\"\"Get the minimum capacity (before losses) of the transmission line.\"\"\"\n    return self._min_capacity\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_outgoing_volume","title":"<code>get_outgoing_volume() -&gt; AvgFlowVolume</code>","text":"<p>Get the outgoing (before losses) flow volume of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_outgoing_volume(self) -&gt; AvgFlowVolume:\n    \"\"\"Get the outgoing (before losses) flow volume of the transmission line.\"\"\"\n    return self._outgoing_volume\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_ramp_down","title":"<code>get_ramp_down() -&gt; Proportion | None</code>","text":"<p>Get the ramp down of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_ramp_down(self) -&gt; Proportion | None:\n    \"\"\"Get the ramp down of the transmission line.\"\"\"\n    return self._ramp_down\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_ramp_up","title":"<code>get_ramp_up() -&gt; Proportion | None</code>","text":"<p>Get the ramp up profile level of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_ramp_up(self) -&gt; Proportion | None:\n    \"\"\"Get the ramp up profile level of the transmission line.\"\"\"\n    return self._ramp_up\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_tariff","title":"<code>get_tariff() -&gt; Cost | None</code>","text":"<p>Get the tariff of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_tariff(self) -&gt; Cost | None:\n    \"\"\"Get the tariff of the transmission line.\"\"\"\n    return self._tariff\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.get_to_node","title":"<code>get_to_node() -&gt; str</code>","text":"<p>Get the to node of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def get_to_node(self) -&gt; str:\n    \"\"\"Get the to node of the transmission line.\"\"\"\n    return self._to_node\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.set_from_node","title":"<code>set_from_node(node: str) -&gt; None</code>","text":"<p>Set the from node of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def set_from_node(self, node: str) -&gt; None:\n    \"\"\"Set the from node of the transmission line.\"\"\"\n    self._check_type(node, str)\n    self._from_node = node\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.set_loss","title":"<code>set_loss(loss: Loss | None) -&gt; None</code>","text":"<p>Set the loss of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def set_loss(self, loss: Loss | None) -&gt; None:\n    \"\"\"Set the loss of the transmission line.\"\"\"\n    self._check_type(loss, (Loss, type(None)))\n    self._loss = loss\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.set_min_capacity","title":"<code>set_min_capacity(value: FlowVolume | None) -&gt; None</code>","text":"<p>Set the minimum capacity (before losses) of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def set_min_capacity(self, value: FlowVolume | None) -&gt; None:\n    \"\"\"Set the minimum capacity (before losses) of the transmission line.\"\"\"\n    self._check_type(value, (FlowVolume, type(None)))\n    self._min_capacity = value\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.set_ramp_down","title":"<code>set_ramp_down(value: Proportion | None) -&gt; None</code>","text":"<p>Set the ramp down of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def set_ramp_down(self, value: Proportion | None) -&gt; None:\n    \"\"\"Set the ramp down of the transmission line.\"\"\"\n    self._check_type(value, (Proportion, type(None)))\n    self._ramp_down = value\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.set_ramp_up","title":"<code>set_ramp_up(value: Proportion | None) -&gt; None</code>","text":"<p>Set the ramp up of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def set_ramp_up(self, value: Proportion | None) -&gt; None:\n    \"\"\"Set the ramp up of the transmission line.\"\"\"\n    self._check_type(value, (Proportion, type(None)))\n    self._ramp_up = value\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.set_tariff","title":"<code>set_tariff(tariff: Cost | None) -&gt; None</code>","text":"<p>Set the tariff of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def set_tariff(self, tariff: Cost | None) -&gt; None:\n    \"\"\"Set the tariff of the transmission line.\"\"\"\n    self._check_type(tariff, (Cost, type(None)))\n    self._tariff = tariff\n</code></pre>"},{"location":"reference/#framcore.components.Transmission.Transmission.set_to_node","title":"<code>set_to_node(node: str) -&gt; None</code>","text":"<p>Set the to node of the transmission line.</p> Source code in <code>framcore/components/Transmission.py</code> <pre><code>def set_to_node(self, node: str) -&gt; None:\n    \"\"\"Set the to node of the transmission line.\"\"\"\n    self._check_type(node, str)\n    self._to_node = node\n</code></pre>"},{"location":"reference/#framcore.components.wind_solar","title":"<code>wind_solar</code>","text":""},{"location":"reference/#framcore.components.wind_solar.Solar","title":"<code>Solar</code>","text":"<p>               Bases: <code>_WindSolar</code></p> <p>Solar power component.</p> <p>Has attributes for power node, capacity, variable operation cost, and production.</p> <p>Compatible with WindSolarAggregator.</p> Source code in <code>framcore/components/wind_solar.py</code> <pre><code>class Solar(_WindSolar):\n    \"\"\"\n    Solar power component.\n\n    Has attributes for power node, capacity, variable operation cost, and production.\n\n    Compatible with WindSolarAggregator.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#framcore.components.wind_solar.Wind","title":"<code>Wind</code>","text":"<p>               Bases: <code>_WindSolar</code></p> <p>Wind power component.</p> <p>Has attributes for power node, capacity, variable operation cost, and production.</p> <p>Compatible with WindSolarAggregator.</p> Source code in <code>framcore/components/wind_solar.py</code> <pre><code>class Wind(_WindSolar):\n    \"\"\"\n    Wind power component.\n\n    Has attributes for power node, capacity, variable operation cost, and production.\n\n    Compatible with WindSolarAggregator.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#framcore.curves","title":"<code>curves</code>","text":""},{"location":"reference/#framcore.curves.Curve","title":"<code>Curve</code>","text":"<p>Curve interface.</p>"},{"location":"reference/#framcore.curves.Curve.Curve","title":"<code>Curve</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Curve interface class.</p> Source code in <code>framcore/curves/Curve.py</code> <pre><code>class Curve(Base, ABC):\n    \"\"\"Curve interface class.\"\"\"\n\n    @abstractmethod\n    def get_unique_name(self) -&gt; str | None:\n        \"\"\"Return unique name of curve.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_x_axis(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"\n        Get array of x axis values.\n\n        Args:\n            is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n        Returns:\n            NDArray: Numpy array of values.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_y_axis(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"\n        Get array of y axis values.\n\n        Args:\n            is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n        Returns:\n            NDArray: Numpy array of values.\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#framcore.curves.Curve.Curve.get_unique_name","title":"<code>get_unique_name() -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Return unique name of curve.</p> Source code in <code>framcore/curves/Curve.py</code> <pre><code>@abstractmethod\ndef get_unique_name(self) -&gt; str | None:\n    \"\"\"Return unique name of curve.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.curves.Curve.Curve.get_x_axis","title":"<code>get_x_axis(is_float32: bool) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Get array of x axis values.</p> <p>Parameters:</p> Name Type Description Default <code>is_float32</code> <code>bool</code> <p>Flag for converting the array of values to numpy float32.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of values.</p> Source code in <code>framcore/curves/Curve.py</code> <pre><code>@abstractmethod\ndef get_x_axis(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"\n    Get array of x axis values.\n\n    Args:\n        is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n    Returns:\n        NDArray: Numpy array of values.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.curves.Curve.Curve.get_y_axis","title":"<code>get_y_axis(is_float32: bool) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Get array of y axis values.</p> <p>Parameters:</p> Name Type Description Default <code>is_float32</code> <code>bool</code> <p>Flag for converting the array of values to numpy float32.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of values.</p> Source code in <code>framcore/curves/Curve.py</code> <pre><code>@abstractmethod\ndef get_y_axis(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"\n    Get array of y axis values.\n\n    Args:\n        is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n    Returns:\n        NDArray: Numpy array of values.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve","title":"<code>LoadedCurve</code>","text":""},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve","title":"<code>LoadedCurve</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Represents a curve loaded from a CurveLoader.</p>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve--methods","title":"Methods","text":"<p>get_unique_name()     Returns the unique name of the curve. get_x_axis(precision=None)     Returns the x-axis data. get_y_axis(precision=None)     Returns the y-axis data. get_x_unit()     Returns the unit for the x-axis. get_y_unit()     Returns the unit for the y-axis. get_loader()     Returns the loader instance. get_fingerprint()     Returns the fingerprint of the curve.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>class LoadedCurve(Curve):\n    \"\"\"\n    Represents a curve loaded from a CurveLoader.\n\n    Methods\n    -------\n    get_unique_name()\n        Returns the unique name of the curve.\n    get_x_axis(precision=None)\n        Returns the x-axis data.\n    get_y_axis(precision=None)\n        Returns the y-axis data.\n    get_x_unit()\n        Returns the unit for the x-axis.\n    get_y_unit()\n        Returns the unit for the y-axis.\n    get_loader()\n        Returns the loader instance.\n    get_fingerprint()\n        Returns the fingerprint of the curve.\n\n    \"\"\"\n\n    def __init__(self, curve_id: str, loader: CurveLoader) -&gt; None:\n        \"\"\"\n        Initialize a LoadedCurve instance.\n\n        Parameters\n        ----------\n        curve_id : str\n            Identifier for the curve.\n        loader : CurveLoader\n            Loader instance used to retrieve curve data.\n\n        \"\"\"\n        self._curve_id = curve_id\n        self._loader = loader\n\n        # TODO: get from loader\n        self._reference_period = None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the LoadedCurve instance.\"\"\"\n        return f\"{type(self).__name__}(curve_id={self._curve_id},loader={self._loader},x_unit={self.get_x_unit()}),y_unit={self.get_y_unit()}),\"\n\n    def get_unique_name(self) -&gt; str:\n        \"\"\"\n        Return the unique name of the curve.\n\n        Returns\n        -------\n        str\n            The unique name for the curve.\n\n        \"\"\"\n        return self._curve_id\n\n    def get_x_axis(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"\n        Get x axis values of the curve as a numpy array.\n\n        Args:\n            is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n        Returns:\n            NDArray: Numpy array of x axis values.\n\n        \"\"\"\n        x_axis = self._loader.get_x_axis(self._curve_id)\n        if is_float32:\n            x_axis = x_axis.astype(np.float32)\n        return x_axis\n\n    def get_y_axis(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"\n        Get y axis values of the curve as a numpy array.\n\n        Args:\n            is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n        Returns:\n            NDArray: Numpy array of y axis values.\n\n        \"\"\"\n        y_axis = self._loader.get_y_axis(self._curve_id)\n        if is_float32:\n            y_axis = y_axis.astype(np.float32)\n        return y_axis\n\n    def get_x_unit(self) -&gt; str:\n        \"\"\"\n        Return the unit for the x-axis.\n\n        Returns\n        -------\n        str\n            The unit for the x-axis.\n\n        \"\"\"\n        return self._loader.get_x_unit(self._curve_id)\n\n    def get_y_unit(self) -&gt; str:\n        \"\"\"\n        Return the unit for the y-axis.\n\n        Returns\n        -------\n        str\n            The unit for the y-axis.\n\n        \"\"\"\n        return self._loader.get_y_unit(self._curve_id)\n\n    def get_loader(self) -&gt; CurveLoader:\n        \"\"\"\n        Return the loader instance used to retrieve curve data.\n\n        Returns\n        -------\n        CurveLoader\n            The loader instance associated with this curve.\n\n        \"\"\"\n        return self._loader\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"\n        Return the fingerprint of the curve.\n\n        The method is not implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Not implemented yet.\")\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.__init__","title":"<code>__init__(curve_id: str, loader: CurveLoader) -&gt; None</code>","text":"<p>Initialize a LoadedCurve instance.</p>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.__init__--parameters","title":"Parameters","text":"<p>curve_id : str     Identifier for the curve. loader : CurveLoader     Loader instance used to retrieve curve data.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def __init__(self, curve_id: str, loader: CurveLoader) -&gt; None:\n    \"\"\"\n    Initialize a LoadedCurve instance.\n\n    Parameters\n    ----------\n    curve_id : str\n        Identifier for the curve.\n    loader : CurveLoader\n        Loader instance used to retrieve curve data.\n\n    \"\"\"\n    self._curve_id = curve_id\n    self._loader = loader\n\n    # TODO: get from loader\n    self._reference_period = None\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a string representation of the LoadedCurve instance.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the LoadedCurve instance.\"\"\"\n    return f\"{type(self).__name__}(curve_id={self._curve_id},loader={self._loader},x_unit={self.get_x_unit()}),y_unit={self.get_y_unit()}),\"\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Return the fingerprint of the curve.</p> <p>The method is not implemented yet.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"\n    Return the fingerprint of the curve.\n\n    The method is not implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Not implemented yet.\")\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_loader","title":"<code>get_loader() -&gt; CurveLoader</code>","text":"<p>Return the loader instance used to retrieve curve data.</p>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_loader--returns","title":"Returns","text":"<p>CurveLoader     The loader instance associated with this curve.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def get_loader(self) -&gt; CurveLoader:\n    \"\"\"\n    Return the loader instance used to retrieve curve data.\n\n    Returns\n    -------\n    CurveLoader\n        The loader instance associated with this curve.\n\n    \"\"\"\n    return self._loader\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_unique_name","title":"<code>get_unique_name() -&gt; str</code>","text":"<p>Return the unique name of the curve.</p>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_unique_name--returns","title":"Returns","text":"<p>str     The unique name for the curve.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def get_unique_name(self) -&gt; str:\n    \"\"\"\n    Return the unique name of the curve.\n\n    Returns\n    -------\n    str\n        The unique name for the curve.\n\n    \"\"\"\n    return self._curve_id\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_x_axis","title":"<code>get_x_axis(is_float32: bool) -&gt; NDArray</code>","text":"<p>Get x axis values of the curve as a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>is_float32</code> <code>bool</code> <p>Flag for converting the array of values to numpy float32.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of x axis values.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def get_x_axis(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"\n    Get x axis values of the curve as a numpy array.\n\n    Args:\n        is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n    Returns:\n        NDArray: Numpy array of x axis values.\n\n    \"\"\"\n    x_axis = self._loader.get_x_axis(self._curve_id)\n    if is_float32:\n        x_axis = x_axis.astype(np.float32)\n    return x_axis\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_x_unit","title":"<code>get_x_unit() -&gt; str</code>","text":"<p>Return the unit for the x-axis.</p>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_x_unit--returns","title":"Returns","text":"<p>str     The unit for the x-axis.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def get_x_unit(self) -&gt; str:\n    \"\"\"\n    Return the unit for the x-axis.\n\n    Returns\n    -------\n    str\n        The unit for the x-axis.\n\n    \"\"\"\n    return self._loader.get_x_unit(self._curve_id)\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_y_axis","title":"<code>get_y_axis(is_float32: bool) -&gt; NDArray</code>","text":"<p>Get y axis values of the curve as a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>is_float32</code> <code>bool</code> <p>Flag for converting the array of values to numpy float32.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of y axis values.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def get_y_axis(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"\n    Get y axis values of the curve as a numpy array.\n\n    Args:\n        is_float32 (bool): Flag for converting the array of values to numpy float32.\n\n    Returns:\n        NDArray: Numpy array of y axis values.\n\n    \"\"\"\n    y_axis = self._loader.get_y_axis(self._curve_id)\n    if is_float32:\n        y_axis = y_axis.astype(np.float32)\n    return y_axis\n</code></pre>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_y_unit","title":"<code>get_y_unit() -&gt; str</code>","text":"<p>Return the unit for the y-axis.</p>"},{"location":"reference/#framcore.curves.LoadedCurve.LoadedCurve.get_y_unit--returns","title":"Returns","text":"<p>str     The unit for the y-axis.</p> Source code in <code>framcore/curves/LoadedCurve.py</code> <pre><code>def get_y_unit(self) -&gt; str:\n    \"\"\"\n    Return the unit for the y-axis.\n\n    Returns\n    -------\n    str\n        The unit for the y-axis.\n\n    \"\"\"\n    return self._loader.get_y_unit(self._curve_id)\n</code></pre>"},{"location":"reference/#framcore.events","title":"<code>events</code>","text":""},{"location":"reference/#framcore.events.get_event_handler","title":"<code>get_event_handler() -&gt; object | None</code>","text":"<p>Get event handler if any.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def get_event_handler() -&gt; object | None:\n    \"\"\"Get event handler if any.\"\"\"\n    return _EVENT_HANDLER\n</code></pre>"},{"location":"reference/#framcore.events.send_debug_event","title":"<code>send_debug_event(sender: object, message: str) -&gt; None</code>","text":"<p>Use this to send debug event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_debug_event(sender: object, message: str) -&gt; None:\n    \"\"\"Use this to send debug event.\"\"\"\n    send_event(sender, \"debug\", message=message)\n</code></pre>"},{"location":"reference/#framcore.events.send_error_event","title":"<code>send_error_event(sender: object, message: str, exception_type_name: str, traceback: str) -&gt; None</code>","text":"<p>Use this to send error event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_error_event(sender: object, message: str, exception_type_name: str, traceback: str) -&gt; None:\n    \"\"\"Use this to send error event.\"\"\"\n    send_event(sender, \"error\", message=message, exception_type_name=exception_type_name, traceback=traceback)\n</code></pre>"},{"location":"reference/#framcore.events.send_event","title":"<code>send_event(sender: object, event_type: str, **kwargs: dict[str, object]) -&gt; None</code>","text":"<p>All events in core should use this.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_event(sender: object, event_type: str, **kwargs: dict[str, object]) -&gt; None:\n    \"\"\"All events in core should use this.\"\"\"\n    if _EVENT_HANDLER is None:\n        print(event_type, kwargs)\n    else:\n        _EVENT_HANDLER.handle_event(sender, event_type, **kwargs)\n</code></pre>"},{"location":"reference/#framcore.events.send_info_event","title":"<code>send_info_event(sender: object, message: str) -&gt; None</code>","text":"<p>Use this to send info event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_info_event(sender: object, message: str) -&gt; None:\n    \"\"\"Use this to send info event.\"\"\"\n    send_event(sender, \"info\", message=message)\n</code></pre>"},{"location":"reference/#framcore.events.send_warning_event","title":"<code>send_warning_event(sender: object, message: str) -&gt; None</code>","text":"<p>Use this to send warning event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_warning_event(sender: object, message: str) -&gt; None:\n    \"\"\"Use this to send warning event.\"\"\"\n    send_event(sender, \"warning\", message=message)\n</code></pre>"},{"location":"reference/#framcore.events.set_event_handler","title":"<code>set_event_handler(handler: object | None) -&gt; None</code>","text":"<p>Set event handler if any.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def set_event_handler(handler: object | None) -&gt; None:\n    \"\"\"Set event handler if any.\"\"\"\n    if handler is not None and (not hasattr(handler, \"handle_event\") or not callable(handler.handle_event)):\n        message = \"Given handler does not implement handle_event.\"\n        raise ValueError(message)\n    global _EVENT_HANDLER  # noqa: PLW0603 # TODO: unsafe?\n    _EVENT_HANDLER = handler\n</code></pre>"},{"location":"reference/#framcore.events.events","title":"<code>events</code>","text":"<p>Event system.</p> <p>All code in the core use these functions to communicate events.</p> <p>Calling systems (e.g. workflow codes) can get events by hooking into SEND_EVENT_CHANNEL.</p>"},{"location":"reference/#framcore.events.events.get_event_handler","title":"<code>get_event_handler() -&gt; object | None</code>","text":"<p>Get event handler if any.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def get_event_handler() -&gt; object | None:\n    \"\"\"Get event handler if any.\"\"\"\n    return _EVENT_HANDLER\n</code></pre>"},{"location":"reference/#framcore.events.events.send_debug_event","title":"<code>send_debug_event(sender: object, message: str) -&gt; None</code>","text":"<p>Use this to send debug event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_debug_event(sender: object, message: str) -&gt; None:\n    \"\"\"Use this to send debug event.\"\"\"\n    send_event(sender, \"debug\", message=message)\n</code></pre>"},{"location":"reference/#framcore.events.events.send_error_event","title":"<code>send_error_event(sender: object, message: str, exception_type_name: str, traceback: str) -&gt; None</code>","text":"<p>Use this to send error event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_error_event(sender: object, message: str, exception_type_name: str, traceback: str) -&gt; None:\n    \"\"\"Use this to send error event.\"\"\"\n    send_event(sender, \"error\", message=message, exception_type_name=exception_type_name, traceback=traceback)\n</code></pre>"},{"location":"reference/#framcore.events.events.send_event","title":"<code>send_event(sender: object, event_type: str, **kwargs: dict[str, object]) -&gt; None</code>","text":"<p>All events in core should use this.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_event(sender: object, event_type: str, **kwargs: dict[str, object]) -&gt; None:\n    \"\"\"All events in core should use this.\"\"\"\n    if _EVENT_HANDLER is None:\n        print(event_type, kwargs)\n    else:\n        _EVENT_HANDLER.handle_event(sender, event_type, **kwargs)\n</code></pre>"},{"location":"reference/#framcore.events.events.send_info_event","title":"<code>send_info_event(sender: object, message: str) -&gt; None</code>","text":"<p>Use this to send info event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_info_event(sender: object, message: str) -&gt; None:\n    \"\"\"Use this to send info event.\"\"\"\n    send_event(sender, \"info\", message=message)\n</code></pre>"},{"location":"reference/#framcore.events.events.send_warning_event","title":"<code>send_warning_event(sender: object, message: str) -&gt; None</code>","text":"<p>Use this to send warning event.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def send_warning_event(sender: object, message: str) -&gt; None:\n    \"\"\"Use this to send warning event.\"\"\"\n    send_event(sender, \"warning\", message=message)\n</code></pre>"},{"location":"reference/#framcore.events.events.set_event_handler","title":"<code>set_event_handler(handler: object | None) -&gt; None</code>","text":"<p>Set event handler if any.</p> Source code in <code>framcore/events/events.py</code> <pre><code>def set_event_handler(handler: object | None) -&gt; None:\n    \"\"\"Set event handler if any.\"\"\"\n    if handler is not None and (not hasattr(handler, \"handle_event\") or not callable(handler.handle_event)):\n        message = \"Given handler does not implement handle_event.\"\n        raise ValueError(message)\n    global _EVENT_HANDLER  # noqa: PLW0603 # TODO: unsafe?\n    _EVENT_HANDLER = handler\n</code></pre>"},{"location":"reference/#framcore.expressions","title":"<code>expressions</code>","text":""},{"location":"reference/#framcore.expressions.ensure_expr","title":"<code>ensure_expr(value: Expr | str | Curve | TimeVector | None, is_flow: bool = False, is_stock: bool = False, is_level: bool = False, is_profile: bool = False, profile: Expr | None = None) -&gt; Expr | None</code>","text":"<p>Ensure that the value is an expression of the expected type or create one if possible.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Expr | str | None</code> <p>The value to check.</p> required <code>is_flow</code> <code>str</code> <p>If the Expr is a flow. Cannot be True if is_stock is True.</p> <code>False</code> <code>is_stock</code> <code>str</code> <p>If the Expr is a stock. Cannot be True if is_flow is True.</p> <code>False</code> <code>is_level</code> <code>bool</code> <p>Wether the Expr represents a level. Cannot be True if is_profile is True.</p> <code>False</code> <code>is_profile</code> <code>bool</code> <p>Wether the Expr represents a profile. Cannot be True if is_level is True.</p> <code>False</code> <code>profile</code> <code>Expr | None</code> <p>If the Expr is a level, this should be its profile.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Expr | str</code> <p>The value as an expression of the expected type or None.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def ensure_expr(\n    value: Expr | str | Curve | TimeVector | None,  # technically anything that can be converted to float. Typehint for this?\n    is_flow: bool = False,\n    is_stock: bool = False,\n    is_level: bool = False,\n    is_profile: bool = False,\n    profile: Expr | None = None,\n) -&gt; Expr | None:\n    \"\"\"\n    Ensure that the value is an expression of the expected type or create one if possible.\n\n    Args:\n        value (Expr | str | None): The value to check.\n        is_flow (str): If the Expr is a flow. Cannot be True if is_stock is True.\n        is_stock (str): If the Expr is a stock. Cannot be True if is_flow is True.\n        is_level (bool): Wether the Expr represents a level. Cannot be True if is_profile is True.\n        is_profile (bool): Wether the Expr represents a profile. Cannot be True if is_level is True.\n        profile (Expr | None): If the Expr is a level, this should be its profile.\n\n    Returns:\n        value (Expr | str): The value as an expression of the expected type or None.\n\n    \"\"\"\n    if not isinstance(value, (str, Expr, Curve, TimeVector)) and value is not None:\n        msg = f\"Expected value to be of type Expr, str, Curve, TimeVector or None. Got {type(value).__name__}.\"\n        raise TypeError(msg)\n\n    if value is None:\n        return None\n\n    if isinstance(value, Expr):\n        # Check wether given Expr matches expected flow, stock, profile and level status.\n        if value.is_flow() != is_flow or value.is_stock() != is_stock or value.is_level() != is_level or value.is_profile() != is_profile:\n            message = (\n                \"Given Expr has a mismatch between expected and actual flow/stock or level/profile status:\\nExpected: \"\n                f\"is_flow - {is_flow}, is_stock - {is_stock}, is_level - {is_level}, is_profile - {is_profile}\\n\"\n                f\"Actual: is_flow - {value.is_flow()}, is_stock - {value.is_stock()}, \"\n                f\"is_level - {value.is_level()}, is_profile - {value.is_profile()}\"\n            )\n            raise ValueError(message)\n        return value\n\n    return Expr(\n        src=value,\n        is_flow=is_flow,\n        is_stock=is_stock,\n        is_level=is_level,\n        is_profile=is_profile,\n        profile=profile,\n    )\n</code></pre>"},{"location":"reference/#framcore.expressions.get_leaf_profiles","title":"<code>get_leaf_profiles(expr: Expr) -&gt; list[Expr]</code>","text":"<p>Get all leaf profile expressions from an Expr object.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>The starting Expr object.</p> required <p>Returns:</p> Type Description <code>list[Expr]</code> <p>list[Expr]: A list of leaf profile expressions.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_leaf_profiles(expr: Expr) -&gt; list[Expr]:\n    \"\"\"\n    Get all leaf profile expressions from an Expr object.\n\n    Args:\n        expr (Expr): The starting Expr object.\n\n    Returns:\n        list[Expr]: A list of leaf profile expressions.\n\n    \"\"\"\n    leaf_profiles = []\n\n    def _traverse(expr: Expr) -&gt; None:\n        if expr.is_leaf():\n            if expr.is_profile():\n                leaf_profiles.append(expr)\n            return\n\n        # Recursively traverse the arguments of the expression\n        _, args = expr.get_operations(expect_ops=False, copy_list=False)\n        for arg in args:\n            _traverse(arg)\n\n    _traverse(expr)\n    return leaf_profiles\n</code></pre>"},{"location":"reference/#framcore.expressions.get_level_value","title":"<code>get_level_value(expr: Expr, db: QueryDB | Model, unit: str | None, data_dim: SinglePeriodTimeIndex, scen_dim: FixedFrequencyTimeIndex, is_max: bool) -&gt; float</code>","text":"<p>Evaluate Expr representing a (possibly aggregated) level.</p> <p>The follwing will be automatically handled for you: - fetching from different data objecs (from db) - conversion to requested unit - query at requested TimeIndex for data and scenario dimension, and with requested reference period - conversion to requested level type (is_max or is_avg)</p> <p>Supports all expressions. Will evaluate level Exprs at data_dim (with reference period of scen_dim), and profile Exprs as an average over scen_dim (both as constants). Has optimized fastpath methods for sums, products and aggregations. The rest uses a fallback method with SymPy.</p> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_level_value(\n    expr: Expr,\n    db: QueryDB | Model,\n    unit: str | None,\n    data_dim: SinglePeriodTimeIndex,\n    scen_dim: FixedFrequencyTimeIndex,\n    is_max: bool,\n) -&gt; float:\n    \"\"\"\n    Evaluate Expr representing a (possibly aggregated) level.\n\n    The follwing will be automatically handled for you:\n    - fetching from different data objecs (from db)\n    - conversion to requested unit\n    - query at requested TimeIndex for data and scenario dimension, and with requested reference period\n    - conversion to requested level type (is_max or is_avg)\n\n    Supports all expressions. Will evaluate level Exprs at data_dim (with reference period of scen_dim),\n    and profile Exprs as an average over scen_dim (both as constants). Has optimized fastpath methods for sums, products and aggregations.\n    The rest uses a fallback method with SymPy.\n\n    \"\"\"\n    check_type(expr, Expr)  # check expr here since _get_level_value is not recursively called.\n    check_type(unit, (str, type(None)))\n    check_type(data_dim, SinglePeriodTimeIndex)\n    check_type(scen_dim, FixedFrequencyTimeIndex)\n    check_type(is_max, bool)\n    db = _load_model_and_create_model_db(db)\n\n    return _get_level_value(expr, db, unit, data_dim, scen_dim, is_max)\n</code></pre>"},{"location":"reference/#framcore.expressions.get_profile_exprs_from_leaf_levels","title":"<code>get_profile_exprs_from_leaf_levels(expr: Expr) -&gt; list[Expr]</code>","text":"<p>Get all profile expressions from leaf-level Expr objects that are marked as levels.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>The starting Expr object.</p> required <p>Returns:</p> Type Description <code>list[Expr]</code> <p>list[Expr]: A list of profile expressions from leaf-level Expr objects.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_profile_exprs_from_leaf_levels(expr: Expr) -&gt; list[Expr]:\n    \"\"\"\n    Get all profile expressions from leaf-level Expr objects that are marked as levels.\n\n    Args:\n        expr (Expr): The starting Expr object.\n\n    Returns:\n        list[Expr]: A list of profile expressions from leaf-level Expr objects.\n\n    \"\"\"\n    profile_exprs = []\n\n    def _traverse(expr: Expr) -&gt; None:\n        if expr.is_leaf():\n            if expr.is_level() and expr.get_profile() is not None:\n                profile_exprs.append(expr.get_profile())\n            return\n\n        # Recursively traverse the arguments of the expression\n        _, args = expr.get_operations(expect_ops=False, copy_list=False)\n        for arg in args:\n            _traverse(arg)\n\n    _traverse(expr)\n    return profile_exprs\n</code></pre>"},{"location":"reference/#framcore.expressions.get_profile_vector","title":"<code>get_profile_vector(expr: Expr, db: QueryDB | Model, data_dim: SinglePeriodTimeIndex, scen_dim: FixedFrequencyTimeIndex, is_zero_one: bool, is_float32: bool = True) -&gt; NDArray</code>","text":"<p>Evaluate expr representing a (possibly aggregated) profile.</p> <p>expr = sum(weight[i] * profile[i]) where</p> <pre><code>weight[i] &gt;= 0 and is unitless, and will be evaluated as a constant\nprofile[i] is a unitless profile expr\n\nprofile[i] is either \"zero_one\" or \"mean_one\" type of profile\n\n\"zero_one\" and \"mean_one\" profile type must be converted to the\nsame standard to be added correctly.\n\nThe query parameters data_dim and scen_dim are used to evaluate the values\nrequested TimeIndex for data and scenario dimension, and with requested reference period\n\nweight[i] will be evaluated level Exprs at data_dim (with reference period of scen_dim),\nand profile Exprs as an average over scen_dim (both as constants)\n\nprofile[i] will be evaluated as profile vectors over scen_dim\n\nThe query parameter is_zero_one tells which profile type the output\nvector should be converted to.\n</code></pre> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_profile_vector(\n    expr: Expr,\n    db: QueryDB | Model,\n    data_dim: SinglePeriodTimeIndex,\n    scen_dim: FixedFrequencyTimeIndex,\n    is_zero_one: bool,\n    is_float32: bool = True,\n) -&gt; NDArray:\n    \"\"\"\n    Evaluate expr representing a (possibly aggregated) profile.\n\n    expr = sum(weight[i] * profile[i]) where\n\n        weight[i] &gt;= 0 and is unitless, and will be evaluated as a constant\n        profile[i] is a unitless profile expr\n\n        profile[i] is either \"zero_one\" or \"mean_one\" type of profile\n\n        \"zero_one\" and \"mean_one\" profile type must be converted to the\n        same standard to be added correctly.\n\n        The query parameters data_dim and scen_dim are used to evaluate the values\n        requested TimeIndex for data and scenario dimension, and with requested reference period\n\n        weight[i] will be evaluated level Exprs at data_dim (with reference period of scen_dim),\n        and profile Exprs as an average over scen_dim (both as constants)\n\n        profile[i] will be evaluated as profile vectors over scen_dim\n\n        The query parameter is_zero_one tells which profile type the output\n        vector should be converted to.\n    \"\"\"\n    # Argument expr checked in _get_profile_vector since it can be recursively called.\n    check_type(data_dim, SinglePeriodTimeIndex)\n    check_type(scen_dim, FixedFrequencyTimeIndex)\n    check_type(is_zero_one, bool)\n    check_type(is_float32, bool)\n    db = _load_model_and_create_model_db(db)\n\n    return _get_profile_vector(expr, db, data_dim, scen_dim, is_zero_one, is_float32)\n</code></pre>"},{"location":"reference/#framcore.expressions.get_timeindexes_from_expr","title":"<code>get_timeindexes_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[TimeIndex]</code>","text":"<p>Find all timeindexes behind an expression.</p> <p>Useful for optimized queries (not asking for more data than necessary).</p> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_timeindexes_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[TimeIndex]:\n    \"\"\"\n    Find all timeindexes behind an expression.\n\n    Useful for optimized queries (not asking for more data than necessary).\n    \"\"\"\n    db = _load_model_and_create_model_db(db)\n\n    timeindexes: set[TimeIndex] = set()\n\n    _recursively_update_timeindexes(timeindexes, db, expr)\n\n    return timeindexes\n</code></pre>"},{"location":"reference/#framcore.expressions.get_unit_conversion_factor","title":"<code>get_unit_conversion_factor(from_unit: str | None, to_unit: str | None) -&gt; float</code>","text":"<p>Get the conversion factor from one unit to another.</p> Source code in <code>framcore/expressions/units.py</code> <pre><code>def get_unit_conversion_factor(from_unit: str | None, to_unit: str | None) -&gt; float:  # noqa C901\n    \"\"\"Get the conversion factor from one unit to another.\"\"\"\n    if from_unit == to_unit:\n        return 1.0\n\n    if from_unit is None or to_unit is None:\n        return _get_unit_conversion_factor_with_none(from_unit, to_unit)\n\n    fastpath = _fastpath_get_unit_conversion_factor(from_unit, to_unit)\n\n    if _DEBUG is False and fastpath is not None:\n        return fastpath\n\n    if fastpath is None:\n        has_multiplier = False\n        with contextlib.suppress(Exception):\n            ix = from_unit.index(\"*\")\n            multiplier = float(from_unit[:ix])\n            base_from_unit = from_unit[ix + 1 :].strip()\n            has_multiplier = True\n\n        if has_multiplier:\n            fastpath = _fastpath_get_unit_conversion_factor(base_from_unit, to_unit)\n            fastpath = fastpath if fastpath is None else fastpath * multiplier\n            if _DEBUG is False and fastpath is not None:\n                return fastpath\n\n    if _COLLECT_FASTPATH_DATA and fastpath is None:\n        if has_multiplier:\n            _OBSERVED_UNIT_CONVERSIONS.add((base_from_unit, to_unit))\n        else:\n            _OBSERVED_UNIT_CONVERSIONS.add((from_unit, to_unit))\n\n    fallback = _fallback_get_unit_conversion_factor(from_unit, to_unit)\n\n    if _DEBUG and fastpath is not None and fallback != fastpath:\n        message = f\"Different results!\\nfrom_unit {from_unit} to_unit {to_unit}\\nfastpath {fastpath} fallback {fallback}\"\n        raise RuntimeError(message)\n\n    if _unit_has_no_floats(from_unit) and _unit_has_no_floats(to_unit):\n        _FASTPATH_CONVERSION_FACTORS[(from_unit, to_unit)] = fallback\n\n    return fallback\n</code></pre>"},{"location":"reference/#framcore.expressions.get_units_from_expr","title":"<code>get_units_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[str]</code>","text":"<p>Find all units behind an expression. Useful for queries involving conversion factors.</p> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_units_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[str]:\n    \"\"\"Find all units behind an expression. Useful for queries involving conversion factors.\"\"\"\n    db = _load_model_and_create_model_db(db)\n\n    units: set[str] = set()\n\n    _recursively_update_units(units, db, expr)\n\n    return units\n</code></pre>"},{"location":"reference/#framcore.expressions.is_convertable","title":"<code>is_convertable(unit_from: str, unit_to: str) -&gt; bool</code>","text":"<p>Return True if from_unit can be converted to to_unit else False.</p> Source code in <code>framcore/expressions/units.py</code> <pre><code>def is_convertable(unit_from: str, unit_to: str) -&gt; bool:\n    \"\"\"Return True if from_unit can be converted to to_unit else False.\"\"\"\n    with contextlib.suppress(Exception):\n        get_unit_conversion_factor(unit_from, unit_to)\n        return True\n    return False\n</code></pre>"},{"location":"reference/#framcore.expressions.validate_unit_conversion_fastpaths","title":"<code>validate_unit_conversion_fastpaths() -&gt; bool</code>","text":"<p>Run-Time validation of fastpaths.</p> Source code in <code>framcore/expressions/units.py</code> <pre><code>def validate_unit_conversion_fastpaths() -&gt; bool:\n    \"\"\"Run-Time validation of fastpaths.\"\"\"\n    errors = []\n    for (from_unit, to_unit), result in _FASTPATH_CONVERSION_FACTORS.items():\n        sympy_result = None\n        with contextlib.suppress(Exception):\n            sympy_result = _fallback_get_unit_conversion_factor(from_unit, to_unit)\n        if result != sympy_result:\n            message = f\"'{from_unit}' to '{to_unit}' failed. Fastpath: {result}, SymPy: {sympy_result}\"\n            errors.append(message)\n    for from_unit, to_unit in _FASTPATH_INCOMPATIBLE_CONVERSIONS:\n        with contextlib.suppress(Exception):\n            sympy_result = _fallback_get_unit_conversion_factor(from_unit, to_unit)\n            message = f\"'{from_unit}' to '{to_unit}'. Fastpath claim incompatible units, but SymPy fallback returned {sympy_result}\"\n            errors.append(message)\n    if errors:\n        message = \"\\n\".join(errors)\n        raise RuntimeError(message)\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr","title":"<code>Expr</code>","text":""},{"location":"reference/#framcore.expressions.Expr.Expr","title":"<code>Expr</code>","text":"<p>               Bases: <code>Base</code></p> <p>Mathematical expression with TimeVectors and Curves to represent Levels and Profiles in LevelProfiles.</p> <p>The simplest Expr is a single TimeVector, while a more complicated expression could be a weighted average of several TimeVectors or Expressions. Expr can also have string references to Expr, TimeVector or Curve in a database (often Model).</p> <p>Expr are classified as Stock, Flow or None of them. See https://en.wikipedia.org/wiki/Stock_and_flow. In FRAM we only support Flow data as a rate of change. So, for example, a production timeseries has to be in MW, and not in MWh. Converting between the two versions of Flow would add another level of complexity both in Expr and in TimeVector operations.</p> <p>Expr are also classified as Level, Profile or none of them. This classification, together with Stock or Flow, is used to check if the built Expr are legal operations. - Expr that are Level can contain its connected Profile Expr. This is used in the queries to evaluate Levels according to their ReferencePeriod, and     convert between Level formats (max level or average level, see LevelProfile for more details).</p> <p>Calculations using Expr are evaluated lazily, reducing unnecessary numerical operations during data manipulation. Computations involving values and units occur only when the Expr is queried.</p> <p>We only support calculations using +, -, *, and / in Expr, and we have no plans to change this. Expanding beyond these would turn Expr into a complex programming language rather than keeping it as a simple and efficient system for common time-series calculations. More advanced operations are still possible through eager evaluation, so this is not a limitation. It simply distributes responsibilities across system components in a way that is practical from a maintenance perspective.</p> <p>We use SymPy to support unit conversions. Already computed unit conversion factors are cached to minimize redundant calculations.</p> <p>At the moment we support these queries for Expr (see Aggregators for more about how they are used): - get_level_value(expr, db, unit, data_dim, scen_dim, is_max)     - Supports all expressions. Will evaluate level Exprs at data_dim (with reference period of scen_dim),         and profile Exprs as an average over scen_dim (both as constants).     - Has optimized fastpath methods for sums, products and aggregations. The rest uses a fallback method with SymPy. - get_profile_vector(expr, db, data_dim, scen_dim, is_zero_one, is_float32)     - Supports expr = sum(weight[i] * profile[i]) where weight[i] is a unitless constant Expr with value &gt;= 0, and profile[i] is a unitless profile Expr.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>class Expr(Base):\n    \"\"\"\n    Mathematical expression with TimeVectors and Curves to represent Levels and Profiles in LevelProfiles.\n\n    The simplest Expr is a single TimeVector, while a more complicated expression could be a weighted average of several TimeVectors or Expressions.\n    Expr can also have string references to Expr, TimeVector or Curve in a database (often Model).\n\n    Expr are classified as Stock, Flow or None of them. See https://en.wikipedia.org/wiki/Stock_and_flow. In FRAM we only support Flow data as a rate of change.\n    So, for example, a production timeseries has to be in MW, and not in MWh. Converting between the two versions of Flow would add another\n    level of complexity both in Expr and in TimeVector operations.\n\n    Expr are also classified as Level, Profile or none of them. This classification, together with Stock or Flow,\n    is used to check if the built Expr are legal operations.\n    - Expr that are Level can contain its connected Profile Expr. This is used in the queries to evaluate Levels according to their ReferencePeriod, and\n        convert between Level formats (max level or average level, see LevelProfile for more details).\n\n    Calculations using Expr are evaluated lazily, reducing unnecessary numerical operations during data manipulation.\n    Computations involving values and units occur only when the Expr is queried.\n\n    We only support calculations using +, -, *, and / in Expr, and we have no plans to change this.\n    Expanding beyond these would turn Expr into a complex programming language rather than keeping it as a simple\n    and efficient system for common time-series calculations. More advanced operations are still possible through eager evaluation, so this is not a limitation.\n    It simply distributes responsibilities across system components in a way that is practical from a maintenance perspective.\n\n    We use SymPy to support unit conversions. Already computed unit conversion factors are cached to minimize redundant calculations.\n\n    At the moment we support these queries for Expr (see Aggregators for more about how they are used):\n    - get_level_value(expr, db, unit, data_dim, scen_dim, is_max)\n        - Supports all expressions. Will evaluate level Exprs at data_dim (with reference period of scen_dim),\n            and profile Exprs as an average over scen_dim (both as constants).\n        - Has optimized fastpath methods for sums, products and aggregations. The rest uses a fallback method with SymPy.\n    - get_profile_vector(expr, db, data_dim, scen_dim, is_zero_one, is_float32)\n        - Supports expr = sum(weight[i] * profile[i]) where weight[i] is a unitless constant Expr with value &gt;= 0, and profile[i] is a unitless profile Expr.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        src: str | Curve | TimeVector | None = None,\n        is_stock: bool = False,\n        is_flow: bool = False,\n        is_profile: bool = False,\n        is_level: bool = False,\n        profile: Expr | None = None,\n        operations: tuple[str, list[Expr]] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Create new (immutable) Expression.\n\n        Args:\n            src (str | Curve | TimeVector | None, optional): Source of the values to be used in the Expression. Either a Curve or TimeVector object,\n              or a reference to one of them. Defaults to None.\n            is_stock (bool, optional): Flag to signify if the Expr represents a stock type variable. Defaults to False.\n            is_flow (bool, optional): Flag to signify if the Expr represents a flow type variable. Defaults to False.\n            is_profile (bool, optional): Flag to signify if the Expr represents a profile. Defaults to False.\n            is_level (bool, optional): Flag to signify if the Expr represents a level. Defaults to False.\n            profile (Expr | None, optional): Expr that are Level can contain its connected Profile Expr. This is used in the queries to evaluate\n                Levels according to their ReferencePeriod, and convert between Level formats (max level or average level, see LevelProfile for more details).\n            operations (tuple[str, list[Expr]] | None, optional): Operations to apply to the expression. Defaults to None.\n\n        \"\"\"\n        if is_level and is_profile:\n            message = \"Expr cannot be both level and a profile. Set either is_level or is_profile True or both False.\"\n            raise ValueError(message)\n\n        if is_flow and is_stock:\n            message = \"Expr cannot be both flow and stock. Set either is_flow or is_stock True or both False.\"\n            raise ValueError(message)\n\n        if is_profile and (is_flow or is_stock):\n            message = \"Expr cannot be both a profile and a flow/stock. Profiles must be coefficients.\"\n            raise ValueError(message)\n\n        self._src: str | Curve | TimeVector | None = src\n        self._is_stock = is_stock\n        self._is_flow = is_flow\n        self._is_profile = is_profile\n        self._is_level = is_level\n        self._profile = profile\n\n        # have to come after setting fields\n        # because fields are used to create\n        # error messages e.g. in __repr__\n\n        self._check_type(src, (str, Curve, TimeVector, type(None)))\n        self._check_type(is_stock, (bool, type(None)))\n        self._check_type(is_flow, (bool, type(None)))\n        self._check_type(is_level, (bool, type(None)))\n        self._check_type(is_profile, (bool, type(None)))\n        self._check_type(profile, (Expr, type(None)))\n\n        self._check_operations(operations)\n        if operations is None:\n            operations = \"\", []\n        self._operations: tuple[str, list[Expr]] = operations\n\n    def _check_operations(self, operations: tuple[str, list[Expr]] | None, expect_ops: bool = False) -&gt; None:\n        if operations is None:\n            return\n        self._check_type(operations, tuple)\n        if len(operations) != 2:  # noqa: PLR2004\n            message = f\"Expected len(operations) == 2. Got: {operations}\"\n            raise ValueError(message)\n        ops, args = operations\n        self._check_type(ops, str)\n        self._check_type(args, list)\n        if ops == \"\":\n            if expect_ops:\n                message = f\"Expected ops, but got {operations}\"\n                raise ValueError(message)\n            if len(args) &gt; 0:\n                message = f\"Expected ops to have length. Got {operations}\"\n                raise ValueError(message)\n            return\n        if len(ops) != len(args) - 1:\n            message = f\"Expected len(ops) == len(args) - 1. Got {operations}\"\n            raise ValueError(message)\n        for op in ops:\n            if op not in \"+-/*\":\n                message = f\"Expected all op in ops in +-*/. Got {operations}\"\n                raise ValueError(message)\n        for ex in args:\n            self._check_type(ex, Expr)\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Return fingerprint.\"\"\"\n        fingerprint = Fingerprint(self)\n        fingerprint.add(\"is_stock\", self._is_stock)\n        fingerprint.add(\"is_flow\", self._is_flow)\n        fingerprint.add(\"is_profile\", self._is_profile)\n        fingerprint.add(\"is_level\", self._is_level)\n        fingerprint.add(\"profile\", self._profile)\n        if self._src:\n            fingerprint.add(\"src\", self._src.get_fingerprint() if isinstance(self._src, TimeVector) else FingerprintRef(self._src))\n        fingerprint.add(\"operations\", self._operations)\n        return fingerprint\n\n    def is_leaf(self) -&gt; bool:\n        \"\"\"Return True if self is not an operation expression.\"\"\"\n        return self._src is not None\n\n    def get_src(self) -&gt; str | Curve | TimeVector | None:\n        \"\"\"Return str, Curve or TimeVector (either reference to Curve/TimeVector or Curve/TimeVector itself) or None if self is an operation expression.\"\"\"\n        return self._src\n\n    def get_operations(self, expect_ops: bool, copy_list: bool) -&gt; tuple[str, list[Expr]]:\n        \"\"\"Return ops, args. Users of this (low level) API must supply expect_ops and copy_list args.\"\"\"\n        self._check_type(copy_list, bool)\n        self._verify_operations(expect_ops)\n        if copy_list:\n            ops, args = self._operations\n            return ops, copy(args)\n        return self._operations\n\n    def _verify_operations(self, expect_ops: bool = False) -&gt; None:\n        self._check_operations(self._operations, expect_ops)\n        ops = self._operations[0]\n\n        if not ops:\n            return\n\n        has_add = \"+\" in ops\n        has_sub = \"-\" in ops\n        has_mul = \"*\" in ops\n        has_div = \"/\" in ops\n\n        if (has_add or has_sub) and (has_mul or has_div):\n            message = f\"Found +- in same operation level as */ in operations {self._operations} \"\n            raise ValueError(message)\n\n        if has_div:\n            seen_div = False\n            for op in ops:\n                if op == \"/\":\n                    seen_div = True\n                    continue\n                if seen_div and op != \"/\":\n                    message = f\"Found +-* after / in operations {self._operations}\"\n                    raise ValueError(message)\n\n    def is_flow(self) -&gt; bool:\n        \"\"\"Return True if flow. Cannot be stock and flow.\"\"\"\n        return self._is_flow\n\n    def is_stock(self) -&gt; bool:\n        \"\"\"Return True if stock. Cannot be stock and flow.\"\"\"\n        return self._is_stock\n\n    def is_level(self) -&gt; bool:\n        \"\"\"Return True if level. Cannot be level and profile.\"\"\"\n        return self._is_level\n\n    def is_profile(self) -&gt; bool:\n        \"\"\"Return True if profile. Cannot be level and profile.\"\"\"\n        return self._is_profile\n\n    def get_profile(self) -&gt; Expr | None:\n        \"\"\"Return Expr representing profile. Implies self.is_level() is True.\"\"\"\n        return self._profile\n\n    def set_profile(self, profile: Expr | None) -&gt; None:\n        \"\"\"Set the profile of the Expr. Implies self.is_level() is True.\"\"\"\n        if not self.is_level():\n            raise ValueError(\"Cannot set profile on Expr that is not a level.\")\n        self._profile = profile\n\n    def _analyze_op(self, op: str, other: Expr) -&gt; tuple[bool, bool, bool, bool, Expr | None]:\n        flow = (True, False)\n        stock = (False, True)\n        level = (True, False)\n        profile = (False, True)\n        none = (False, False)\n\n        supported_cases = {\n            # all op supported for none\n            (\"+\", none, none, none, none): (none, none, None),\n            (\"-\", none, none, none, none): (none, none, None),\n            (\"*\", none, none, none, none): (none, none, None),\n            (\"/\", none, none, none, none): (none, none, None),\n            # + flow level\n            (\"+\", flow, level, flow, level): (flow, level, None),\n            # * flow level\n            (\"*\", flow, level, none, none): (flow, level, self.get_profile()),\n            (\"*\", none, none, flow, level): (flow, level, other.get_profile()),\n            # / flow level\n            (\"/\", flow, level, none, none): (flow, level, self.get_profile()),\n            (\"/\", flow, level, flow, level): (none, none, None),\n            # + stock level\n            (\"+\", stock, level, stock, level): (stock, level, None),\n            # * stock level\n            (\"*\", stock, level, none, level): (stock, level, None),\n            (\"*\", none, level, stock, level): (stock, level, None),\n            (\"*\", stock, level, none, none): (stock, level, self.get_profile()),\n            (\"*\", none, none, stock, level): (stock, level, other.get_profile()),\n            # / stock level\n            (\"/\", stock, level, none, level): (stock, level, None),\n            (\"/\", stock, level, none, none): (stock, level, self.get_profile()),\n            (\"/\", stock, level, stock, level): (none, none, None),\n            # level * level ok if one is flow (i.e. price * volume) or none (co2_eff / eff)\n            (\"*\", flow, level, none, level): (flow, level, None),\n            (\"*\", none, level, flow, level): (flow, level, None),\n            (\"/\", flow, level, none, level): (flow, level, None),\n            (\"/\", none, level, none, level): (none, level, None),\n            (\"*\", none, level, none, level): (none, level, None),\n            # profile\n            (\"+\", none, profile, none, profile): (none, profile, None),\n            (\"-\", none, profile, none, profile): (none, profile, None),\n            (\"/\", none, profile, none, none): (none, profile, None),\n            (\"*\", none, profile, none, none): (none, profile, None),\n            (\"*\", none, none, none, profile): (none, profile, None),\n            (\"/\", none, none, none, profile): (none, profile, None),\n            # level\n            (\"+\", none, level, none, level): (none, level, None),\n            (\"-\", none, level, none, level): (none, level, None),\n            (\"/\", none, level, none, none): (none, level, self.get_profile()),\n            (\"*\", none, level, none, none): (none, level, self.get_profile()),\n            (\"*\", none, none, none, level): (none, level, other.get_profile()),\n            (\"/\", none, none, none, level): (none, level, other.get_profile()),\n        }\n\n        case = (\n            op,\n            (self.is_flow(), self.is_stock()),\n            (self.is_level(), self.is_profile()),\n            (other.is_flow(), other.is_stock()),\n            (other.is_level(), other.is_profile()),\n        )\n\n        if case not in supported_cases:\n            printable_case = {\n                \"op\": case[0],\n                \"self_is_flow\": case[1][0],\n                \"self_is_stock\": case[1][1],\n                \"self_is_level\": case[2][0],\n                \"self_is_profile\": case[2][1],\n                \"other_is_flow\": case[3][0],\n                \"other_is_stock\": case[3][1],\n                \"other_is_level\": case[4][0],\n                \"other_is_profile\": case[4][1],\n            }\n            message = f\"Unsupported case:\\n{printable_case}\\nexpression:\\n{self} {op} {other}.\"\n            raise ValueError(message)\n\n        ((is_flow, is_stock), (is_level, is_profile), profile) = supported_cases[case]\n\n        return is_stock, is_flow, is_level, is_profile, profile\n\n    @staticmethod\n    def _is_number(src: str) -&gt; bool:\n        try:\n            float(src)\n            return True\n        except ValueError:\n            return False\n\n    def _create_op_expr(  # noqa: C901\n        self,\n        op: str,\n        other: Expr | int | float,\n        is_rhs: bool,\n    ) -&gt; Expr:\n        if isinstance(other, Expr):\n            is_stock, is_flow, is_level, is_profile, profile = self._analyze_op(op, other)\n\n            x, y = (other, self) if is_rhs else (self, other)\n\n            xisconst = isinstance(x.get_src(), ConstantTimeVector)\n            yisconst = isinstance(y.get_src(), ConstantTimeVector)\n            if xisconst and yisconst:\n                xtv = x.get_src()\n                ytv = y.get_src()\n                is_combinable_tv = (\n                    xtv.get_unit() == ytv.get_unit()\n                    and xtv.is_max_level() == ytv.is_max_level()\n                    and xtv.is_zero_one_profile() == ytv.is_zero_one_profile()\n                    and xtv.get_reference_period() == ytv.get_reference_period()\n                )\n                if is_combinable_tv:\n                    is_combinable_expr = (\n                        x.is_level() == y.is_level()\n                        and x.is_profile() == y.is_profile()\n                        and x.is_flow() == y.is_flow()\n                        and x.is_stock() == y.is_stock()\n                        and x.get_profile() == y.get_profile()\n                    )\n                    if is_combinable_expr:\n                        xscalar = xtv.get_vector(is_float32=True)[0]\n                        yscalar = ytv.get_vector(is_float32=True)[0]\n                        if op == \"+\":\n                            scalar = xscalar + yscalar\n                        elif op == \"-\":\n                            scalar = xscalar - yscalar\n                        elif op == \"*\":\n                            scalar = xscalar * yscalar\n                        elif op == \"/\":\n                            scalar = xscalar / yscalar\n                        return Expr(\n                            src=ConstantTimeVector(\n                                scalar=scalar,\n                                unit=xtv.get_unit(),\n                                is_max_level=xtv.is_max_level(),\n                                is_zero_one_profile=xtv.is_zero_one_profile(),\n                                reference_period=xtv.get_reference_period(),\n                            ),\n                            is_stock=x.is_stock(),\n                            is_flow=x.is_flow(),\n                            is_profile=x.is_profile(),\n                            is_level=x.is_level(),\n                            profile=x.get_profile(),\n                            operations=None,\n                        )\n\n            ops, args = x.get_operations(expect_ops=False, copy_list=True)\n\n            if not ops:\n                ops = op\n                args = [x, y]\n            else:\n                last_op = ops[-1]\n                if last_op == op or (op in \"+-\" and last_op in \"+-\") or (last_op == \"*\" and op == \"/\"):\n                    ops = f\"{ops}{op}\"\n                    args.append(y)\n                else:\n                    ops = op\n                    args = [x, y]\n\n            return Expr(\n                src=None,\n                is_flow=is_flow,\n                is_stock=is_stock,\n                is_level=is_level,\n                is_profile=is_profile,\n                profile=profile,\n                operations=(ops, args),\n            )\n\n        if self._is_number(other):\n            if op in \"*/\":\n                other_expr = Expr(src=ConstantTimeVector(float(other), is_max_level=False))\n                return self._create_op_expr(op=op, other=other_expr, is_rhs=is_rhs)\n\n            if op in \"+\" and other == 0:  # Comes from sum(expr_list). See sum() noqa\n                return self  # TODO: Also accept 0 - Expr and -Expr?\n\n            message = f\"Only support multiplication and division with numbers, got {op} and {other}.\"\n            raise ValueError(message)\n\n        message = f\"Only support Expr, int, float. Got unsupported type {type(other).__name__}.\"\n        raise TypeError(message)\n\n    def __add__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"+\", other, is_rhs=False)\n\n    def __sub__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"-\", other, is_rhs=False)\n\n    def __mul__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"*\", other, is_rhs=False)\n\n    def __truediv__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"/\", other, is_rhs=False)\n\n    def __radd__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"+\", other, is_rhs=True)\n\n    def __rsub__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"-\", other, is_rhs=True)\n\n    def __rmul__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"*\", other, is_rhs=True)\n\n    def __rtruediv__(self, other: object) -&gt; Expr:  # noqa: D105\n        return self._create_op_expr(\"/\", other, is_rhs=True)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Represent Expr as str.\"\"\"\n        if self._src is not None:\n            return f\"Expr({self._src})\"\n        ops, args = self.get_operations(expect_ops=True, copy_list=False)\n        out = f\"{args[0]}\"\n        for op, arg in zip(ops, args[1:], strict=True):\n            out = f\"{out} {op} {arg}\"\n        return f\"Expr({out})\"\n\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Check if self and other are equal.\"\"\"\n        if not isinstance(other, type(self)):\n            return False\n        return (\n            self._is_flow == other._is_flow\n            and self._is_level == other._is_level\n            and self._src == other._src\n            and self._is_stock == other._is_stock\n            and self._is_profile == other._is_profile\n            and self._profile == other._profile\n            and self._operations[0] == other._operations[0]\n            and len(self._operations[1]) == len(other._operations[1])\n            and all([self._operations[1][i] == other._operations[1][i] for i in range(len(self._operations[1]))])  # noqa: SLF001\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute hash value..\"\"\"\n        return hash(\n            (\n                self._is_flow,\n                self._is_stock,\n                self._is_level,\n                self._is_profile,\n                self._src,\n                self._profile,\n                self._operations[0],\n                tuple(self._operations[1]),\n            ),\n        )\n\n    def add_loaders(self, loaders: set[Loader]) -&gt; None:\n        \"\"\"Add all loaders stored in TimeVector or Curve within Expr to loaders.\"\"\"\n        if self.is_leaf():\n            src = self.get_src()\n            if isinstance(src, TimeVector | LoadedCurve):\n                loader = src.get_loader()\n                if loader is not None:\n                    loaders.add(loader)\n            return\n        __, args = self.get_operations(expect_ops=True, copy_list=False)\n        for arg in args:\n            arg.add_loaders(loaders)\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Check if self and other are equal.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Check if self and other are equal.\"\"\"\n    if not isinstance(other, type(self)):\n        return False\n    return (\n        self._is_flow == other._is_flow\n        and self._is_level == other._is_level\n        and self._src == other._src\n        and self._is_stock == other._is_stock\n        and self._is_profile == other._is_profile\n        and self._profile == other._profile\n        and self._operations[0] == other._operations[0]\n        and len(self._operations[1]) == len(other._operations[1])\n        and all([self._operations[1][i] == other._operations[1][i] for i in range(len(self._operations[1]))])  # noqa: SLF001\n    )\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Compute hash value..</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute hash value..\"\"\"\n    return hash(\n        (\n            self._is_flow,\n            self._is_stock,\n            self._is_level,\n            self._is_profile,\n            self._src,\n            self._profile,\n            self._operations[0],\n            tuple(self._operations[1]),\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.__init__","title":"<code>__init__(src: str | Curve | TimeVector | None = None, is_stock: bool = False, is_flow: bool = False, is_profile: bool = False, is_level: bool = False, profile: Expr | None = None, operations: tuple[str, list[Expr]] | None = None) -&gt; None</code>","text":"<p>Create new (immutable) Expression.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str | Curve | TimeVector | None</code> <p>Source of the values to be used in the Expression. Either a Curve or TimeVector object, or a reference to one of them. Defaults to None.</p> <code>None</code> <code>is_stock</code> <code>bool</code> <p>Flag to signify if the Expr represents a stock type variable. Defaults to False.</p> <code>False</code> <code>is_flow</code> <code>bool</code> <p>Flag to signify if the Expr represents a flow type variable. Defaults to False.</p> <code>False</code> <code>is_profile</code> <code>bool</code> <p>Flag to signify if the Expr represents a profile. Defaults to False.</p> <code>False</code> <code>is_level</code> <code>bool</code> <p>Flag to signify if the Expr represents a level. Defaults to False.</p> <code>False</code> <code>profile</code> <code>Expr | None</code> <p>Expr that are Level can contain its connected Profile Expr. This is used in the queries to evaluate Levels according to their ReferencePeriod, and convert between Level formats (max level or average level, see LevelProfile for more details).</p> <code>None</code> <code>operations</code> <code>tuple[str, list[Expr]] | None</code> <p>Operations to apply to the expression. Defaults to None.</p> <code>None</code> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def __init__(\n    self,\n    src: str | Curve | TimeVector | None = None,\n    is_stock: bool = False,\n    is_flow: bool = False,\n    is_profile: bool = False,\n    is_level: bool = False,\n    profile: Expr | None = None,\n    operations: tuple[str, list[Expr]] | None = None,\n) -&gt; None:\n    \"\"\"\n    Create new (immutable) Expression.\n\n    Args:\n        src (str | Curve | TimeVector | None, optional): Source of the values to be used in the Expression. Either a Curve or TimeVector object,\n          or a reference to one of them. Defaults to None.\n        is_stock (bool, optional): Flag to signify if the Expr represents a stock type variable. Defaults to False.\n        is_flow (bool, optional): Flag to signify if the Expr represents a flow type variable. Defaults to False.\n        is_profile (bool, optional): Flag to signify if the Expr represents a profile. Defaults to False.\n        is_level (bool, optional): Flag to signify if the Expr represents a level. Defaults to False.\n        profile (Expr | None, optional): Expr that are Level can contain its connected Profile Expr. This is used in the queries to evaluate\n            Levels according to their ReferencePeriod, and convert between Level formats (max level or average level, see LevelProfile for more details).\n        operations (tuple[str, list[Expr]] | None, optional): Operations to apply to the expression. Defaults to None.\n\n    \"\"\"\n    if is_level and is_profile:\n        message = \"Expr cannot be both level and a profile. Set either is_level or is_profile True or both False.\"\n        raise ValueError(message)\n\n    if is_flow and is_stock:\n        message = \"Expr cannot be both flow and stock. Set either is_flow or is_stock True or both False.\"\n        raise ValueError(message)\n\n    if is_profile and (is_flow or is_stock):\n        message = \"Expr cannot be both a profile and a flow/stock. Profiles must be coefficients.\"\n        raise ValueError(message)\n\n    self._src: str | Curve | TimeVector | None = src\n    self._is_stock = is_stock\n    self._is_flow = is_flow\n    self._is_profile = is_profile\n    self._is_level = is_level\n    self._profile = profile\n\n    # have to come after setting fields\n    # because fields are used to create\n    # error messages e.g. in __repr__\n\n    self._check_type(src, (str, Curve, TimeVector, type(None)))\n    self._check_type(is_stock, (bool, type(None)))\n    self._check_type(is_flow, (bool, type(None)))\n    self._check_type(is_level, (bool, type(None)))\n    self._check_type(is_profile, (bool, type(None)))\n    self._check_type(profile, (Expr, type(None)))\n\n    self._check_operations(operations)\n    if operations is None:\n        operations = \"\", []\n    self._operations: tuple[str, list[Expr]] = operations\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Represent Expr as str.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Represent Expr as str.\"\"\"\n    if self._src is not None:\n        return f\"Expr({self._src})\"\n    ops, args = self.get_operations(expect_ops=True, copy_list=False)\n    out = f\"{args[0]}\"\n    for op, arg in zip(ops, args[1:], strict=True):\n        out = f\"{out} {op} {arg}\"\n    return f\"Expr({out})\"\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.add_loaders","title":"<code>add_loaders(loaders: set[Loader]) -&gt; None</code>","text":"<p>Add all loaders stored in TimeVector or Curve within Expr to loaders.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def add_loaders(self, loaders: set[Loader]) -&gt; None:\n    \"\"\"Add all loaders stored in TimeVector or Curve within Expr to loaders.\"\"\"\n    if self.is_leaf():\n        src = self.get_src()\n        if isinstance(src, TimeVector | LoadedCurve):\n            loader = src.get_loader()\n            if loader is not None:\n                loaders.add(loader)\n        return\n    __, args = self.get_operations(expect_ops=True, copy_list=False)\n    for arg in args:\n        arg.add_loaders(loaders)\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Return fingerprint.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Return fingerprint.\"\"\"\n    fingerprint = Fingerprint(self)\n    fingerprint.add(\"is_stock\", self._is_stock)\n    fingerprint.add(\"is_flow\", self._is_flow)\n    fingerprint.add(\"is_profile\", self._is_profile)\n    fingerprint.add(\"is_level\", self._is_level)\n    fingerprint.add(\"profile\", self._profile)\n    if self._src:\n        fingerprint.add(\"src\", self._src.get_fingerprint() if isinstance(self._src, TimeVector) else FingerprintRef(self._src))\n    fingerprint.add(\"operations\", self._operations)\n    return fingerprint\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.get_operations","title":"<code>get_operations(expect_ops: bool, copy_list: bool) -&gt; tuple[str, list[Expr]]</code>","text":"<p>Return ops, args. Users of this (low level) API must supply expect_ops and copy_list args.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_operations(self, expect_ops: bool, copy_list: bool) -&gt; tuple[str, list[Expr]]:\n    \"\"\"Return ops, args. Users of this (low level) API must supply expect_ops and copy_list args.\"\"\"\n    self._check_type(copy_list, bool)\n    self._verify_operations(expect_ops)\n    if copy_list:\n        ops, args = self._operations\n        return ops, copy(args)\n    return self._operations\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.get_profile","title":"<code>get_profile() -&gt; Expr | None</code>","text":"<p>Return Expr representing profile. Implies self.is_level() is True.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_profile(self) -&gt; Expr | None:\n    \"\"\"Return Expr representing profile. Implies self.is_level() is True.\"\"\"\n    return self._profile\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.get_src","title":"<code>get_src() -&gt; str | Curve | TimeVector | None</code>","text":"<p>Return str, Curve or TimeVector (either reference to Curve/TimeVector or Curve/TimeVector itself) or None if self is an operation expression.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_src(self) -&gt; str | Curve | TimeVector | None:\n    \"\"\"Return str, Curve or TimeVector (either reference to Curve/TimeVector or Curve/TimeVector itself) or None if self is an operation expression.\"\"\"\n    return self._src\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.is_flow","title":"<code>is_flow() -&gt; bool</code>","text":"<p>Return True if flow. Cannot be stock and flow.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def is_flow(self) -&gt; bool:\n    \"\"\"Return True if flow. Cannot be stock and flow.\"\"\"\n    return self._is_flow\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.is_leaf","title":"<code>is_leaf() -&gt; bool</code>","text":"<p>Return True if self is not an operation expression.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def is_leaf(self) -&gt; bool:\n    \"\"\"Return True if self is not an operation expression.\"\"\"\n    return self._src is not None\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.is_level","title":"<code>is_level() -&gt; bool</code>","text":"<p>Return True if level. Cannot be level and profile.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def is_level(self) -&gt; bool:\n    \"\"\"Return True if level. Cannot be level and profile.\"\"\"\n    return self._is_level\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.is_profile","title":"<code>is_profile() -&gt; bool</code>","text":"<p>Return True if profile. Cannot be level and profile.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def is_profile(self) -&gt; bool:\n    \"\"\"Return True if profile. Cannot be level and profile.\"\"\"\n    return self._is_profile\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.is_stock","title":"<code>is_stock() -&gt; bool</code>","text":"<p>Return True if stock. Cannot be stock and flow.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def is_stock(self) -&gt; bool:\n    \"\"\"Return True if stock. Cannot be stock and flow.\"\"\"\n    return self._is_stock\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.Expr.set_profile","title":"<code>set_profile(profile: Expr | None) -&gt; None</code>","text":"<p>Set the profile of the Expr. Implies self.is_level() is True.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def set_profile(self, profile: Expr | None) -&gt; None:\n    \"\"\"Set the profile of the Expr. Implies self.is_level() is True.\"\"\"\n    if not self.is_level():\n        raise ValueError(\"Cannot set profile on Expr that is not a level.\")\n    self._profile = profile\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.ensure_expr","title":"<code>ensure_expr(value: Expr | str | Curve | TimeVector | None, is_flow: bool = False, is_stock: bool = False, is_level: bool = False, is_profile: bool = False, profile: Expr | None = None) -&gt; Expr | None</code>","text":"<p>Ensure that the value is an expression of the expected type or create one if possible.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Expr | str | None</code> <p>The value to check.</p> required <code>is_flow</code> <code>str</code> <p>If the Expr is a flow. Cannot be True if is_stock is True.</p> <code>False</code> <code>is_stock</code> <code>str</code> <p>If the Expr is a stock. Cannot be True if is_flow is True.</p> <code>False</code> <code>is_level</code> <code>bool</code> <p>Wether the Expr represents a level. Cannot be True if is_profile is True.</p> <code>False</code> <code>is_profile</code> <code>bool</code> <p>Wether the Expr represents a profile. Cannot be True if is_level is True.</p> <code>False</code> <code>profile</code> <code>Expr | None</code> <p>If the Expr is a level, this should be its profile.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Expr | str</code> <p>The value as an expression of the expected type or None.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def ensure_expr(\n    value: Expr | str | Curve | TimeVector | None,  # technically anything that can be converted to float. Typehint for this?\n    is_flow: bool = False,\n    is_stock: bool = False,\n    is_level: bool = False,\n    is_profile: bool = False,\n    profile: Expr | None = None,\n) -&gt; Expr | None:\n    \"\"\"\n    Ensure that the value is an expression of the expected type or create one if possible.\n\n    Args:\n        value (Expr | str | None): The value to check.\n        is_flow (str): If the Expr is a flow. Cannot be True if is_stock is True.\n        is_stock (str): If the Expr is a stock. Cannot be True if is_flow is True.\n        is_level (bool): Wether the Expr represents a level. Cannot be True if is_profile is True.\n        is_profile (bool): Wether the Expr represents a profile. Cannot be True if is_level is True.\n        profile (Expr | None): If the Expr is a level, this should be its profile.\n\n    Returns:\n        value (Expr | str): The value as an expression of the expected type or None.\n\n    \"\"\"\n    if not isinstance(value, (str, Expr, Curve, TimeVector)) and value is not None:\n        msg = f\"Expected value to be of type Expr, str, Curve, TimeVector or None. Got {type(value).__name__}.\"\n        raise TypeError(msg)\n\n    if value is None:\n        return None\n\n    if isinstance(value, Expr):\n        # Check wether given Expr matches expected flow, stock, profile and level status.\n        if value.is_flow() != is_flow or value.is_stock() != is_stock or value.is_level() != is_level or value.is_profile() != is_profile:\n            message = (\n                \"Given Expr has a mismatch between expected and actual flow/stock or level/profile status:\\nExpected: \"\n                f\"is_flow - {is_flow}, is_stock - {is_stock}, is_level - {is_level}, is_profile - {is_profile}\\n\"\n                f\"Actual: is_flow - {value.is_flow()}, is_stock - {value.is_stock()}, \"\n                f\"is_level - {value.is_level()}, is_profile - {value.is_profile()}\"\n            )\n            raise ValueError(message)\n        return value\n\n    return Expr(\n        src=value,\n        is_flow=is_flow,\n        is_stock=is_stock,\n        is_level=is_level,\n        is_profile=is_profile,\n        profile=profile,\n    )\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.get_leaf_profiles","title":"<code>get_leaf_profiles(expr: Expr) -&gt; list[Expr]</code>","text":"<p>Get all leaf profile expressions from an Expr object.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>The starting Expr object.</p> required <p>Returns:</p> Type Description <code>list[Expr]</code> <p>list[Expr]: A list of leaf profile expressions.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_leaf_profiles(expr: Expr) -&gt; list[Expr]:\n    \"\"\"\n    Get all leaf profile expressions from an Expr object.\n\n    Args:\n        expr (Expr): The starting Expr object.\n\n    Returns:\n        list[Expr]: A list of leaf profile expressions.\n\n    \"\"\"\n    leaf_profiles = []\n\n    def _traverse(expr: Expr) -&gt; None:\n        if expr.is_leaf():\n            if expr.is_profile():\n                leaf_profiles.append(expr)\n            return\n\n        # Recursively traverse the arguments of the expression\n        _, args = expr.get_operations(expect_ops=False, copy_list=False)\n        for arg in args:\n            _traverse(arg)\n\n    _traverse(expr)\n    return leaf_profiles\n</code></pre>"},{"location":"reference/#framcore.expressions.Expr.get_profile_exprs_from_leaf_levels","title":"<code>get_profile_exprs_from_leaf_levels(expr: Expr) -&gt; list[Expr]</code>","text":"<p>Get all profile expressions from leaf-level Expr objects that are marked as levels.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>The starting Expr object.</p> required <p>Returns:</p> Type Description <code>list[Expr]</code> <p>list[Expr]: A list of profile expressions from leaf-level Expr objects.</p> Source code in <code>framcore/expressions/Expr.py</code> <pre><code>def get_profile_exprs_from_leaf_levels(expr: Expr) -&gt; list[Expr]:\n    \"\"\"\n    Get all profile expressions from leaf-level Expr objects that are marked as levels.\n\n    Args:\n        expr (Expr): The starting Expr object.\n\n    Returns:\n        list[Expr]: A list of profile expressions from leaf-level Expr objects.\n\n    \"\"\"\n    profile_exprs = []\n\n    def _traverse(expr: Expr) -&gt; None:\n        if expr.is_leaf():\n            if expr.is_level() and expr.get_profile() is not None:\n                profile_exprs.append(expr.get_profile())\n            return\n\n        # Recursively traverse the arguments of the expression\n        _, args = expr.get_operations(expect_ops=False, copy_list=False)\n        for arg in args:\n            _traverse(arg)\n\n    _traverse(expr)\n    return profile_exprs\n</code></pre>"},{"location":"reference/#framcore.expressions.queries","title":"<code>queries</code>","text":""},{"location":"reference/#framcore.expressions.queries.get_level_value","title":"<code>get_level_value(expr: Expr, db: QueryDB | Model, unit: str | None, data_dim: SinglePeriodTimeIndex, scen_dim: FixedFrequencyTimeIndex, is_max: bool) -&gt; float</code>","text":"<p>Evaluate Expr representing a (possibly aggregated) level.</p> <p>The follwing will be automatically handled for you: - fetching from different data objecs (from db) - conversion to requested unit - query at requested TimeIndex for data and scenario dimension, and with requested reference period - conversion to requested level type (is_max or is_avg)</p> <p>Supports all expressions. Will evaluate level Exprs at data_dim (with reference period of scen_dim), and profile Exprs as an average over scen_dim (both as constants). Has optimized fastpath methods for sums, products and aggregations. The rest uses a fallback method with SymPy.</p> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_level_value(\n    expr: Expr,\n    db: QueryDB | Model,\n    unit: str | None,\n    data_dim: SinglePeriodTimeIndex,\n    scen_dim: FixedFrequencyTimeIndex,\n    is_max: bool,\n) -&gt; float:\n    \"\"\"\n    Evaluate Expr representing a (possibly aggregated) level.\n\n    The follwing will be automatically handled for you:\n    - fetching from different data objecs (from db)\n    - conversion to requested unit\n    - query at requested TimeIndex for data and scenario dimension, and with requested reference period\n    - conversion to requested level type (is_max or is_avg)\n\n    Supports all expressions. Will evaluate level Exprs at data_dim (with reference period of scen_dim),\n    and profile Exprs as an average over scen_dim (both as constants). Has optimized fastpath methods for sums, products and aggregations.\n    The rest uses a fallback method with SymPy.\n\n    \"\"\"\n    check_type(expr, Expr)  # check expr here since _get_level_value is not recursively called.\n    check_type(unit, (str, type(None)))\n    check_type(data_dim, SinglePeriodTimeIndex)\n    check_type(scen_dim, FixedFrequencyTimeIndex)\n    check_type(is_max, bool)\n    db = _load_model_and_create_model_db(db)\n\n    return _get_level_value(expr, db, unit, data_dim, scen_dim, is_max)\n</code></pre>"},{"location":"reference/#framcore.expressions.queries.get_profile_vector","title":"<code>get_profile_vector(expr: Expr, db: QueryDB | Model, data_dim: SinglePeriodTimeIndex, scen_dim: FixedFrequencyTimeIndex, is_zero_one: bool, is_float32: bool = True) -&gt; NDArray</code>","text":"<p>Evaluate expr representing a (possibly aggregated) profile.</p> <p>expr = sum(weight[i] * profile[i]) where</p> <pre><code>weight[i] &gt;= 0 and is unitless, and will be evaluated as a constant\nprofile[i] is a unitless profile expr\n\nprofile[i] is either \"zero_one\" or \"mean_one\" type of profile\n\n\"zero_one\" and \"mean_one\" profile type must be converted to the\nsame standard to be added correctly.\n\nThe query parameters data_dim and scen_dim are used to evaluate the values\nrequested TimeIndex for data and scenario dimension, and with requested reference period\n\nweight[i] will be evaluated level Exprs at data_dim (with reference period of scen_dim),\nand profile Exprs as an average over scen_dim (both as constants)\n\nprofile[i] will be evaluated as profile vectors over scen_dim\n\nThe query parameter is_zero_one tells which profile type the output\nvector should be converted to.\n</code></pre> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_profile_vector(\n    expr: Expr,\n    db: QueryDB | Model,\n    data_dim: SinglePeriodTimeIndex,\n    scen_dim: FixedFrequencyTimeIndex,\n    is_zero_one: bool,\n    is_float32: bool = True,\n) -&gt; NDArray:\n    \"\"\"\n    Evaluate expr representing a (possibly aggregated) profile.\n\n    expr = sum(weight[i] * profile[i]) where\n\n        weight[i] &gt;= 0 and is unitless, and will be evaluated as a constant\n        profile[i] is a unitless profile expr\n\n        profile[i] is either \"zero_one\" or \"mean_one\" type of profile\n\n        \"zero_one\" and \"mean_one\" profile type must be converted to the\n        same standard to be added correctly.\n\n        The query parameters data_dim and scen_dim are used to evaluate the values\n        requested TimeIndex for data and scenario dimension, and with requested reference period\n\n        weight[i] will be evaluated level Exprs at data_dim (with reference period of scen_dim),\n        and profile Exprs as an average over scen_dim (both as constants)\n\n        profile[i] will be evaluated as profile vectors over scen_dim\n\n        The query parameter is_zero_one tells which profile type the output\n        vector should be converted to.\n    \"\"\"\n    # Argument expr checked in _get_profile_vector since it can be recursively called.\n    check_type(data_dim, SinglePeriodTimeIndex)\n    check_type(scen_dim, FixedFrequencyTimeIndex)\n    check_type(is_zero_one, bool)\n    check_type(is_float32, bool)\n    db = _load_model_and_create_model_db(db)\n\n    return _get_profile_vector(expr, db, data_dim, scen_dim, is_zero_one, is_float32)\n</code></pre>"},{"location":"reference/#framcore.expressions.queries.get_timeindexes_from_expr","title":"<code>get_timeindexes_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[TimeIndex]</code>","text":"<p>Find all timeindexes behind an expression.</p> <p>Useful for optimized queries (not asking for more data than necessary).</p> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_timeindexes_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[TimeIndex]:\n    \"\"\"\n    Find all timeindexes behind an expression.\n\n    Useful for optimized queries (not asking for more data than necessary).\n    \"\"\"\n    db = _load_model_and_create_model_db(db)\n\n    timeindexes: set[TimeIndex] = set()\n\n    _recursively_update_timeindexes(timeindexes, db, expr)\n\n    return timeindexes\n</code></pre>"},{"location":"reference/#framcore.expressions.queries.get_units_from_expr","title":"<code>get_units_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[str]</code>","text":"<p>Find all units behind an expression. Useful for queries involving conversion factors.</p> Source code in <code>framcore/expressions/queries.py</code> <pre><code>def get_units_from_expr(db: QueryDB | Model, expr: Expr) -&gt; set[str]:\n    \"\"\"Find all units behind an expression. Useful for queries involving conversion factors.\"\"\"\n    db = _load_model_and_create_model_db(db)\n\n    units: set[str] = set()\n\n    _recursively_update_units(units, db, expr)\n\n    return units\n</code></pre>"},{"location":"reference/#framcore.expressions.units","title":"<code>units</code>","text":"<p>Define units used in the system, their handling and conversion rules.</p> <p>We use SymPy to support unit conversions. Already computed unit conversion factors are cached to minimize redundant calculations.</p>"},{"location":"reference/#framcore.expressions.units.get_unit_conversion_factor","title":"<code>get_unit_conversion_factor(from_unit: str | None, to_unit: str | None) -&gt; float</code>","text":"<p>Get the conversion factor from one unit to another.</p> Source code in <code>framcore/expressions/units.py</code> <pre><code>def get_unit_conversion_factor(from_unit: str | None, to_unit: str | None) -&gt; float:  # noqa C901\n    \"\"\"Get the conversion factor from one unit to another.\"\"\"\n    if from_unit == to_unit:\n        return 1.0\n\n    if from_unit is None or to_unit is None:\n        return _get_unit_conversion_factor_with_none(from_unit, to_unit)\n\n    fastpath = _fastpath_get_unit_conversion_factor(from_unit, to_unit)\n\n    if _DEBUG is False and fastpath is not None:\n        return fastpath\n\n    if fastpath is None:\n        has_multiplier = False\n        with contextlib.suppress(Exception):\n            ix = from_unit.index(\"*\")\n            multiplier = float(from_unit[:ix])\n            base_from_unit = from_unit[ix + 1 :].strip()\n            has_multiplier = True\n\n        if has_multiplier:\n            fastpath = _fastpath_get_unit_conversion_factor(base_from_unit, to_unit)\n            fastpath = fastpath if fastpath is None else fastpath * multiplier\n            if _DEBUG is False and fastpath is not None:\n                return fastpath\n\n    if _COLLECT_FASTPATH_DATA and fastpath is None:\n        if has_multiplier:\n            _OBSERVED_UNIT_CONVERSIONS.add((base_from_unit, to_unit))\n        else:\n            _OBSERVED_UNIT_CONVERSIONS.add((from_unit, to_unit))\n\n    fallback = _fallback_get_unit_conversion_factor(from_unit, to_unit)\n\n    if _DEBUG and fastpath is not None and fallback != fastpath:\n        message = f\"Different results!\\nfrom_unit {from_unit} to_unit {to_unit}\\nfastpath {fastpath} fallback {fallback}\"\n        raise RuntimeError(message)\n\n    if _unit_has_no_floats(from_unit) and _unit_has_no_floats(to_unit):\n        _FASTPATH_CONVERSION_FACTORS[(from_unit, to_unit)] = fallback\n\n    return fallback\n</code></pre>"},{"location":"reference/#framcore.expressions.units.is_convertable","title":"<code>is_convertable(unit_from: str, unit_to: str) -&gt; bool</code>","text":"<p>Return True if from_unit can be converted to to_unit else False.</p> Source code in <code>framcore/expressions/units.py</code> <pre><code>def is_convertable(unit_from: str, unit_to: str) -&gt; bool:\n    \"\"\"Return True if from_unit can be converted to to_unit else False.\"\"\"\n    with contextlib.suppress(Exception):\n        get_unit_conversion_factor(unit_from, unit_to)\n        return True\n    return False\n</code></pre>"},{"location":"reference/#framcore.expressions.units.validate_unit_conversion_fastpaths","title":"<code>validate_unit_conversion_fastpaths() -&gt; bool</code>","text":"<p>Run-Time validation of fastpaths.</p> Source code in <code>framcore/expressions/units.py</code> <pre><code>def validate_unit_conversion_fastpaths() -&gt; bool:\n    \"\"\"Run-Time validation of fastpaths.\"\"\"\n    errors = []\n    for (from_unit, to_unit), result in _FASTPATH_CONVERSION_FACTORS.items():\n        sympy_result = None\n        with contextlib.suppress(Exception):\n            sympy_result = _fallback_get_unit_conversion_factor(from_unit, to_unit)\n        if result != sympy_result:\n            message = f\"'{from_unit}' to '{to_unit}' failed. Fastpath: {result}, SymPy: {sympy_result}\"\n            errors.append(message)\n    for from_unit, to_unit in _FASTPATH_INCOMPATIBLE_CONVERSIONS:\n        with contextlib.suppress(Exception):\n            sympy_result = _fallback_get_unit_conversion_factor(from_unit, to_unit)\n            message = f\"'{from_unit}' to '{to_unit}'. Fastpath claim incompatible units, but SymPy fallback returned {sympy_result}\"\n            errors.append(message)\n    if errors:\n        message = \"\\n\".join(errors)\n        raise RuntimeError(message)\n</code></pre>"},{"location":"reference/#framcore.fingerprints","title":"<code>fingerprints</code>","text":""},{"location":"reference/#framcore.fingerprints.Fingerprint","title":"<code>Fingerprint</code>","text":"<p>Fingerprint of various data structures.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class Fingerprint:\n    \"\"\"Fingerprint of various data structures.\"\"\"\n\n    def __init__(self, source: object = None) -&gt; None:\n        \"\"\"\n        Initialize a Fingerprint instance.\n\n        Args:\n            source (object, optional): The source object to fingerprint. Defaults to None.\n\n        \"\"\"\n        self._nested = {}\n        self._hash = None\n        self._source = source\n\n    def add(self, key: str, value: object) -&gt; None:\n        \"\"\"\n        Add a value to the fingerprint under the specified key.\n\n        Args:\n            key (str): The key to associate with the value.\n            value: The value to add, which can be a Fingerprint, FingerprintRef, or other supported types.\n\n        Returns:\n            None\n\n        \"\"\"\n        assert key not in self._nested\n\n        if isinstance(value, Fingerprint | FingerprintRef):\n            self._nested[key] = value\n        elif hasattr(value, \"get_fingerprint\"):\n            self.add(key, value.get_fingerprint())\n        elif isinstance(value, list | tuple | set):\n            self.add(key, self._fingerprint_from_list(value))\n        elif isinstance(value, dict):\n            self.add(key, self._fingerprint_from_dict(value))\n        else:\n            self._nested[key] = _custom_hash(value)\n\n        self._hash = None\n\n    def _fingerprint_from_list(self, items: list | tuple | set) -&gt; Fingerprint:\n        fingerprint = Fingerprint()\n        for index, value in enumerate(items):\n            fingerprint.add(f\"{index}\", value)\n        return fingerprint\n\n    def _fingerprint_from_dict(self, a_dict: dict) -&gt; Fingerprint:\n        fingerprint = Fingerprint()\n        for key, value in a_dict.items():\n            fingerprint.add(f\"{key}\", value)\n        return fingerprint\n\n    def add_ref(self, prop: str, ref_key: str) -&gt; None:\n        \"\"\"\n        Add a FingerprintRef to the fingerprint under the specified property key.\n\n        Args:\n            prop (str): The property key to associate with the reference.\n            ref_key (str): The key referencing another fingerprint.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.add(prop, FingerprintRef(ref_key))\n\n    def get_parts(self) -&gt; dict:\n        \"\"\"\n        Return the dictionary of parts contained in the fingerprint.\n\n        Returns:\n            dict: A dictionary mapping keys to their associated fingerprint parts.\n\n        \"\"\"\n        return {k: v for k, v in self._nested.items()}\n\n    def update_ref(self, ref_key: str, fingerprint: Fingerprint) -&gt; None:\n        \"\"\"\n        Update the reference at the given key with a new Fingerprint.\n\n        Args:\n            ref_key (str): The key referencing the FingerprintRef to update.\n            fingerprint (Fingerprint): The new Fingerprint to set at the reference.\n\n        Returns:\n            None\n\n        \"\"\"\n        assert ref_key in self._nested\n        assert isinstance(self._nested[ref_key], FingerprintRef)\n\n        self._nested[ref_key] = fingerprint\n        self._hash = None\n\n    def get_hash(self) -&gt; str:\n        \"\"\"\n        Return the hash value of the fingerprint.\n\n        Returns:\n            str: The computed hash value representing the fingerprint.\n\n        \"\"\"\n        self._resolve_total_hash()\n        return self._hash\n\n    def _contains_refs(self) -&gt; bool:\n        return any(isinstance(v, FingerprintRef) for v in self._nested.values())\n\n    def _contains_key(self, key: str) -&gt; bool:\n        return key in self._nested\n\n    def _resolve_total_hash(self) -&gt; None:\n        parts = []\n        for k, v in self._nested.items():\n            if isinstance(v, Fingerprint):\n                parts.append((k, v.get_hash()))\n            elif isinstance(v, FingerprintRef):\n                parts.append((k, f\"#ref:{v.get_key()}\"))\n            else:\n                parts.append((k, v))\n\n        self._hash = _custom_hash(sorted(parts))\n\n    def diff(self, other: Fingerprint | None) -&gt; FingerprintDiff:\n        \"\"\"Return differences between this and other fingerprint.\"\"\"\n        diff = FingerprintDiff()\n\n        if other is None:\n            for parent_key, parent_value in self.get_parts().items():\n                if isinstance(parent_value, Fingerprint):\n                    diff.add_diff(parent_key, FingerprintDiffType.NEW, parent_value._source)  # noqa: SLF001\n                    diff.update(parent_value.diff(None))\n            return diff\n\n        if self.get_hash() == other.get_hash():\n            return diff\n\n        self_parts: dict[str, Fingerprint] = {\n            key: value for key, value in self.get_parts().items() if isinstance(value, Fingerprint)\n        }\n        other_parts: dict[str, Fingerprint] = {\n            key: value for key, value in other.get_parts().items() if isinstance(value, Fingerprint)\n        }\n\n        # Check for new or modified keys\n        for key, value in self_parts.items():\n            if key not in other_parts:\n                diff.add_diff(key, FingerprintDiffType.NEW, value._source)  # noqa: SLF001\n                diff.update(value.diff(None))\n            elif value.get_hash() != other_parts[key].get_hash():\n                diff.add_diff(key, FingerprintDiffType.MODIFIED, value._source)  # noqa: SLF001\n                diff.update(value.diff(other_parts[key]))\n\n        # Check for deleted keys\n        for key in other_parts.keys() - self_parts.keys():\n            other_value = other_parts[key]\n            diff.add_diff(key, FingerprintDiffType.DELETED, other_value._source)  # noqa: SLF001\n            source = self  # TODO: Is this correct?\n            diff.update(Fingerprint(source).diff(other_value))\n\n        return diff\n\n    def __eq__(self, other: Fingerprint) -&gt; bool:\n        \"\"\"\n        Determine if two Fingerprint instances are equal based on their hash values.\n\n        Args:\n            other (Fingerprint): The other Fingerprint instance to compare.\n\n        Returns:\n            bool: True if the hash values are equal, False otherwise.\n\n        \"\"\"\n        return self.get_hash() == other.get_hash()\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.__eq__","title":"<code>__eq__(other: Fingerprint) -&gt; bool</code>","text":"<p>Determine if two Fingerprint instances are equal based on their hash values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Fingerprint</code> <p>The other Fingerprint instance to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the hash values are equal, False otherwise.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __eq__(self, other: Fingerprint) -&gt; bool:\n    \"\"\"\n    Determine if two Fingerprint instances are equal based on their hash values.\n\n    Args:\n        other (Fingerprint): The other Fingerprint instance to compare.\n\n    Returns:\n        bool: True if the hash values are equal, False otherwise.\n\n    \"\"\"\n    return self.get_hash() == other.get_hash()\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.__init__","title":"<code>__init__(source: object = None) -&gt; None</code>","text":"<p>Initialize a Fingerprint instance.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>object</code> <p>The source object to fingerprint. Defaults to None.</p> <code>None</code> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __init__(self, source: object = None) -&gt; None:\n    \"\"\"\n    Initialize a Fingerprint instance.\n\n    Args:\n        source (object, optional): The source object to fingerprint. Defaults to None.\n\n    \"\"\"\n    self._nested = {}\n    self._hash = None\n    self._source = source\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.add","title":"<code>add(key: str, value: object) -&gt; None</code>","text":"<p>Add a value to the fingerprint under the specified key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to associate with the value.</p> required <code>value</code> <code>object</code> <p>The value to add, which can be a Fingerprint, FingerprintRef, or other supported types.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def add(self, key: str, value: object) -&gt; None:\n    \"\"\"\n    Add a value to the fingerprint under the specified key.\n\n    Args:\n        key (str): The key to associate with the value.\n        value: The value to add, which can be a Fingerprint, FingerprintRef, or other supported types.\n\n    Returns:\n        None\n\n    \"\"\"\n    assert key not in self._nested\n\n    if isinstance(value, Fingerprint | FingerprintRef):\n        self._nested[key] = value\n    elif hasattr(value, \"get_fingerprint\"):\n        self.add(key, value.get_fingerprint())\n    elif isinstance(value, list | tuple | set):\n        self.add(key, self._fingerprint_from_list(value))\n    elif isinstance(value, dict):\n        self.add(key, self._fingerprint_from_dict(value))\n    else:\n        self._nested[key] = _custom_hash(value)\n\n    self._hash = None\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.add_ref","title":"<code>add_ref(prop: str, ref_key: str) -&gt; None</code>","text":"<p>Add a FingerprintRef to the fingerprint under the specified property key.</p> <p>Parameters:</p> Name Type Description Default <code>prop</code> <code>str</code> <p>The property key to associate with the reference.</p> required <code>ref_key</code> <code>str</code> <p>The key referencing another fingerprint.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def add_ref(self, prop: str, ref_key: str) -&gt; None:\n    \"\"\"\n    Add a FingerprintRef to the fingerprint under the specified property key.\n\n    Args:\n        prop (str): The property key to associate with the reference.\n        ref_key (str): The key referencing another fingerprint.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.add(prop, FingerprintRef(ref_key))\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.diff","title":"<code>diff(other: Fingerprint | None) -&gt; FingerprintDiff</code>","text":"<p>Return differences between this and other fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def diff(self, other: Fingerprint | None) -&gt; FingerprintDiff:\n    \"\"\"Return differences between this and other fingerprint.\"\"\"\n    diff = FingerprintDiff()\n\n    if other is None:\n        for parent_key, parent_value in self.get_parts().items():\n            if isinstance(parent_value, Fingerprint):\n                diff.add_diff(parent_key, FingerprintDiffType.NEW, parent_value._source)  # noqa: SLF001\n                diff.update(parent_value.diff(None))\n        return diff\n\n    if self.get_hash() == other.get_hash():\n        return diff\n\n    self_parts: dict[str, Fingerprint] = {\n        key: value for key, value in self.get_parts().items() if isinstance(value, Fingerprint)\n    }\n    other_parts: dict[str, Fingerprint] = {\n        key: value for key, value in other.get_parts().items() if isinstance(value, Fingerprint)\n    }\n\n    # Check for new or modified keys\n    for key, value in self_parts.items():\n        if key not in other_parts:\n            diff.add_diff(key, FingerprintDiffType.NEW, value._source)  # noqa: SLF001\n            diff.update(value.diff(None))\n        elif value.get_hash() != other_parts[key].get_hash():\n            diff.add_diff(key, FingerprintDiffType.MODIFIED, value._source)  # noqa: SLF001\n            diff.update(value.diff(other_parts[key]))\n\n    # Check for deleted keys\n    for key in other_parts.keys() - self_parts.keys():\n        other_value = other_parts[key]\n        diff.add_diff(key, FingerprintDiffType.DELETED, other_value._source)  # noqa: SLF001\n        source = self  # TODO: Is this correct?\n        diff.update(Fingerprint(source).diff(other_value))\n\n    return diff\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.get_hash","title":"<code>get_hash() -&gt; str</code>","text":"<p>Return the hash value of the fingerprint.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The computed hash value representing the fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_hash(self) -&gt; str:\n    \"\"\"\n    Return the hash value of the fingerprint.\n\n    Returns:\n        str: The computed hash value representing the fingerprint.\n\n    \"\"\"\n    self._resolve_total_hash()\n    return self._hash\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.get_parts","title":"<code>get_parts() -&gt; dict</code>","text":"<p>Return the dictionary of parts contained in the fingerprint.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping keys to their associated fingerprint parts.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_parts(self) -&gt; dict:\n    \"\"\"\n    Return the dictionary of parts contained in the fingerprint.\n\n    Returns:\n        dict: A dictionary mapping keys to their associated fingerprint parts.\n\n    \"\"\"\n    return {k: v for k, v in self._nested.items()}\n</code></pre>"},{"location":"reference/#framcore.fingerprints.Fingerprint.update_ref","title":"<code>update_ref(ref_key: str, fingerprint: Fingerprint) -&gt; None</code>","text":"<p>Update the reference at the given key with a new Fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>ref_key</code> <code>str</code> <p>The key referencing the FingerprintRef to update.</p> required <code>fingerprint</code> <code>Fingerprint</code> <p>The new Fingerprint to set at the reference.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def update_ref(self, ref_key: str, fingerprint: Fingerprint) -&gt; None:\n    \"\"\"\n    Update the reference at the given key with a new Fingerprint.\n\n    Args:\n        ref_key (str): The key referencing the FingerprintRef to update.\n        fingerprint (Fingerprint): The new Fingerprint to set at the reference.\n\n    Returns:\n        None\n\n    \"\"\"\n    assert ref_key in self._nested\n    assert isinstance(self._nested[ref_key], FingerprintRef)\n\n    self._nested[ref_key] = fingerprint\n    self._hash = None\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintDiff","title":"<code>FingerprintDiff</code>","text":"<p>Differences between two fingerprints.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class FingerprintDiff:\n    \"\"\"Differences between two fingerprints.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty FingerprintDiff.\"\"\"\n        self._diffs: dict[str, tuple] = {}\n\n    def add_diff(\n        self,\n        key: str,\n        diff_type: FingerprintDiffType,\n        obj: object,\n    ) -&gt; None:\n        \"\"\"\n        Add a difference entry for a fingerprint.\n\n        Args:\n            key (str): The key identifying the fingerprint part.\n            diff_type (FingerprintDiffType): The type of difference (NEW, MODIFIED, DELETED).\n            obj: The object associated with the difference.\n\n        \"\"\"\n        from framcore.components.Component import Component\n        from framcore.curves.Curve import Curve\n        from framcore.timevectors.TimeVector import TimeVector\n\n        # Trenger vi denne sjekken, siden vi filtrerer ut alt som ikke er Fingerprint f\u00f8r vi kj\u00f8rer add_diff()?\n        if isinstance(obj, TimeVector | Curve | Component):\n            if key in self._diffs:\n                message = f\"duplicate entry: {key} ({obj})\"\n                print(message)\n\n            self._diffs[key] = (obj, diff_type)\n\n    def get_diffs(self) -&gt; dict[str, tuple]:\n        \"\"\"\n        Return the dictionary of differences.\n\n        Returns:\n            dict[str, tuple]: The differences stored in the FingerprintDiff.\n\n        \"\"\"\n        return self._diffs\n\n    def is_changed(self) -&gt; bool:\n        \"\"\"Return True if there are any differences.\"\"\"\n        return bool(self._diffs)\n\n    def update(self, other: FingerprintDiff) -&gt; None:\n        \"\"\"\n        Update this FingerprintDiff with differences from another FingerprintDiff.\n\n        Args:\n            other (FingerprintDiff): Another FingerprintDiff whose differences will be added.\n\n        \"\"\"\n        self._diffs.update(other.get_diffs())\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintDiff.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize an empty FingerprintDiff.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty FingerprintDiff.\"\"\"\n    self._diffs: dict[str, tuple] = {}\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintDiff.add_diff","title":"<code>add_diff(key: str, diff_type: FingerprintDiffType, obj: object) -&gt; None</code>","text":"<p>Add a difference entry for a fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key identifying the fingerprint part.</p> required <code>diff_type</code> <code>FingerprintDiffType</code> <p>The type of difference (NEW, MODIFIED, DELETED).</p> required <code>obj</code> <code>object</code> <p>The object associated with the difference.</p> required Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def add_diff(\n    self,\n    key: str,\n    diff_type: FingerprintDiffType,\n    obj: object,\n) -&gt; None:\n    \"\"\"\n    Add a difference entry for a fingerprint.\n\n    Args:\n        key (str): The key identifying the fingerprint part.\n        diff_type (FingerprintDiffType): The type of difference (NEW, MODIFIED, DELETED).\n        obj: The object associated with the difference.\n\n    \"\"\"\n    from framcore.components.Component import Component\n    from framcore.curves.Curve import Curve\n    from framcore.timevectors.TimeVector import TimeVector\n\n    # Trenger vi denne sjekken, siden vi filtrerer ut alt som ikke er Fingerprint f\u00f8r vi kj\u00f8rer add_diff()?\n    if isinstance(obj, TimeVector | Curve | Component):\n        if key in self._diffs:\n            message = f\"duplicate entry: {key} ({obj})\"\n            print(message)\n\n        self._diffs[key] = (obj, diff_type)\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintDiff.get_diffs","title":"<code>get_diffs() -&gt; dict[str, tuple]</code>","text":"<p>Return the dictionary of differences.</p> <p>Returns:</p> Type Description <code>dict[str, tuple]</code> <p>dict[str, tuple]: The differences stored in the FingerprintDiff.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_diffs(self) -&gt; dict[str, tuple]:\n    \"\"\"\n    Return the dictionary of differences.\n\n    Returns:\n        dict[str, tuple]: The differences stored in the FingerprintDiff.\n\n    \"\"\"\n    return self._diffs\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintDiff.is_changed","title":"<code>is_changed() -&gt; bool</code>","text":"<p>Return True if there are any differences.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def is_changed(self) -&gt; bool:\n    \"\"\"Return True if there are any differences.\"\"\"\n    return bool(self._diffs)\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintDiff.update","title":"<code>update(other: FingerprintDiff) -&gt; None</code>","text":"<p>Update this FingerprintDiff with differences from another FingerprintDiff.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FingerprintDiff</code> <p>Another FingerprintDiff whose differences will be added.</p> required Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def update(self, other: FingerprintDiff) -&gt; None:\n    \"\"\"\n    Update this FingerprintDiff with differences from another FingerprintDiff.\n\n    Args:\n        other (FingerprintDiff): Another FingerprintDiff whose differences will be added.\n\n    \"\"\"\n    self._diffs.update(other.get_diffs())\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintDiffType","title":"<code>FingerprintDiffType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of difference between two fingerprints.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class FingerprintDiffType(Enum):\n    \"\"\"Type of difference between two fingerprints.\"\"\"\n\n    NEW = \"new\"\n    MODIFIED = \"modified\"\n    DELETED = \"deleted\"\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintRef","title":"<code>FingerprintRef</code>","text":"<p>Refers to another fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class FingerprintRef:\n    \"\"\"Refers to another fingerprint.\"\"\"\n\n    def __init__(self, key: str) -&gt; None:\n        \"\"\"\n        Initialize a FingerprintRef with the given key.\n\n        Args:\n            key (str): The key referencing another fingerprint.\n\n        \"\"\"\n        self._key = key\n\n    def get_key(self) -&gt; str:\n        \"\"\"\n        Return the key referencing another fingerprint.\n\n        Returns:\n            str: The key referencing another fingerprint.\n\n        \"\"\"\n        return self._key\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintRef.__init__","title":"<code>__init__(key: str) -&gt; None</code>","text":"<p>Initialize a FingerprintRef with the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key referencing another fingerprint.</p> required Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __init__(self, key: str) -&gt; None:\n    \"\"\"\n    Initialize a FingerprintRef with the given key.\n\n    Args:\n        key (str): The key referencing another fingerprint.\n\n    \"\"\"\n    self._key = key\n</code></pre>"},{"location":"reference/#framcore.fingerprints.FingerprintRef.get_key","title":"<code>get_key() -&gt; str</code>","text":"<p>Return the key referencing another fingerprint.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The key referencing another fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_key(self) -&gt; str:\n    \"\"\"\n    Return the key referencing another fingerprint.\n\n    Returns:\n        str: The key referencing another fingerprint.\n\n    \"\"\"\n    return self._key\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint","title":"<code>fingerprint</code>","text":""},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint","title":"<code>Fingerprint</code>","text":"<p>Fingerprint of various data structures.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class Fingerprint:\n    \"\"\"Fingerprint of various data structures.\"\"\"\n\n    def __init__(self, source: object = None) -&gt; None:\n        \"\"\"\n        Initialize a Fingerprint instance.\n\n        Args:\n            source (object, optional): The source object to fingerprint. Defaults to None.\n\n        \"\"\"\n        self._nested = {}\n        self._hash = None\n        self._source = source\n\n    def add(self, key: str, value: object) -&gt; None:\n        \"\"\"\n        Add a value to the fingerprint under the specified key.\n\n        Args:\n            key (str): The key to associate with the value.\n            value: The value to add, which can be a Fingerprint, FingerprintRef, or other supported types.\n\n        Returns:\n            None\n\n        \"\"\"\n        assert key not in self._nested\n\n        if isinstance(value, Fingerprint | FingerprintRef):\n            self._nested[key] = value\n        elif hasattr(value, \"get_fingerprint\"):\n            self.add(key, value.get_fingerprint())\n        elif isinstance(value, list | tuple | set):\n            self.add(key, self._fingerprint_from_list(value))\n        elif isinstance(value, dict):\n            self.add(key, self._fingerprint_from_dict(value))\n        else:\n            self._nested[key] = _custom_hash(value)\n\n        self._hash = None\n\n    def _fingerprint_from_list(self, items: list | tuple | set) -&gt; Fingerprint:\n        fingerprint = Fingerprint()\n        for index, value in enumerate(items):\n            fingerprint.add(f\"{index}\", value)\n        return fingerprint\n\n    def _fingerprint_from_dict(self, a_dict: dict) -&gt; Fingerprint:\n        fingerprint = Fingerprint()\n        for key, value in a_dict.items():\n            fingerprint.add(f\"{key}\", value)\n        return fingerprint\n\n    def add_ref(self, prop: str, ref_key: str) -&gt; None:\n        \"\"\"\n        Add a FingerprintRef to the fingerprint under the specified property key.\n\n        Args:\n            prop (str): The property key to associate with the reference.\n            ref_key (str): The key referencing another fingerprint.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.add(prop, FingerprintRef(ref_key))\n\n    def get_parts(self) -&gt; dict:\n        \"\"\"\n        Return the dictionary of parts contained in the fingerprint.\n\n        Returns:\n            dict: A dictionary mapping keys to their associated fingerprint parts.\n\n        \"\"\"\n        return {k: v for k, v in self._nested.items()}\n\n    def update_ref(self, ref_key: str, fingerprint: Fingerprint) -&gt; None:\n        \"\"\"\n        Update the reference at the given key with a new Fingerprint.\n\n        Args:\n            ref_key (str): The key referencing the FingerprintRef to update.\n            fingerprint (Fingerprint): The new Fingerprint to set at the reference.\n\n        Returns:\n            None\n\n        \"\"\"\n        assert ref_key in self._nested\n        assert isinstance(self._nested[ref_key], FingerprintRef)\n\n        self._nested[ref_key] = fingerprint\n        self._hash = None\n\n    def get_hash(self) -&gt; str:\n        \"\"\"\n        Return the hash value of the fingerprint.\n\n        Returns:\n            str: The computed hash value representing the fingerprint.\n\n        \"\"\"\n        self._resolve_total_hash()\n        return self._hash\n\n    def _contains_refs(self) -&gt; bool:\n        return any(isinstance(v, FingerprintRef) for v in self._nested.values())\n\n    def _contains_key(self, key: str) -&gt; bool:\n        return key in self._nested\n\n    def _resolve_total_hash(self) -&gt; None:\n        parts = []\n        for k, v in self._nested.items():\n            if isinstance(v, Fingerprint):\n                parts.append((k, v.get_hash()))\n            elif isinstance(v, FingerprintRef):\n                parts.append((k, f\"#ref:{v.get_key()}\"))\n            else:\n                parts.append((k, v))\n\n        self._hash = _custom_hash(sorted(parts))\n\n    def diff(self, other: Fingerprint | None) -&gt; FingerprintDiff:\n        \"\"\"Return differences between this and other fingerprint.\"\"\"\n        diff = FingerprintDiff()\n\n        if other is None:\n            for parent_key, parent_value in self.get_parts().items():\n                if isinstance(parent_value, Fingerprint):\n                    diff.add_diff(parent_key, FingerprintDiffType.NEW, parent_value._source)  # noqa: SLF001\n                    diff.update(parent_value.diff(None))\n            return diff\n\n        if self.get_hash() == other.get_hash():\n            return diff\n\n        self_parts: dict[str, Fingerprint] = {\n            key: value for key, value in self.get_parts().items() if isinstance(value, Fingerprint)\n        }\n        other_parts: dict[str, Fingerprint] = {\n            key: value for key, value in other.get_parts().items() if isinstance(value, Fingerprint)\n        }\n\n        # Check for new or modified keys\n        for key, value in self_parts.items():\n            if key not in other_parts:\n                diff.add_diff(key, FingerprintDiffType.NEW, value._source)  # noqa: SLF001\n                diff.update(value.diff(None))\n            elif value.get_hash() != other_parts[key].get_hash():\n                diff.add_diff(key, FingerprintDiffType.MODIFIED, value._source)  # noqa: SLF001\n                diff.update(value.diff(other_parts[key]))\n\n        # Check for deleted keys\n        for key in other_parts.keys() - self_parts.keys():\n            other_value = other_parts[key]\n            diff.add_diff(key, FingerprintDiffType.DELETED, other_value._source)  # noqa: SLF001\n            source = self  # TODO: Is this correct?\n            diff.update(Fingerprint(source).diff(other_value))\n\n        return diff\n\n    def __eq__(self, other: Fingerprint) -&gt; bool:\n        \"\"\"\n        Determine if two Fingerprint instances are equal based on their hash values.\n\n        Args:\n            other (Fingerprint): The other Fingerprint instance to compare.\n\n        Returns:\n            bool: True if the hash values are equal, False otherwise.\n\n        \"\"\"\n        return self.get_hash() == other.get_hash()\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.__eq__","title":"<code>__eq__(other: Fingerprint) -&gt; bool</code>","text":"<p>Determine if two Fingerprint instances are equal based on their hash values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Fingerprint</code> <p>The other Fingerprint instance to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the hash values are equal, False otherwise.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __eq__(self, other: Fingerprint) -&gt; bool:\n    \"\"\"\n    Determine if two Fingerprint instances are equal based on their hash values.\n\n    Args:\n        other (Fingerprint): The other Fingerprint instance to compare.\n\n    Returns:\n        bool: True if the hash values are equal, False otherwise.\n\n    \"\"\"\n    return self.get_hash() == other.get_hash()\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.__init__","title":"<code>__init__(source: object = None) -&gt; None</code>","text":"<p>Initialize a Fingerprint instance.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>object</code> <p>The source object to fingerprint. Defaults to None.</p> <code>None</code> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __init__(self, source: object = None) -&gt; None:\n    \"\"\"\n    Initialize a Fingerprint instance.\n\n    Args:\n        source (object, optional): The source object to fingerprint. Defaults to None.\n\n    \"\"\"\n    self._nested = {}\n    self._hash = None\n    self._source = source\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.add","title":"<code>add(key: str, value: object) -&gt; None</code>","text":"<p>Add a value to the fingerprint under the specified key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to associate with the value.</p> required <code>value</code> <code>object</code> <p>The value to add, which can be a Fingerprint, FingerprintRef, or other supported types.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def add(self, key: str, value: object) -&gt; None:\n    \"\"\"\n    Add a value to the fingerprint under the specified key.\n\n    Args:\n        key (str): The key to associate with the value.\n        value: The value to add, which can be a Fingerprint, FingerprintRef, or other supported types.\n\n    Returns:\n        None\n\n    \"\"\"\n    assert key not in self._nested\n\n    if isinstance(value, Fingerprint | FingerprintRef):\n        self._nested[key] = value\n    elif hasattr(value, \"get_fingerprint\"):\n        self.add(key, value.get_fingerprint())\n    elif isinstance(value, list | tuple | set):\n        self.add(key, self._fingerprint_from_list(value))\n    elif isinstance(value, dict):\n        self.add(key, self._fingerprint_from_dict(value))\n    else:\n        self._nested[key] = _custom_hash(value)\n\n    self._hash = None\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.add_ref","title":"<code>add_ref(prop: str, ref_key: str) -&gt; None</code>","text":"<p>Add a FingerprintRef to the fingerprint under the specified property key.</p> <p>Parameters:</p> Name Type Description Default <code>prop</code> <code>str</code> <p>The property key to associate with the reference.</p> required <code>ref_key</code> <code>str</code> <p>The key referencing another fingerprint.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def add_ref(self, prop: str, ref_key: str) -&gt; None:\n    \"\"\"\n    Add a FingerprintRef to the fingerprint under the specified property key.\n\n    Args:\n        prop (str): The property key to associate with the reference.\n        ref_key (str): The key referencing another fingerprint.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.add(prop, FingerprintRef(ref_key))\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.diff","title":"<code>diff(other: Fingerprint | None) -&gt; FingerprintDiff</code>","text":"<p>Return differences between this and other fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def diff(self, other: Fingerprint | None) -&gt; FingerprintDiff:\n    \"\"\"Return differences between this and other fingerprint.\"\"\"\n    diff = FingerprintDiff()\n\n    if other is None:\n        for parent_key, parent_value in self.get_parts().items():\n            if isinstance(parent_value, Fingerprint):\n                diff.add_diff(parent_key, FingerprintDiffType.NEW, parent_value._source)  # noqa: SLF001\n                diff.update(parent_value.diff(None))\n        return diff\n\n    if self.get_hash() == other.get_hash():\n        return diff\n\n    self_parts: dict[str, Fingerprint] = {\n        key: value for key, value in self.get_parts().items() if isinstance(value, Fingerprint)\n    }\n    other_parts: dict[str, Fingerprint] = {\n        key: value for key, value in other.get_parts().items() if isinstance(value, Fingerprint)\n    }\n\n    # Check for new or modified keys\n    for key, value in self_parts.items():\n        if key not in other_parts:\n            diff.add_diff(key, FingerprintDiffType.NEW, value._source)  # noqa: SLF001\n            diff.update(value.diff(None))\n        elif value.get_hash() != other_parts[key].get_hash():\n            diff.add_diff(key, FingerprintDiffType.MODIFIED, value._source)  # noqa: SLF001\n            diff.update(value.diff(other_parts[key]))\n\n    # Check for deleted keys\n    for key in other_parts.keys() - self_parts.keys():\n        other_value = other_parts[key]\n        diff.add_diff(key, FingerprintDiffType.DELETED, other_value._source)  # noqa: SLF001\n        source = self  # TODO: Is this correct?\n        diff.update(Fingerprint(source).diff(other_value))\n\n    return diff\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.get_hash","title":"<code>get_hash() -&gt; str</code>","text":"<p>Return the hash value of the fingerprint.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The computed hash value representing the fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_hash(self) -&gt; str:\n    \"\"\"\n    Return the hash value of the fingerprint.\n\n    Returns:\n        str: The computed hash value representing the fingerprint.\n\n    \"\"\"\n    self._resolve_total_hash()\n    return self._hash\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.get_parts","title":"<code>get_parts() -&gt; dict</code>","text":"<p>Return the dictionary of parts contained in the fingerprint.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping keys to their associated fingerprint parts.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_parts(self) -&gt; dict:\n    \"\"\"\n    Return the dictionary of parts contained in the fingerprint.\n\n    Returns:\n        dict: A dictionary mapping keys to their associated fingerprint parts.\n\n    \"\"\"\n    return {k: v for k, v in self._nested.items()}\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.Fingerprint.update_ref","title":"<code>update_ref(ref_key: str, fingerprint: Fingerprint) -&gt; None</code>","text":"<p>Update the reference at the given key with a new Fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>ref_key</code> <code>str</code> <p>The key referencing the FingerprintRef to update.</p> required <code>fingerprint</code> <code>Fingerprint</code> <p>The new Fingerprint to set at the reference.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def update_ref(self, ref_key: str, fingerprint: Fingerprint) -&gt; None:\n    \"\"\"\n    Update the reference at the given key with a new Fingerprint.\n\n    Args:\n        ref_key (str): The key referencing the FingerprintRef to update.\n        fingerprint (Fingerprint): The new Fingerprint to set at the reference.\n\n    Returns:\n        None\n\n    \"\"\"\n    assert ref_key in self._nested\n    assert isinstance(self._nested[ref_key], FingerprintRef)\n\n    self._nested[ref_key] = fingerprint\n    self._hash = None\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintDiff","title":"<code>FingerprintDiff</code>","text":"<p>Differences between two fingerprints.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class FingerprintDiff:\n    \"\"\"Differences between two fingerprints.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty FingerprintDiff.\"\"\"\n        self._diffs: dict[str, tuple] = {}\n\n    def add_diff(\n        self,\n        key: str,\n        diff_type: FingerprintDiffType,\n        obj: object,\n    ) -&gt; None:\n        \"\"\"\n        Add a difference entry for a fingerprint.\n\n        Args:\n            key (str): The key identifying the fingerprint part.\n            diff_type (FingerprintDiffType): The type of difference (NEW, MODIFIED, DELETED).\n            obj: The object associated with the difference.\n\n        \"\"\"\n        from framcore.components.Component import Component\n        from framcore.curves.Curve import Curve\n        from framcore.timevectors.TimeVector import TimeVector\n\n        # Trenger vi denne sjekken, siden vi filtrerer ut alt som ikke er Fingerprint f\u00f8r vi kj\u00f8rer add_diff()?\n        if isinstance(obj, TimeVector | Curve | Component):\n            if key in self._diffs:\n                message = f\"duplicate entry: {key} ({obj})\"\n                print(message)\n\n            self._diffs[key] = (obj, diff_type)\n\n    def get_diffs(self) -&gt; dict[str, tuple]:\n        \"\"\"\n        Return the dictionary of differences.\n\n        Returns:\n            dict[str, tuple]: The differences stored in the FingerprintDiff.\n\n        \"\"\"\n        return self._diffs\n\n    def is_changed(self) -&gt; bool:\n        \"\"\"Return True if there are any differences.\"\"\"\n        return bool(self._diffs)\n\n    def update(self, other: FingerprintDiff) -&gt; None:\n        \"\"\"\n        Update this FingerprintDiff with differences from another FingerprintDiff.\n\n        Args:\n            other (FingerprintDiff): Another FingerprintDiff whose differences will be added.\n\n        \"\"\"\n        self._diffs.update(other.get_diffs())\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintDiff.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize an empty FingerprintDiff.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty FingerprintDiff.\"\"\"\n    self._diffs: dict[str, tuple] = {}\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintDiff.add_diff","title":"<code>add_diff(key: str, diff_type: FingerprintDiffType, obj: object) -&gt; None</code>","text":"<p>Add a difference entry for a fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key identifying the fingerprint part.</p> required <code>diff_type</code> <code>FingerprintDiffType</code> <p>The type of difference (NEW, MODIFIED, DELETED).</p> required <code>obj</code> <code>object</code> <p>The object associated with the difference.</p> required Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def add_diff(\n    self,\n    key: str,\n    diff_type: FingerprintDiffType,\n    obj: object,\n) -&gt; None:\n    \"\"\"\n    Add a difference entry for a fingerprint.\n\n    Args:\n        key (str): The key identifying the fingerprint part.\n        diff_type (FingerprintDiffType): The type of difference (NEW, MODIFIED, DELETED).\n        obj: The object associated with the difference.\n\n    \"\"\"\n    from framcore.components.Component import Component\n    from framcore.curves.Curve import Curve\n    from framcore.timevectors.TimeVector import TimeVector\n\n    # Trenger vi denne sjekken, siden vi filtrerer ut alt som ikke er Fingerprint f\u00f8r vi kj\u00f8rer add_diff()?\n    if isinstance(obj, TimeVector | Curve | Component):\n        if key in self._diffs:\n            message = f\"duplicate entry: {key} ({obj})\"\n            print(message)\n\n        self._diffs[key] = (obj, diff_type)\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintDiff.get_diffs","title":"<code>get_diffs() -&gt; dict[str, tuple]</code>","text":"<p>Return the dictionary of differences.</p> <p>Returns:</p> Type Description <code>dict[str, tuple]</code> <p>dict[str, tuple]: The differences stored in the FingerprintDiff.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_diffs(self) -&gt; dict[str, tuple]:\n    \"\"\"\n    Return the dictionary of differences.\n\n    Returns:\n        dict[str, tuple]: The differences stored in the FingerprintDiff.\n\n    \"\"\"\n    return self._diffs\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintDiff.is_changed","title":"<code>is_changed() -&gt; bool</code>","text":"<p>Return True if there are any differences.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def is_changed(self) -&gt; bool:\n    \"\"\"Return True if there are any differences.\"\"\"\n    return bool(self._diffs)\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintDiff.update","title":"<code>update(other: FingerprintDiff) -&gt; None</code>","text":"<p>Update this FingerprintDiff with differences from another FingerprintDiff.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FingerprintDiff</code> <p>Another FingerprintDiff whose differences will be added.</p> required Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def update(self, other: FingerprintDiff) -&gt; None:\n    \"\"\"\n    Update this FingerprintDiff with differences from another FingerprintDiff.\n\n    Args:\n        other (FingerprintDiff): Another FingerprintDiff whose differences will be added.\n\n    \"\"\"\n    self._diffs.update(other.get_diffs())\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintDiffType","title":"<code>FingerprintDiffType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of difference between two fingerprints.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class FingerprintDiffType(Enum):\n    \"\"\"Type of difference between two fingerprints.\"\"\"\n\n    NEW = \"new\"\n    MODIFIED = \"modified\"\n    DELETED = \"deleted\"\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintRef","title":"<code>FingerprintRef</code>","text":"<p>Refers to another fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>class FingerprintRef:\n    \"\"\"Refers to another fingerprint.\"\"\"\n\n    def __init__(self, key: str) -&gt; None:\n        \"\"\"\n        Initialize a FingerprintRef with the given key.\n\n        Args:\n            key (str): The key referencing another fingerprint.\n\n        \"\"\"\n        self._key = key\n\n    def get_key(self) -&gt; str:\n        \"\"\"\n        Return the key referencing another fingerprint.\n\n        Returns:\n            str: The key referencing another fingerprint.\n\n        \"\"\"\n        return self._key\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintRef.__init__","title":"<code>__init__(key: str) -&gt; None</code>","text":"<p>Initialize a FingerprintRef with the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key referencing another fingerprint.</p> required Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def __init__(self, key: str) -&gt; None:\n    \"\"\"\n    Initialize a FingerprintRef with the given key.\n\n    Args:\n        key (str): The key referencing another fingerprint.\n\n    \"\"\"\n    self._key = key\n</code></pre>"},{"location":"reference/#framcore.fingerprints.fingerprint.FingerprintRef.get_key","title":"<code>get_key() -&gt; str</code>","text":"<p>Return the key referencing another fingerprint.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The key referencing another fingerprint.</p> Source code in <code>framcore/fingerprints/fingerprint.py</code> <pre><code>def get_key(self) -&gt; str:\n    \"\"\"\n    Return the key referencing another fingerprint.\n\n    Returns:\n        str: The key referencing another fingerprint.\n\n    \"\"\"\n    return self._key\n</code></pre>"},{"location":"reference/#framcore.juliamodels","title":"<code>juliamodels</code>","text":""},{"location":"reference/#framcore.juliamodels.JuliaModel","title":"<code>JuliaModel</code>","text":"<p>Manage Julia environment and usage of juliacall for Solvers implemented in the Julia language.</p>"},{"location":"reference/#framcore.juliamodels.JuliaModel.JuliaModel","title":"<code>JuliaModel</code>","text":"<p>               Bases: <code>Base</code></p> <p>Class for running julia code with juliacall.</p> Source code in <code>framcore/juliamodels/JuliaModel.py</code> <pre><code>class JuliaModel(Base):\n    \"\"\"Class for running julia code with juliacall.\"\"\"\n\n    ENV_NAME: str = \"julia_env\"  # Used to let each model define their own project/environment to avoid overwriting.\n    _jl = None\n\n    def __init__(\n        self,\n        env_path: Path | str | None = None,\n        depot_path: Path | str | None = None,\n        julia_path: Path | str | None = None,\n        dependencies: list[str | tuple[str, str | None]] | None = None,\n        skip_install_dependencies: bool = False,\n        force_julia_install: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize management of Julia model, environment and dependencies.\n\n        The three parameters env_path, depot_path and julia_path sets environment variables for locations of your Julia\n        environment, packages and language.\n\n        - If user has not specified locations, the default is to use the current python/conda environment.\n        - If a system installation of Python is used, the default is set to the current user location.\n\n        Args:\n            env_path (Path | str | None, optional): Path to location of Julia environment. If it doesnt exist it will be\n                                                    created. Defaults to None.\n            depot_path (Path | str | None, optional): Path to location where JuliaCall shoult install package\n                                                      dependencies. Defaults to None.\n            julia_path (Path | str | None, optional): Path to Julia language location. Will be installed here if it\n                                                      doesnt exist. Defaults to None.\n            dependencies (list[str] | None, optional): List of dependencies of the model. The strings in the list can be\n                                                       either urls or Julia package names.. Defaults to None.\n            skip_install_dependencies (bool, optional): Skip installation of dependencies. Defaults to False.\n            force_julia_install (bool): Force new Julia install.\n\n        \"\"\"\n        self._check_type(env_path, (Path, str, type(None)))\n        self._check_type(depot_path, (Path, str, type(None)))\n        self._check_type(julia_path, (Path, str, type(None)))\n        self._check_type(dependencies, (list, str, type(None)))\n        self._check_type(skip_install_dependencies, bool)\n\n        self._env_path = env_path\n        self._depot_path = depot_path\n        self._julia_path = julia_path\n        self._dependencies = dependencies if dependencies else []\n        self._skip_install_dependencies = skip_install_dependencies\n        self._force_julia_install = force_julia_install\n\n        self._jlpkg = None\n        self._initialize_julia()\n\n    def _initialize_julia(self) -&gt; None:\n        \"\"\"Initialize Julia language, package depot, and environment with JuliaCall.\"\"\"\n        if self._jl is not None:\n            return\n\n        # figure out what kind of environment we are in\n        prefix = sys.prefix if sys.prefix != sys.base_prefix else os.getenv(\"CONDA_PREFIX\")\n        # we have python system installation\n        project = Path(\"~/.julia\").expanduser() if prefix is None else prefix\n\n        self._env_path = str(Path(project) / \"julia_envs\" / self.ENV_NAME) if not self._env_path else str(self._env_path)\n        self._depot_path = str(Path(project) / \"julia_pkgs\") if not self._depot_path else str(self._depot_path)\n\n        os.environ[\"PYTHON_JULIAPKG_PROJECT\"] = self._env_path\n        os.environ[\"JULIA_DEPOT_PATH\"] = self._depot_path\n        if self._julia_path:  # If Julia path is not set, let JuliaCall handle defaults.\n            os.environ[\"PYTHON_JULIAPKG_EXE\"] = str(self._julia_path)\n\n        if self._force_julia_install:\n            path = os.environ.get(\"PATH\", \"\")\n            cleaned = os.pathsep.join(p for p in path.split(os.pathsep) if \"julia\" not in p.lower())\n            os.environ[\"PATH\"] = cleaned\n\n        juliacall = importlib.import_module(\"juliacall\")\n        JuliaModel._jl = juliacall.Main\n        self._jlpkg = juliacall.Pkg\n\n        self._jlpkg.activate(str(self._env_path))\n\n        if not self._skip_install_dependencies:\n            self._install_dependencies()\n\n        # Print sysimage Julia\n        try:\n            path_sysimage = self._jl.seval(\"unsafe_string(Base.JLOptions().image_file)\")\n            message = f\"path_sysimage: {path_sysimage}\"\n            self.send_debug_event(message)\n        except Exception:\n            pass\n\n    def _install_dependencies(self) -&gt; None:\n        \"\"\"Install dependencies.\"\"\"\n        # if (Path(self._env_path) / Path(\"Manifest.toml\")).exists():\n        #    print(\"Manifest found, assuming environment is already initialized.\")\n        #    return\n\n        url_tuples = [p for p in self._dependencies if isinstance(p, tuple) and _is_url(p[0])]\n        urls = [p for p in self._dependencies if isinstance(p, str) and _is_url(p)]\n        dev_paths = [p for p in self._dependencies if isinstance(p, str) and Path(p).exists()]\n        pkg_names = [p for p in self._dependencies if isinstance(p, str) and not _is_url(p) and not Path(p).exists()]\n\n        unknowns = [p for p in self._dependencies if not (p in url_tuples or p in urls or p in pkg_names or p in dev_paths)]\n\n        if unknowns:\n            messages = []\n            for p in unknowns:\n                messages.append(\n                    (\n                        f\"Unsupported julia package definition: '{p}' of type '{type(p)}' is not supported. \"\n                        \"Must be defined as either str or tuple[str, str | None]\"\n                    ),\n                )\n            message = \"\\n\".join(messages)\n            raise ValueError(message)\n\n        self._jl.seval(\"using Pkg\")\n\n        pkg_spec_vector = self._jl.seval(\"x = Pkg.PackageSpec[]\")\n\n        for url, rev in url_tuples:\n            self._jl.seval(f'push!(x, Pkg.PackageSpec(url=\"{url}\", rev=\"{rev}\"))')\n\n        for url in urls:\n            self._jl.seval(f'push!(x, Pkg.PackageSpec(url=\"{url}))\"')\n\n        for pkg_name in pkg_names:\n            self._jl.seval(f'push!(x, Pkg.PackageSpec(name=\"{pkg_name}\"))')\n\n        self._jlpkg.add(pkg_spec_vector)\n\n        for dev_path in dev_paths:\n            self._jl.seval(f'Pkg.develop(path=\"{dev_path}\")')\n\n    def _run(self, julia_code: str) -&gt; None:\n        \"\"\"Run a string of julia code wich is supposed to start running the Julia Model in the given environment.\"\"\"\n        self._jl.seval(julia_code)\n</code></pre>"},{"location":"reference/#framcore.juliamodels.JuliaModel.JuliaModel.__init__","title":"<code>__init__(env_path: Path | str | None = None, depot_path: Path | str | None = None, julia_path: Path | str | None = None, dependencies: list[str | tuple[str, str | None]] | None = None, skip_install_dependencies: bool = False, force_julia_install: bool = True) -&gt; None</code>","text":"<p>Initialize management of Julia model, environment and dependencies.</p> <p>The three parameters env_path, depot_path and julia_path sets environment variables for locations of your Julia environment, packages and language.</p> <ul> <li>If user has not specified locations, the default is to use the current python/conda environment.</li> <li>If a system installation of Python is used, the default is set to the current user location.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>env_path</code> <code>Path | str | None</code> <p>Path to location of Julia environment. If it doesnt exist it will be                                     created. Defaults to None.</p> <code>None</code> <code>depot_path</code> <code>Path | str | None</code> <p>Path to location where JuliaCall shoult install package                                       dependencies. Defaults to None.</p> <code>None</code> <code>julia_path</code> <code>Path | str | None</code> <p>Path to Julia language location. Will be installed here if it                                       doesnt exist. Defaults to None.</p> <code>None</code> <code>dependencies</code> <code>list[str] | None</code> <p>List of dependencies of the model. The strings in the list can be                                        either urls or Julia package names.. Defaults to None.</p> <code>None</code> <code>skip_install_dependencies</code> <code>bool</code> <p>Skip installation of dependencies. Defaults to False.</p> <code>False</code> <code>force_julia_install</code> <code>bool</code> <p>Force new Julia install.</p> <code>True</code> Source code in <code>framcore/juliamodels/JuliaModel.py</code> <pre><code>def __init__(\n    self,\n    env_path: Path | str | None = None,\n    depot_path: Path | str | None = None,\n    julia_path: Path | str | None = None,\n    dependencies: list[str | tuple[str, str | None]] | None = None,\n    skip_install_dependencies: bool = False,\n    force_julia_install: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize management of Julia model, environment and dependencies.\n\n    The three parameters env_path, depot_path and julia_path sets environment variables for locations of your Julia\n    environment, packages and language.\n\n    - If user has not specified locations, the default is to use the current python/conda environment.\n    - If a system installation of Python is used, the default is set to the current user location.\n\n    Args:\n        env_path (Path | str | None, optional): Path to location of Julia environment. If it doesnt exist it will be\n                                                created. Defaults to None.\n        depot_path (Path | str | None, optional): Path to location where JuliaCall shoult install package\n                                                  dependencies. Defaults to None.\n        julia_path (Path | str | None, optional): Path to Julia language location. Will be installed here if it\n                                                  doesnt exist. Defaults to None.\n        dependencies (list[str] | None, optional): List of dependencies of the model. The strings in the list can be\n                                                   either urls or Julia package names.. Defaults to None.\n        skip_install_dependencies (bool, optional): Skip installation of dependencies. Defaults to False.\n        force_julia_install (bool): Force new Julia install.\n\n    \"\"\"\n    self._check_type(env_path, (Path, str, type(None)))\n    self._check_type(depot_path, (Path, str, type(None)))\n    self._check_type(julia_path, (Path, str, type(None)))\n    self._check_type(dependencies, (list, str, type(None)))\n    self._check_type(skip_install_dependencies, bool)\n\n    self._env_path = env_path\n    self._depot_path = depot_path\n    self._julia_path = julia_path\n    self._dependencies = dependencies if dependencies else []\n    self._skip_install_dependencies = skip_install_dependencies\n    self._force_julia_install = force_julia_install\n\n    self._jlpkg = None\n    self._initialize_julia()\n</code></pre>"},{"location":"reference/#framcore.loaders","title":"<code>loaders</code>","text":""},{"location":"reference/#framcore.loaders.CurveLoader","title":"<code>CurveLoader</code>","text":"<p>               Bases: <code>Loader</code>, <code>ABC</code></p> <p>Loader API for retrieving curve data from some source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class CurveLoader(Loader, ABC):\n    \"\"\"Loader API for retrieving curve data from some source.\"\"\"\n\n    @abstractmethod\n    def get_y_axis(self, curve_id: str) -&gt; NDArray:\n        \"\"\"\n        Return the values of a Curves y axis in the Loader source.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            NDArray: Numpy array of all values in the y axis.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_x_axis(self, curve_id: str) -&gt; NDArray:\n        \"\"\"\n        Return the values of a Curves x axis in the Loader source.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            NDArray: Numpy array of all values in the x axis.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_x_unit(self, curve_id: str) -&gt; str:\n        \"\"\"\n        Return the unit of the x axis of a specific curve.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            str: Unit of the curve's x axis.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_y_unit(self, curve_id: str) -&gt; str:\n        \"\"\"\n        Return the unit of the y axis of a specific curve.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            str: Unit of the curve's y axis.\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#framcore.loaders.CurveLoader.get_x_axis","title":"<code>get_x_axis(curve_id: str) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Return the values of a Curves x axis in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of all values in the x axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_x_axis(self, curve_id: str) -&gt; NDArray:\n    \"\"\"\n    Return the values of a Curves x axis in the Loader source.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        NDArray: Numpy array of all values in the x axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.CurveLoader.get_x_unit","title":"<code>get_x_unit(curve_id: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return the unit of the x axis of a specific curve.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unit of the curve's x axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_x_unit(self, curve_id: str) -&gt; str:\n    \"\"\"\n    Return the unit of the x axis of a specific curve.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        str: Unit of the curve's x axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.CurveLoader.get_y_axis","title":"<code>get_y_axis(curve_id: str) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Return the values of a Curves y axis in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of all values in the y axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_y_axis(self, curve_id: str) -&gt; NDArray:\n    \"\"\"\n    Return the values of a Curves y axis in the Loader source.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        NDArray: Numpy array of all values in the y axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.CurveLoader.get_y_unit","title":"<code>get_y_unit(curve_id: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return the unit of the y axis of a specific curve.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unit of the curve's y axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_y_unit(self, curve_id: str) -&gt; str:\n    \"\"\"\n    Return the unit of the y axis of a specific curve.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        str: Unit of the curve's y axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.FileLoader","title":"<code>FileLoader</code>","text":"<p>               Bases: <code>Loader</code>, <code>ABC</code></p> <p>Define common functionality and API for Loaders connected to a file as source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class FileLoader(Loader, ABC):\n    \"\"\"Define common functionality and API for Loaders connected to a file as source.\"\"\"\n\n    _SUPPORTED_SUFFIXES: ClassVar[list[str]] = []\n\n    def __init__(self, source: Path | str, relative_loc: Path | str | None = None) -&gt; None:\n        \"\"\"\n        Check validity of input parameters.\n\n        Args:\n            source (Path | str): Full file path or the absolute part of a file path\n            relative_loc (Optional[Union[Path, str]], optional): The relative part of a file path. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n        self._source = source\n        self._relative_loc = relative_loc\n\n        self._check_type(source, (Path, str))\n        if self._relative_loc is not None:\n            self._check_type(self._relative_loc, (Path, str))\n        self._check_path_exists(self.get_source())\n        self._check_path_supported(self.get_source())\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overwrite __repr__ to get better info.\"\"\"\n        return f\"{type(self).__name__}(source={self._source}, relative_loc={self._relative_loc})\"\n\n    def get_source(self) -&gt; Path:\n        \"\"\"Combine absolute and relative file path (if relative is defined) to get full source.\"\"\"\n        if self._relative_loc is None:\n            return Path(self._source)\n        return Path(self._source) / self._relative_loc\n\n    def set_source(self, new_source: Path, relative_loc: Path | str | None = None) -&gt; None:\n        \"\"\"\n        Set absolute and relative parts of filepath.\n\n        Args:\n            new_source (Path): New absolute part.\n            relative_loc (Optional[Union[Path, str]], optional): New relative part. Defaults to None.\n\n        \"\"\"\n        self._source = new_source\n        self._relative_loc = relative_loc\n\n    @classmethod\n    def get_supported_suffixes(cls) -&gt; list[str]:\n        \"\"\"\n        Return list of supported file types.\n\n        Returns:\n            list: List of filetypes.\n\n        \"\"\"\n        return cls._SUPPORTED_SUFFIXES\n\n    def _check_path_exists(self, path: Path) -&gt; None:\n        \"\"\"\n        Check if a file path exists.\n\n        Args:\n            path (Path): Path to check.\n\n        Raises:\n            FileNotFoundError\n\n        \"\"\"\n        if not path.exists():\n            msg = f\"\"\"File {path} does not exist. Could not create {type(self)}.\"\"\"\n            raise FileNotFoundError(msg)\n\n    def _check_path_supported(self, path: Path) -&gt; None:\n        \"\"\"\n        Check if a file is supported/readable by this FileLoader instance.\n\n        Args:\n            path (Path): Path to check.\n\n        Raises:\n            ValueError: If the file type is not defined as supported.\n\n        \"\"\"\n        filetype = path.suffix\n        if filetype not in self._SUPPORTED_SUFFIXES:\n            msg = f\"File type of {path}, {filetype} is not supported by {type(self)}. Supported filetypes: {self._SUPPORTED_SUFFIXES}\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"reference/#framcore.loaders.FileLoader.__init__","title":"<code>__init__(source: Path | str, relative_loc: Path | str | None = None) -&gt; None</code>","text":"<p>Check validity of input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>Full file path or the absolute part of a file path</p> required <code>relative_loc</code> <code>Optional[Union[Path, str]]</code> <p>The relative part of a file path. Defaults to None.</p> <code>None</code> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __init__(self, source: Path | str, relative_loc: Path | str | None = None) -&gt; None:\n    \"\"\"\n    Check validity of input parameters.\n\n    Args:\n        source (Path | str): Full file path or the absolute part of a file path\n        relative_loc (Optional[Union[Path, str]], optional): The relative part of a file path. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self._source = source\n    self._relative_loc = relative_loc\n\n    self._check_type(source, (Path, str))\n    if self._relative_loc is not None:\n        self._check_type(self._relative_loc, (Path, str))\n    self._check_path_exists(self.get_source())\n    self._check_path_supported(self.get_source())\n</code></pre>"},{"location":"reference/#framcore.loaders.FileLoader.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Overwrite repr to get better info.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overwrite __repr__ to get better info.\"\"\"\n    return f\"{type(self).__name__}(source={self._source}, relative_loc={self._relative_loc})\"\n</code></pre>"},{"location":"reference/#framcore.loaders.FileLoader.get_source","title":"<code>get_source() -&gt; Path</code>","text":"<p>Combine absolute and relative file path (if relative is defined) to get full source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def get_source(self) -&gt; Path:\n    \"\"\"Combine absolute and relative file path (if relative is defined) to get full source.\"\"\"\n    if self._relative_loc is None:\n        return Path(self._source)\n    return Path(self._source) / self._relative_loc\n</code></pre>"},{"location":"reference/#framcore.loaders.FileLoader.get_supported_suffixes","title":"<code>get_supported_suffixes() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Return list of supported file types.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[str]</code> <p>List of filetypes.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@classmethod\ndef get_supported_suffixes(cls) -&gt; list[str]:\n    \"\"\"\n    Return list of supported file types.\n\n    Returns:\n        list: List of filetypes.\n\n    \"\"\"\n    return cls._SUPPORTED_SUFFIXES\n</code></pre>"},{"location":"reference/#framcore.loaders.FileLoader.set_source","title":"<code>set_source(new_source: Path, relative_loc: Path | str | None = None) -&gt; None</code>","text":"<p>Set absolute and relative parts of filepath.</p> <p>Parameters:</p> Name Type Description Default <code>new_source</code> <code>Path</code> <p>New absolute part.</p> required <code>relative_loc</code> <code>Optional[Union[Path, str]]</code> <p>New relative part. Defaults to None.</p> <code>None</code> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def set_source(self, new_source: Path, relative_loc: Path | str | None = None) -&gt; None:\n    \"\"\"\n    Set absolute and relative parts of filepath.\n\n    Args:\n        new_source (Path): New absolute part.\n        relative_loc (Optional[Union[Path, str]], optional): New relative part. Defaults to None.\n\n    \"\"\"\n    self._source = new_source\n    self._relative_loc = relative_loc\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Base Loader class defining common API and functionality for all Loaders.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class Loader(Base, ABC):\n    \"\"\"Base Loader class defining common API and functionality for all Loaders.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Set up cache of ids contained in the source of the Loader.\"\"\"\n        self._content_ids: list[str] = None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Overwrite string representation.\n\n        Returns:\n            str: Object represented as string.\n\n        \"\"\"\n        return f\"{type(self).__name__}({vars(self)})\"\n\n    def __getstate__(self) -&gt; dict:\n        \"\"\"\n        Return current object state, clearing any cached data.\n\n        Returns:\n            dict: The object's state dictionary.\n\n        \"\"\"\n        self.clear_cache()\n        return self.__dict__\n\n    @abstractmethod\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear cached data from the loader.\"\"\"\n        pass\n\n    def __deepcopy__(self, memo: dict) -&gt; Loader:\n        \"\"\"\n        Overwrite deepcopy.\n\n        This is done to enable sharing of loaders. Since a loader is connected to one source, caching can thus be shared\n        between Models.\n\n        Args:\n            memo (dict): Required argument.\n\n        Returns:\n            Loader: Returns itself.\n\n        \"\"\"\n        return self\n\n    @abstractmethod\n    def get_source(self) -&gt; object:\n        \"\"\"\n        Return Loader source.\n\n        Returns:\n            object: Whatever the Loader interacts with to retrieve data.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_source(self, new_source: object) -&gt; None:\n        \"\"\"\n        Set the Loader source.\n\n        Args:\n            new_source (object): Whatever the Loader should interact with to retrieve data.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_metadata(self, content_id: str) -&gt; object:\n        \"\"\"\n        Get metadata from the Loader source.\n\n        The metadata could describe behavior of the data in source.\n\n        Args:\n            content_id (str): Id of some content.\n\n        Returns:\n            object: Metadata in some format only the specific Loader knows.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _get_ids(self) -&gt; list[str]:\n        \"\"\"\n        Return list of names which can be used to access specific data structures whithin source.\n\n        Most likely the names of all time vectors or curves in The Loader's source.\n\n        Returns:\n            list[str]\n\n        \"\"\"\n        pass\n\n    def get_ids(self) -&gt; list[str]:\n        \"\"\"\n        Handle caching of ids existing in the loaders source.\n\n        Returns:\n            list[str]: List containing ids in Loader source.\n\n        \"\"\"\n        if self._content_ids is None:\n            self._content_ids = self._get_ids()\n            seen = set()\n            duplicates = []\n            for content_id in self._content_ids:\n                if content_id in seen:\n                    duplicates.append(content_id)\n                else:\n                    seen.add(content_id)\n            if duplicates:\n                msg = f\"Duplicate ID's found in {self.get_source()}: {duplicates}\"\n                raise ValueError(msg)\n\n        return self._content_ids\n\n    def _id_exsists(self, content_id: str) -&gt; None:\n        \"\"\"\n        Check if a given id exists in source.\n\n        Args:\n            content_id (str): Id of some content.\n\n        Raises:\n            KeyError: If content id does not exist.\n\n        \"\"\"\n        existing_ids = self.get_ids()\n        if content_id not in existing_ids:\n            # __repr__ should be overwritten in subclasses to produce enough info in error message.\n            msg = f\"Could not find ID {content_id} in {self}. Existing IDs: {existing_ids}\"\n            raise KeyError(msg)\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.__deepcopy__","title":"<code>__deepcopy__(memo: dict) -&gt; Loader</code>","text":"<p>Overwrite deepcopy.</p> <p>This is done to enable sharing of loaders. Since a loader is connected to one source, caching can thus be shared between Models.</p> <p>Parameters:</p> Name Type Description Default <code>memo</code> <code>dict</code> <p>Required argument.</p> required <p>Returns:</p> Name Type Description <code>Loader</code> <code>Loader</code> <p>Returns itself.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __deepcopy__(self, memo: dict) -&gt; Loader:\n    \"\"\"\n    Overwrite deepcopy.\n\n    This is done to enable sharing of loaders. Since a loader is connected to one source, caching can thus be shared\n    between Models.\n\n    Args:\n        memo (dict): Required argument.\n\n    Returns:\n        Loader: Returns itself.\n\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.__getstate__","title":"<code>__getstate__() -&gt; dict</code>","text":"<p>Return current object state, clearing any cached data.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The object's state dictionary.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __getstate__(self) -&gt; dict:\n    \"\"\"\n    Return current object state, clearing any cached data.\n\n    Returns:\n        dict: The object's state dictionary.\n\n    \"\"\"\n    self.clear_cache()\n    return self.__dict__\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Set up cache of ids contained in the source of the Loader.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Set up cache of ids contained in the source of the Loader.\"\"\"\n    self._content_ids: list[str] = None\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Overwrite string representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Object represented as string.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Overwrite string representation.\n\n    Returns:\n        str: Object represented as string.\n\n    \"\"\"\n    return f\"{type(self).__name__}({vars(self)})\"\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.clear_cache","title":"<code>clear_cache() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Clear cached data from the loader.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef clear_cache(self) -&gt; None:\n    \"\"\"Clear cached data from the loader.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.get_ids","title":"<code>get_ids() -&gt; list[str]</code>","text":"<p>Handle caching of ids existing in the loaders source.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List containing ids in Loader source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def get_ids(self) -&gt; list[str]:\n    \"\"\"\n    Handle caching of ids existing in the loaders source.\n\n    Returns:\n        list[str]: List containing ids in Loader source.\n\n    \"\"\"\n    if self._content_ids is None:\n        self._content_ids = self._get_ids()\n        seen = set()\n        duplicates = []\n        for content_id in self._content_ids:\n            if content_id in seen:\n                duplicates.append(content_id)\n            else:\n                seen.add(content_id)\n        if duplicates:\n            msg = f\"Duplicate ID's found in {self.get_source()}: {duplicates}\"\n            raise ValueError(msg)\n\n    return self._content_ids\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.get_metadata","title":"<code>get_metadata(content_id: str) -&gt; object</code>  <code>abstractmethod</code>","text":"<p>Get metadata from the Loader source.</p> <p>The metadata could describe behavior of the data in source.</p> <p>Parameters:</p> Name Type Description Default <code>content_id</code> <code>str</code> <p>Id of some content.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Metadata in some format only the specific Loader knows.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_metadata(self, content_id: str) -&gt; object:\n    \"\"\"\n    Get metadata from the Loader source.\n\n    The metadata could describe behavior of the data in source.\n\n    Args:\n        content_id (str): Id of some content.\n\n    Returns:\n        object: Metadata in some format only the specific Loader knows.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.get_source","title":"<code>get_source() -&gt; object</code>  <code>abstractmethod</code>","text":"<p>Return Loader source.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Whatever the Loader interacts with to retrieve data.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_source(self) -&gt; object:\n    \"\"\"\n    Return Loader source.\n\n    Returns:\n        object: Whatever the Loader interacts with to retrieve data.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.Loader.set_source","title":"<code>set_source(new_source: object) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>new_source</code> <code>object</code> <p>Whatever the Loader should interact with to retrieve data.</p> required Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef set_source(self, new_source: object) -&gt; None:\n    \"\"\"\n    Set the Loader source.\n\n    Args:\n        new_source (object): Whatever the Loader should interact with to retrieve data.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader","title":"<code>TimeVectorLoader</code>","text":"<p>               Bases: <code>Loader</code>, <code>ABC</code></p> <p>Loader API for retrieving time vector data from some source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class TimeVectorLoader(Loader, ABC):\n    \"\"\"Loader API for retrieving time vector data from some source.\"\"\"\n\n    @abstractmethod\n    def get_values(self, vector_id: str) -&gt; NDArray:\n        \"\"\"\n        Return the values of a time vector in the Loader source.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            NDArray: Numpy array of all values.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_index(self, vector_id: str) -&gt; TimeIndex:\n        \"\"\"\n        Return the index a time vector in the Loader source.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            NDArray: TimeIndex object.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_unit(self, vector_id: str) -&gt; str:\n        \"\"\"\n        Return unit of the values within a time vector in the loader source.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            str: String with unit.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_max_level(self, vector_id: str) -&gt; bool | None:\n        \"\"\"\n        Check if the given TimeVector is a level representing max Volume/Capacity/Price.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            True - vector is a level representing max Volume/Capacity.\n            False - vector is a level representing average Volume/Capacity over a given reference period.\n            None - vector is not a level.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_zero_one_profile(self, vector_id: str) -&gt; bool | None:\n        \"\"\"\n        Check if the given TimeVector is a profile with values between zero and one.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            True - vector is a profile with values between zero and one.\n            False - vector is a profile where the mean value is 1 given a reference period.\n            None - vector is not a profile.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_reference_period(self, vector_id: str) -&gt; ReferencePeriod | None:\n        \"\"\"\n        Get the reference period of a given vector.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            ReferencePeriod - if the vector is a mean one profile or average level, a reference period must exist.\n            None - No reference period if vector is max level, zero one profile or not a level or profile.\n\n        \"\"\"\n        pass\n\n    def get_fingerprint(self, vector_id: str) -&gt; Fingerprint:\n        \"\"\"Return Loader Fingerprint for given vector id.\"\"\"\n        f = Fingerprint(self)\n        f.add(\"unit\", self.get_unit(vector_id))\n        f.add(\"index\", self.get_index(vector_id))\n        f.add(\"values\", self.get_values(vector_id))\n        return f\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader.get_fingerprint","title":"<code>get_fingerprint(vector_id: str) -&gt; Fingerprint</code>","text":"<p>Return Loader Fingerprint for given vector id.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def get_fingerprint(self, vector_id: str) -&gt; Fingerprint:\n    \"\"\"Return Loader Fingerprint for given vector id.\"\"\"\n    f = Fingerprint(self)\n    f.add(\"unit\", self.get_unit(vector_id))\n    f.add(\"index\", self.get_index(vector_id))\n    f.add(\"values\", self.get_values(vector_id))\n    return f\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader.get_index","title":"<code>get_index(vector_id: str) -&gt; TimeIndex</code>  <code>abstractmethod</code>","text":"<p>Return the index a time vector in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>TimeIndex</code> <p>TimeIndex object.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_index(self, vector_id: str) -&gt; TimeIndex:\n    \"\"\"\n    Return the index a time vector in the Loader source.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        NDArray: TimeIndex object.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader.get_reference_period","title":"<code>get_reference_period(vector_id: str) -&gt; ReferencePeriod | None</code>  <code>abstractmethod</code>","text":"<p>Get the reference period of a given vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Type Description <code>ReferencePeriod | None</code> <p>ReferencePeriod - if the vector is a mean one profile or average level, a reference period must exist.</p> <code>ReferencePeriod | None</code> <p>None - No reference period if vector is max level, zero one profile or not a level or profile.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_reference_period(self, vector_id: str) -&gt; ReferencePeriod | None:\n    \"\"\"\n    Get the reference period of a given vector.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        ReferencePeriod - if the vector is a mean one profile or average level, a reference period must exist.\n        None - No reference period if vector is max level, zero one profile or not a level or profile.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader.get_unit","title":"<code>get_unit(vector_id: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return unit of the values within a time vector in the loader source.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with unit.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_unit(self, vector_id: str) -&gt; str:\n    \"\"\"\n    Return unit of the values within a time vector in the loader source.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        str: String with unit.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader.get_values","title":"<code>get_values(vector_id: str) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Return the values of a time vector in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of all values.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_values(self, vector_id: str) -&gt; NDArray:\n    \"\"\"\n    Return the values of a time vector in the Loader source.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        NDArray: Numpy array of all values.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader.is_max_level","title":"<code>is_max_level(vector_id: str) -&gt; bool | None</code>  <code>abstractmethod</code>","text":"<p>Check if the given TimeVector is a level representing max Volume/Capacity/Price.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Type Description <code>bool | None</code> <p>True - vector is a level representing max Volume/Capacity.</p> <code>bool | None</code> <p>False - vector is a level representing average Volume/Capacity over a given reference period.</p> <code>bool | None</code> <p>None - vector is not a level.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef is_max_level(self, vector_id: str) -&gt; bool | None:\n    \"\"\"\n    Check if the given TimeVector is a level representing max Volume/Capacity/Price.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        True - vector is a level representing max Volume/Capacity.\n        False - vector is a level representing average Volume/Capacity over a given reference period.\n        None - vector is not a level.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.TimeVectorLoader.is_zero_one_profile","title":"<code>is_zero_one_profile(vector_id: str) -&gt; bool | None</code>  <code>abstractmethod</code>","text":"<p>Check if the given TimeVector is a profile with values between zero and one.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Type Description <code>bool | None</code> <p>True - vector is a profile with values between zero and one.</p> <code>bool | None</code> <p>False - vector is a profile where the mean value is 1 given a reference period.</p> <code>bool | None</code> <p>None - vector is not a profile.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef is_zero_one_profile(self, vector_id: str) -&gt; bool | None:\n    \"\"\"\n    Check if the given TimeVector is a profile with values between zero and one.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        True - vector is a profile with values between zero and one.\n        False - vector is a profile where the mean value is 1 given a reference period.\n        None - vector is not a profile.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders","title":"<code>loaders</code>","text":"<p>Classes defining APIs for Loaders.</p>"},{"location":"reference/#framcore.loaders.loaders.CurveLoader","title":"<code>CurveLoader</code>","text":"<p>               Bases: <code>Loader</code>, <code>ABC</code></p> <p>Loader API for retrieving curve data from some source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class CurveLoader(Loader, ABC):\n    \"\"\"Loader API for retrieving curve data from some source.\"\"\"\n\n    @abstractmethod\n    def get_y_axis(self, curve_id: str) -&gt; NDArray:\n        \"\"\"\n        Return the values of a Curves y axis in the Loader source.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            NDArray: Numpy array of all values in the y axis.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_x_axis(self, curve_id: str) -&gt; NDArray:\n        \"\"\"\n        Return the values of a Curves x axis in the Loader source.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            NDArray: Numpy array of all values in the x axis.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_x_unit(self, curve_id: str) -&gt; str:\n        \"\"\"\n        Return the unit of the x axis of a specific curve.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            str: Unit of the curve's x axis.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_y_unit(self, curve_id: str) -&gt; str:\n        \"\"\"\n        Return the unit of the y axis of a specific curve.\n\n        Args:\n            curve_id (str): ID of the curve.\n\n        Returns:\n            str: Unit of the curve's y axis.\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.CurveLoader.get_x_axis","title":"<code>get_x_axis(curve_id: str) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Return the values of a Curves x axis in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of all values in the x axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_x_axis(self, curve_id: str) -&gt; NDArray:\n    \"\"\"\n    Return the values of a Curves x axis in the Loader source.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        NDArray: Numpy array of all values in the x axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.CurveLoader.get_x_unit","title":"<code>get_x_unit(curve_id: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return the unit of the x axis of a specific curve.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unit of the curve's x axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_x_unit(self, curve_id: str) -&gt; str:\n    \"\"\"\n    Return the unit of the x axis of a specific curve.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        str: Unit of the curve's x axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.CurveLoader.get_y_axis","title":"<code>get_y_axis(curve_id: str) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Return the values of a Curves y axis in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of all values in the y axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_y_axis(self, curve_id: str) -&gt; NDArray:\n    \"\"\"\n    Return the values of a Curves y axis in the Loader source.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        NDArray: Numpy array of all values in the y axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.CurveLoader.get_y_unit","title":"<code>get_y_unit(curve_id: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return the unit of the y axis of a specific curve.</p> <p>Parameters:</p> Name Type Description Default <code>curve_id</code> <code>str</code> <p>ID of the curve.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unit of the curve's y axis.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_y_unit(self, curve_id: str) -&gt; str:\n    \"\"\"\n    Return the unit of the y axis of a specific curve.\n\n    Args:\n        curve_id (str): ID of the curve.\n\n    Returns:\n        str: Unit of the curve's y axis.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.FileLoader","title":"<code>FileLoader</code>","text":"<p>               Bases: <code>Loader</code>, <code>ABC</code></p> <p>Define common functionality and API for Loaders connected to a file as source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class FileLoader(Loader, ABC):\n    \"\"\"Define common functionality and API for Loaders connected to a file as source.\"\"\"\n\n    _SUPPORTED_SUFFIXES: ClassVar[list[str]] = []\n\n    def __init__(self, source: Path | str, relative_loc: Path | str | None = None) -&gt; None:\n        \"\"\"\n        Check validity of input parameters.\n\n        Args:\n            source (Path | str): Full file path or the absolute part of a file path\n            relative_loc (Optional[Union[Path, str]], optional): The relative part of a file path. Defaults to None.\n\n        \"\"\"\n        super().__init__()\n        self._source = source\n        self._relative_loc = relative_loc\n\n        self._check_type(source, (Path, str))\n        if self._relative_loc is not None:\n            self._check_type(self._relative_loc, (Path, str))\n        self._check_path_exists(self.get_source())\n        self._check_path_supported(self.get_source())\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overwrite __repr__ to get better info.\"\"\"\n        return f\"{type(self).__name__}(source={self._source}, relative_loc={self._relative_loc})\"\n\n    def get_source(self) -&gt; Path:\n        \"\"\"Combine absolute and relative file path (if relative is defined) to get full source.\"\"\"\n        if self._relative_loc is None:\n            return Path(self._source)\n        return Path(self._source) / self._relative_loc\n\n    def set_source(self, new_source: Path, relative_loc: Path | str | None = None) -&gt; None:\n        \"\"\"\n        Set absolute and relative parts of filepath.\n\n        Args:\n            new_source (Path): New absolute part.\n            relative_loc (Optional[Union[Path, str]], optional): New relative part. Defaults to None.\n\n        \"\"\"\n        self._source = new_source\n        self._relative_loc = relative_loc\n\n    @classmethod\n    def get_supported_suffixes(cls) -&gt; list[str]:\n        \"\"\"\n        Return list of supported file types.\n\n        Returns:\n            list: List of filetypes.\n\n        \"\"\"\n        return cls._SUPPORTED_SUFFIXES\n\n    def _check_path_exists(self, path: Path) -&gt; None:\n        \"\"\"\n        Check if a file path exists.\n\n        Args:\n            path (Path): Path to check.\n\n        Raises:\n            FileNotFoundError\n\n        \"\"\"\n        if not path.exists():\n            msg = f\"\"\"File {path} does not exist. Could not create {type(self)}.\"\"\"\n            raise FileNotFoundError(msg)\n\n    def _check_path_supported(self, path: Path) -&gt; None:\n        \"\"\"\n        Check if a file is supported/readable by this FileLoader instance.\n\n        Args:\n            path (Path): Path to check.\n\n        Raises:\n            ValueError: If the file type is not defined as supported.\n\n        \"\"\"\n        filetype = path.suffix\n        if filetype not in self._SUPPORTED_SUFFIXES:\n            msg = f\"File type of {path}, {filetype} is not supported by {type(self)}. Supported filetypes: {self._SUPPORTED_SUFFIXES}\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.FileLoader.__init__","title":"<code>__init__(source: Path | str, relative_loc: Path | str | None = None) -&gt; None</code>","text":"<p>Check validity of input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | str</code> <p>Full file path or the absolute part of a file path</p> required <code>relative_loc</code> <code>Optional[Union[Path, str]]</code> <p>The relative part of a file path. Defaults to None.</p> <code>None</code> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __init__(self, source: Path | str, relative_loc: Path | str | None = None) -&gt; None:\n    \"\"\"\n    Check validity of input parameters.\n\n    Args:\n        source (Path | str): Full file path or the absolute part of a file path\n        relative_loc (Optional[Union[Path, str]], optional): The relative part of a file path. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self._source = source\n    self._relative_loc = relative_loc\n\n    self._check_type(source, (Path, str))\n    if self._relative_loc is not None:\n        self._check_type(self._relative_loc, (Path, str))\n    self._check_path_exists(self.get_source())\n    self._check_path_supported(self.get_source())\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.FileLoader.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Overwrite repr to get better info.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overwrite __repr__ to get better info.\"\"\"\n    return f\"{type(self).__name__}(source={self._source}, relative_loc={self._relative_loc})\"\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.FileLoader.get_source","title":"<code>get_source() -&gt; Path</code>","text":"<p>Combine absolute and relative file path (if relative is defined) to get full source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def get_source(self) -&gt; Path:\n    \"\"\"Combine absolute and relative file path (if relative is defined) to get full source.\"\"\"\n    if self._relative_loc is None:\n        return Path(self._source)\n    return Path(self._source) / self._relative_loc\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.FileLoader.get_supported_suffixes","title":"<code>get_supported_suffixes() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Return list of supported file types.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[str]</code> <p>List of filetypes.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@classmethod\ndef get_supported_suffixes(cls) -&gt; list[str]:\n    \"\"\"\n    Return list of supported file types.\n\n    Returns:\n        list: List of filetypes.\n\n    \"\"\"\n    return cls._SUPPORTED_SUFFIXES\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.FileLoader.set_source","title":"<code>set_source(new_source: Path, relative_loc: Path | str | None = None) -&gt; None</code>","text":"<p>Set absolute and relative parts of filepath.</p> <p>Parameters:</p> Name Type Description Default <code>new_source</code> <code>Path</code> <p>New absolute part.</p> required <code>relative_loc</code> <code>Optional[Union[Path, str]]</code> <p>New relative part. Defaults to None.</p> <code>None</code> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def set_source(self, new_source: Path, relative_loc: Path | str | None = None) -&gt; None:\n    \"\"\"\n    Set absolute and relative parts of filepath.\n\n    Args:\n        new_source (Path): New absolute part.\n        relative_loc (Optional[Union[Path, str]], optional): New relative part. Defaults to None.\n\n    \"\"\"\n    self._source = new_source\n    self._relative_loc = relative_loc\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Base Loader class defining common API and functionality for all Loaders.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class Loader(Base, ABC):\n    \"\"\"Base Loader class defining common API and functionality for all Loaders.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Set up cache of ids contained in the source of the Loader.\"\"\"\n        self._content_ids: list[str] = None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Overwrite string representation.\n\n        Returns:\n            str: Object represented as string.\n\n        \"\"\"\n        return f\"{type(self).__name__}({vars(self)})\"\n\n    def __getstate__(self) -&gt; dict:\n        \"\"\"\n        Return current object state, clearing any cached data.\n\n        Returns:\n            dict: The object's state dictionary.\n\n        \"\"\"\n        self.clear_cache()\n        return self.__dict__\n\n    @abstractmethod\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear cached data from the loader.\"\"\"\n        pass\n\n    def __deepcopy__(self, memo: dict) -&gt; Loader:\n        \"\"\"\n        Overwrite deepcopy.\n\n        This is done to enable sharing of loaders. Since a loader is connected to one source, caching can thus be shared\n        between Models.\n\n        Args:\n            memo (dict): Required argument.\n\n        Returns:\n            Loader: Returns itself.\n\n        \"\"\"\n        return self\n\n    @abstractmethod\n    def get_source(self) -&gt; object:\n        \"\"\"\n        Return Loader source.\n\n        Returns:\n            object: Whatever the Loader interacts with to retrieve data.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_source(self, new_source: object) -&gt; None:\n        \"\"\"\n        Set the Loader source.\n\n        Args:\n            new_source (object): Whatever the Loader should interact with to retrieve data.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_metadata(self, content_id: str) -&gt; object:\n        \"\"\"\n        Get metadata from the Loader source.\n\n        The metadata could describe behavior of the data in source.\n\n        Args:\n            content_id (str): Id of some content.\n\n        Returns:\n            object: Metadata in some format only the specific Loader knows.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _get_ids(self) -&gt; list[str]:\n        \"\"\"\n        Return list of names which can be used to access specific data structures whithin source.\n\n        Most likely the names of all time vectors or curves in The Loader's source.\n\n        Returns:\n            list[str]\n\n        \"\"\"\n        pass\n\n    def get_ids(self) -&gt; list[str]:\n        \"\"\"\n        Handle caching of ids existing in the loaders source.\n\n        Returns:\n            list[str]: List containing ids in Loader source.\n\n        \"\"\"\n        if self._content_ids is None:\n            self._content_ids = self._get_ids()\n            seen = set()\n            duplicates = []\n            for content_id in self._content_ids:\n                if content_id in seen:\n                    duplicates.append(content_id)\n                else:\n                    seen.add(content_id)\n            if duplicates:\n                msg = f\"Duplicate ID's found in {self.get_source()}: {duplicates}\"\n                raise ValueError(msg)\n\n        return self._content_ids\n\n    def _id_exsists(self, content_id: str) -&gt; None:\n        \"\"\"\n        Check if a given id exists in source.\n\n        Args:\n            content_id (str): Id of some content.\n\n        Raises:\n            KeyError: If content id does not exist.\n\n        \"\"\"\n        existing_ids = self.get_ids()\n        if content_id not in existing_ids:\n            # __repr__ should be overwritten in subclasses to produce enough info in error message.\n            msg = f\"Could not find ID {content_id} in {self}. Existing IDs: {existing_ids}\"\n            raise KeyError(msg)\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.__deepcopy__","title":"<code>__deepcopy__(memo: dict) -&gt; Loader</code>","text":"<p>Overwrite deepcopy.</p> <p>This is done to enable sharing of loaders. Since a loader is connected to one source, caching can thus be shared between Models.</p> <p>Parameters:</p> Name Type Description Default <code>memo</code> <code>dict</code> <p>Required argument.</p> required <p>Returns:</p> Name Type Description <code>Loader</code> <code>Loader</code> <p>Returns itself.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __deepcopy__(self, memo: dict) -&gt; Loader:\n    \"\"\"\n    Overwrite deepcopy.\n\n    This is done to enable sharing of loaders. Since a loader is connected to one source, caching can thus be shared\n    between Models.\n\n    Args:\n        memo (dict): Required argument.\n\n    Returns:\n        Loader: Returns itself.\n\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.__getstate__","title":"<code>__getstate__() -&gt; dict</code>","text":"<p>Return current object state, clearing any cached data.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The object's state dictionary.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __getstate__(self) -&gt; dict:\n    \"\"\"\n    Return current object state, clearing any cached data.\n\n    Returns:\n        dict: The object's state dictionary.\n\n    \"\"\"\n    self.clear_cache()\n    return self.__dict__\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Set up cache of ids contained in the source of the Loader.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Set up cache of ids contained in the source of the Loader.\"\"\"\n    self._content_ids: list[str] = None\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Overwrite string representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Object represented as string.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Overwrite string representation.\n\n    Returns:\n        str: Object represented as string.\n\n    \"\"\"\n    return f\"{type(self).__name__}({vars(self)})\"\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.clear_cache","title":"<code>clear_cache() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Clear cached data from the loader.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef clear_cache(self) -&gt; None:\n    \"\"\"Clear cached data from the loader.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.get_ids","title":"<code>get_ids() -&gt; list[str]</code>","text":"<p>Handle caching of ids existing in the loaders source.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List containing ids in Loader source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def get_ids(self) -&gt; list[str]:\n    \"\"\"\n    Handle caching of ids existing in the loaders source.\n\n    Returns:\n        list[str]: List containing ids in Loader source.\n\n    \"\"\"\n    if self._content_ids is None:\n        self._content_ids = self._get_ids()\n        seen = set()\n        duplicates = []\n        for content_id in self._content_ids:\n            if content_id in seen:\n                duplicates.append(content_id)\n            else:\n                seen.add(content_id)\n        if duplicates:\n            msg = f\"Duplicate ID's found in {self.get_source()}: {duplicates}\"\n            raise ValueError(msg)\n\n    return self._content_ids\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.get_metadata","title":"<code>get_metadata(content_id: str) -&gt; object</code>  <code>abstractmethod</code>","text":"<p>Get metadata from the Loader source.</p> <p>The metadata could describe behavior of the data in source.</p> <p>Parameters:</p> Name Type Description Default <code>content_id</code> <code>str</code> <p>Id of some content.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Metadata in some format only the specific Loader knows.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_metadata(self, content_id: str) -&gt; object:\n    \"\"\"\n    Get metadata from the Loader source.\n\n    The metadata could describe behavior of the data in source.\n\n    Args:\n        content_id (str): Id of some content.\n\n    Returns:\n        object: Metadata in some format only the specific Loader knows.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.get_source","title":"<code>get_source() -&gt; object</code>  <code>abstractmethod</code>","text":"<p>Return Loader source.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Whatever the Loader interacts with to retrieve data.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_source(self) -&gt; object:\n    \"\"\"\n    Return Loader source.\n\n    Returns:\n        object: Whatever the Loader interacts with to retrieve data.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.Loader.set_source","title":"<code>set_source(new_source: object) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>new_source</code> <code>object</code> <p>Whatever the Loader should interact with to retrieve data.</p> required Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef set_source(self, new_source: object) -&gt; None:\n    \"\"\"\n    Set the Loader source.\n\n    Args:\n        new_source (object): Whatever the Loader should interact with to retrieve data.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader","title":"<code>TimeVectorLoader</code>","text":"<p>               Bases: <code>Loader</code>, <code>ABC</code></p> <p>Loader API for retrieving time vector data from some source.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>class TimeVectorLoader(Loader, ABC):\n    \"\"\"Loader API for retrieving time vector data from some source.\"\"\"\n\n    @abstractmethod\n    def get_values(self, vector_id: str) -&gt; NDArray:\n        \"\"\"\n        Return the values of a time vector in the Loader source.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            NDArray: Numpy array of all values.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_index(self, vector_id: str) -&gt; TimeIndex:\n        \"\"\"\n        Return the index a time vector in the Loader source.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            NDArray: TimeIndex object.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_unit(self, vector_id: str) -&gt; str:\n        \"\"\"\n        Return unit of the values within a time vector in the loader source.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            str: String with unit.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_max_level(self, vector_id: str) -&gt; bool | None:\n        \"\"\"\n        Check if the given TimeVector is a level representing max Volume/Capacity/Price.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            True - vector is a level representing max Volume/Capacity.\n            False - vector is a level representing average Volume/Capacity over a given reference period.\n            None - vector is not a level.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_zero_one_profile(self, vector_id: str) -&gt; bool | None:\n        \"\"\"\n        Check if the given TimeVector is a profile with values between zero and one.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            True - vector is a profile with values between zero and one.\n            False - vector is a profile where the mean value is 1 given a reference period.\n            None - vector is not a profile.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_reference_period(self, vector_id: str) -&gt; ReferencePeriod | None:\n        \"\"\"\n        Get the reference period of a given vector.\n\n        Args:\n            vector_id (str): ID of the vector.\n\n        Returns:\n            ReferencePeriod - if the vector is a mean one profile or average level, a reference period must exist.\n            None - No reference period if vector is max level, zero one profile or not a level or profile.\n\n        \"\"\"\n        pass\n\n    def get_fingerprint(self, vector_id: str) -&gt; Fingerprint:\n        \"\"\"Return Loader Fingerprint for given vector id.\"\"\"\n        f = Fingerprint(self)\n        f.add(\"unit\", self.get_unit(vector_id))\n        f.add(\"index\", self.get_index(vector_id))\n        f.add(\"values\", self.get_values(vector_id))\n        return f\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader.get_fingerprint","title":"<code>get_fingerprint(vector_id: str) -&gt; Fingerprint</code>","text":"<p>Return Loader Fingerprint for given vector id.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>def get_fingerprint(self, vector_id: str) -&gt; Fingerprint:\n    \"\"\"Return Loader Fingerprint for given vector id.\"\"\"\n    f = Fingerprint(self)\n    f.add(\"unit\", self.get_unit(vector_id))\n    f.add(\"index\", self.get_index(vector_id))\n    f.add(\"values\", self.get_values(vector_id))\n    return f\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader.get_index","title":"<code>get_index(vector_id: str) -&gt; TimeIndex</code>  <code>abstractmethod</code>","text":"<p>Return the index a time vector in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>TimeIndex</code> <p>TimeIndex object.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_index(self, vector_id: str) -&gt; TimeIndex:\n    \"\"\"\n    Return the index a time vector in the Loader source.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        NDArray: TimeIndex object.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader.get_reference_period","title":"<code>get_reference_period(vector_id: str) -&gt; ReferencePeriod | None</code>  <code>abstractmethod</code>","text":"<p>Get the reference period of a given vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Type Description <code>ReferencePeriod | None</code> <p>ReferencePeriod - if the vector is a mean one profile or average level, a reference period must exist.</p> <code>ReferencePeriod | None</code> <p>None - No reference period if vector is max level, zero one profile or not a level or profile.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_reference_period(self, vector_id: str) -&gt; ReferencePeriod | None:\n    \"\"\"\n    Get the reference period of a given vector.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        ReferencePeriod - if the vector is a mean one profile or average level, a reference period must exist.\n        None - No reference period if vector is max level, zero one profile or not a level or profile.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader.get_unit","title":"<code>get_unit(vector_id: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return unit of the values within a time vector in the loader source.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with unit.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_unit(self, vector_id: str) -&gt; str:\n    \"\"\"\n    Return unit of the values within a time vector in the loader source.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        str: String with unit.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader.get_values","title":"<code>get_values(vector_id: str) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Return the values of a time vector in the Loader source.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>Numpy array of all values.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef get_values(self, vector_id: str) -&gt; NDArray:\n    \"\"\"\n    Return the values of a time vector in the Loader source.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        NDArray: Numpy array of all values.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader.is_max_level","title":"<code>is_max_level(vector_id: str) -&gt; bool | None</code>  <code>abstractmethod</code>","text":"<p>Check if the given TimeVector is a level representing max Volume/Capacity/Price.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Type Description <code>bool | None</code> <p>True - vector is a level representing max Volume/Capacity.</p> <code>bool | None</code> <p>False - vector is a level representing average Volume/Capacity over a given reference period.</p> <code>bool | None</code> <p>None - vector is not a level.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef is_max_level(self, vector_id: str) -&gt; bool | None:\n    \"\"\"\n    Check if the given TimeVector is a level representing max Volume/Capacity/Price.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        True - vector is a level representing max Volume/Capacity.\n        False - vector is a level representing average Volume/Capacity over a given reference period.\n        None - vector is not a level.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.loaders.loaders.TimeVectorLoader.is_zero_one_profile","title":"<code>is_zero_one_profile(vector_id: str) -&gt; bool | None</code>  <code>abstractmethod</code>","text":"<p>Check if the given TimeVector is a profile with values between zero and one.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>ID of the vector.</p> required <p>Returns:</p> Type Description <code>bool | None</code> <p>True - vector is a profile with values between zero and one.</p> <code>bool | None</code> <p>False - vector is a profile where the mean value is 1 given a reference period.</p> <code>bool | None</code> <p>None - vector is not a profile.</p> Source code in <code>framcore/loaders/loaders.py</code> <pre><code>@abstractmethod\ndef is_zero_one_profile(self, vector_id: str) -&gt; bool | None:\n    \"\"\"\n    Check if the given TimeVector is a profile with values between zero and one.\n\n    Args:\n        vector_id (str): ID of the vector.\n\n    Returns:\n        True - vector is a profile with values between zero and one.\n        False - vector is a profile where the mean value is 1 given a reference period.\n        None - vector is not a profile.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.metadata","title":"<code>metadata</code>","text":""},{"location":"reference/#framcore.metadata.Div","title":"<code>Div</code>","text":""},{"location":"reference/#framcore.metadata.Div.Div","title":"<code>Div</code>","text":"<p>               Bases: <code>Meta</code></p> <p>Div class is made for loss-less aggregation of metadata. Subclass of Meta.</p> <p>It's combine method is made to keep all unique metadata, so that nothing is thrown away in connection with aggregation.</p> Source code in <code>framcore/metadata/Div.py</code> <pre><code>class Div(Meta):\n    \"\"\"\n    Div class is made for loss-less aggregation of metadata. Subclass of Meta.\n\n    It's combine method is made to keep all unique metadata,\n    so that nothing is thrown away in connection with aggregation.\n    \"\"\"\n\n    def __init__(self, value: Meta | set[Meta] | None = None) -&gt; None:\n        \"\"\"Create Div metadata.\"\"\"\n        self._check_type_meta(value, with_none=True)\n\n        self._value: set[Meta] = set()\n\n        if isinstance(value, set):\n            self._value.update(value)\n\n        elif isinstance(value, Meta):\n            self._value.add(value)\n\n    def _check_type_meta(self, value: Meta | set[Meta], with_none: bool) -&gt; None:\n        if with_none:\n            self._check_type(value, (Meta, set, type(None)))\n        else:\n            self._check_type(value, (Meta, set))\n        if isinstance(value, set):\n            for x in value:\n                self._check_type(x, Meta)\n\n    def get_value(self) -&gt; set[Meta]:\n        \"\"\"Return str value.\"\"\"\n        return self._value\n\n    def set_value(self, value: Meta | set[Meta]) -&gt; None:\n        \"\"\"Set str value. TypeError if not str.\"\"\"\n        self._check_type_meta(value, with_none=False)\n        if isinstance(value, set):\n            self._value.update(value)\n\n        elif isinstance(value, Meta):\n            self._value.add(value)\n\n    def combine(self, other: Meta | set[Meta]) -&gt; Div:\n        \"\"\"Just consume other and return self.\"\"\"\n        self._check_type_meta(other, with_none=True)\n        if isinstance(other, Div):\n            for x in other.get_value():\n                self.combine(x)\n        else:\n            self.set_value(other)\n        return self\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"\n        Generate and return a Fingerprint representing the current set of Meta values.\n\n        Returns\n        -------\n        Fingerprint\n            A fingerprint object based on the hashes of the contained Meta values.\n\n        \"\"\"\n        fingerprint = Fingerprint()\n        hash_list = [value.get_fingerprint().get_hash() for value in self._value]\n        fingerprint.add(\"_value\", _custom_hash(hash_list))\n        return fingerprint\n</code></pre>"},{"location":"reference/#framcore.metadata.Div.Div.__init__","title":"<code>__init__(value: Meta | set[Meta] | None = None) -&gt; None</code>","text":"<p>Create Div metadata.</p> Source code in <code>framcore/metadata/Div.py</code> <pre><code>def __init__(self, value: Meta | set[Meta] | None = None) -&gt; None:\n    \"\"\"Create Div metadata.\"\"\"\n    self._check_type_meta(value, with_none=True)\n\n    self._value: set[Meta] = set()\n\n    if isinstance(value, set):\n        self._value.update(value)\n\n    elif isinstance(value, Meta):\n        self._value.add(value)\n</code></pre>"},{"location":"reference/#framcore.metadata.Div.Div.combine","title":"<code>combine(other: Meta | set[Meta]) -&gt; Div</code>","text":"<p>Just consume other and return self.</p> Source code in <code>framcore/metadata/Div.py</code> <pre><code>def combine(self, other: Meta | set[Meta]) -&gt; Div:\n    \"\"\"Just consume other and return self.\"\"\"\n    self._check_type_meta(other, with_none=True)\n    if isinstance(other, Div):\n        for x in other.get_value():\n            self.combine(x)\n    else:\n        self.set_value(other)\n    return self\n</code></pre>"},{"location":"reference/#framcore.metadata.Div.Div.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Generate and return a Fingerprint representing the current set of Meta values.</p>"},{"location":"reference/#framcore.metadata.Div.Div.get_fingerprint--returns","title":"Returns","text":"<p>Fingerprint     A fingerprint object based on the hashes of the contained Meta values.</p> Source code in <code>framcore/metadata/Div.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"\n    Generate and return a Fingerprint representing the current set of Meta values.\n\n    Returns\n    -------\n    Fingerprint\n        A fingerprint object based on the hashes of the contained Meta values.\n\n    \"\"\"\n    fingerprint = Fingerprint()\n    hash_list = [value.get_fingerprint().get_hash() for value in self._value]\n    fingerprint.add(\"_value\", _custom_hash(hash_list))\n    return fingerprint\n</code></pre>"},{"location":"reference/#framcore.metadata.Div.Div.get_value","title":"<code>get_value() -&gt; set[Meta]</code>","text":"<p>Return str value.</p> Source code in <code>framcore/metadata/Div.py</code> <pre><code>def get_value(self) -&gt; set[Meta]:\n    \"\"\"Return str value.\"\"\"\n    return self._value\n</code></pre>"},{"location":"reference/#framcore.metadata.Div.Div.set_value","title":"<code>set_value(value: Meta | set[Meta]) -&gt; None</code>","text":"<p>Set str value. TypeError if not str.</p> Source code in <code>framcore/metadata/Div.py</code> <pre><code>def set_value(self, value: Meta | set[Meta]) -&gt; None:\n    \"\"\"Set str value. TypeError if not str.\"\"\"\n    self._check_type_meta(value, with_none=False)\n    if isinstance(value, set):\n        self._value.update(value)\n\n    elif isinstance(value, Meta):\n        self._value.add(value)\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta","title":"<code>ExprMeta</code>","text":""},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta","title":"<code>ExprMeta</code>","text":"<p>               Bases: <code>Meta</code></p> <p>ExprMeta represent an Expr. Subclass of Meta.</p> <p>When used, all components must have a ExprMeta.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>class ExprMeta(Meta):\n    \"\"\"\n    ExprMeta represent an Expr. Subclass of Meta.\n\n    When used, all components must have a ExprMeta.\n    \"\"\"\n\n    def __init__(self, value: Expr) -&gt; None:\n        \"\"\"Create new ExprMeta with float value.\"\"\"\n        self._value = value\n        self._check_type(value, Expr)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overwrite __repr__ for better string representation.\"\"\"\n        if not hasattr(self, \"_value\"):\n            return f\"{type(self).__name__}(uninitialized)\"\n        return f\"{type(self).__name__}(expr={self._value})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality based on expr.\"\"\"\n        if not isinstance(other, ExprMeta):\n            return False\n        return self._value == other._value\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute the hash of the ExprMeta.\"\"\"\n        return hash(self._value)\n\n    def get_value(self) -&gt; Expr:\n        \"\"\"Return expr.\"\"\"\n        return self._value\n\n    def set_value(self, value: Expr) -&gt; None:\n        \"\"\"Set expr value. TypeError if not expr.\"\"\"\n        self._check_type(value, Expr)\n        self._value = value\n\n    def combine(self, other: Meta) -&gt; Expr | Div:\n        \"\"\"Sum Expr.\"\"\"\n        if isinstance(other, ExprMeta):\n            return self._value + other.get_value()\n\n        div = Div(self)\n        div.set_value(other)\n        return div\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the fingerprint of the ScalarMeta.\"\"\"\n        return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.__eq__","title":"<code>__eq__(other: object) -&gt; bool</code>","text":"<p>Check equality based on expr.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality based on expr.\"\"\"\n    if not isinstance(other, ExprMeta):\n        return False\n    return self._value == other._value\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Compute the hash of the ExprMeta.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute the hash of the ExprMeta.\"\"\"\n    return hash(self._value)\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.__init__","title":"<code>__init__(value: Expr) -&gt; None</code>","text":"<p>Create new ExprMeta with float value.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def __init__(self, value: Expr) -&gt; None:\n    \"\"\"Create new ExprMeta with float value.\"\"\"\n    self._value = value\n    self._check_type(value, Expr)\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Overwrite repr for better string representation.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overwrite __repr__ for better string representation.\"\"\"\n    if not hasattr(self, \"_value\"):\n        return f\"{type(self).__name__}(uninitialized)\"\n    return f\"{type(self).__name__}(expr={self._value})\"\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.combine","title":"<code>combine(other: Meta) -&gt; Expr | Div</code>","text":"<p>Sum Expr.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def combine(self, other: Meta) -&gt; Expr | Div:\n    \"\"\"Sum Expr.\"\"\"\n    if isinstance(other, ExprMeta):\n        return self._value + other.get_value()\n\n    div = Div(self)\n    div.set_value(other)\n    return div\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the fingerprint of the ScalarMeta.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the fingerprint of the ScalarMeta.\"\"\"\n    return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.get_value","title":"<code>get_value() -&gt; Expr</code>","text":"<p>Return expr.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def get_value(self) -&gt; Expr:\n    \"\"\"Return expr.\"\"\"\n    return self._value\n</code></pre>"},{"location":"reference/#framcore.metadata.ExprMeta.ExprMeta.set_value","title":"<code>set_value(value: Expr) -&gt; None</code>","text":"<p>Set expr value. TypeError if not expr.</p> Source code in <code>framcore/metadata/ExprMeta.py</code> <pre><code>def set_value(self, value: Expr) -&gt; None:\n    \"\"\"Set expr value. TypeError if not expr.\"\"\"\n    self._check_type(value, Expr)\n    self._value = value\n</code></pre>"},{"location":"reference/#framcore.metadata.LevelExprMeta","title":"<code>LevelExprMeta</code>","text":""},{"location":"reference/#framcore.metadata.LevelExprMeta.LevelExprMeta","title":"<code>LevelExprMeta</code>","text":"<p>               Bases: <code>ExprMeta</code></p> <p>LevelExprMeta represent an Expr. Subclass of ExprMeta.</p> <p>When used, all components must have a ExprMeta.</p> Source code in <code>framcore/metadata/LevelExprMeta.py</code> <pre><code>class LevelExprMeta(ExprMeta):\n    \"\"\"\n    LevelExprMeta represent an Expr. Subclass of ExprMeta.\n\n    When used, all components must have a ExprMeta.\n    \"\"\"\n\n    def __init__(self, value: Expr | TimeVector) -&gt; None:\n        \"\"\"\n        Create new LevelExprMeta with Expr value.\n\n        Args:\n            value (Expr | TimeVector): Accepts Expr with is_level=True or TimeVector with is_max_level=True/False.\n\n        Raises:\n            TypeError: If value is not Expr or TimeVector.\n            ValueError: If value is non-level Expr or TimeVector.\n\n        \"\"\"\n        self._check_type(value, (Expr, TimeVector))\n\n        if isinstance(value, TimeVector) and value.is_max_level() is None:\n            raise ValueError(\"Parameter 'value' (TimeVector) must be a level (is_max_level must be True or False).\")\n\n        self._value = ensure_expr(value, is_level=True)\n</code></pre>"},{"location":"reference/#framcore.metadata.LevelExprMeta.LevelExprMeta.__init__","title":"<code>__init__(value: Expr | TimeVector) -&gt; None</code>","text":"<p>Create new LevelExprMeta with Expr value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Expr | TimeVector</code> <p>Accepts Expr with is_level=True or TimeVector with is_max_level=True/False.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If value is not Expr or TimeVector.</p> <code>ValueError</code> <p>If value is non-level Expr or TimeVector.</p> Source code in <code>framcore/metadata/LevelExprMeta.py</code> <pre><code>def __init__(self, value: Expr | TimeVector) -&gt; None:\n    \"\"\"\n    Create new LevelExprMeta with Expr value.\n\n    Args:\n        value (Expr | TimeVector): Accepts Expr with is_level=True or TimeVector with is_max_level=True/False.\n\n    Raises:\n        TypeError: If value is not Expr or TimeVector.\n        ValueError: If value is non-level Expr or TimeVector.\n\n    \"\"\"\n    self._check_type(value, (Expr, TimeVector))\n\n    if isinstance(value, TimeVector) and value.is_max_level() is None:\n        raise ValueError(\"Parameter 'value' (TimeVector) must be a level (is_max_level must be True or False).\")\n\n    self._value = ensure_expr(value, is_level=True)\n</code></pre>"},{"location":"reference/#framcore.metadata.Member","title":"<code>Member</code>","text":""},{"location":"reference/#framcore.metadata.Member.Member","title":"<code>Member</code>","text":"<p>               Bases: <code>Meta</code></p> <p>Member represent membership to a catergory or group using a str. Subclass of Meta.</p> <p>Should not have missing values.</p> <p>When used, all components must have a membership.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>class Member(Meta):\n    \"\"\"\n    Member represent membership to a catergory or group using a str. Subclass of Meta.\n\n    Should not have missing values.\n\n    When used, all components must have a membership.\n    \"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Create new member with str value.\"\"\"\n        self._value = value\n        self._check_type(value, str)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overwrite __repr__ for better string representation.\"\"\"\n        return f\"{type(self).__name__}(value={self._value})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality based on value.\"\"\"\n        if not isinstance(other, Member):\n            return False\n        return self._value == other._value\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Overwrite __hash__ since its added to sets.\"\"\"\n        return hash(self.__repr__())\n\n    def get_value(self) -&gt; str:\n        \"\"\"Return str value.\"\"\"\n        return self._value\n\n    def set_value(self, value: str) -&gt; None:\n        \"\"\"Set str value. TypeError if not str.\"\"\"\n        self._check_type(value, str)\n        self._value = value\n\n    def combine(self, other: Meta) -&gt; Member | Div:\n        \"\"\"Return self if other == self else return Div containing both.\"\"\"\n        if self == other:\n            return self\n        d = Div(self)\n        d.set_value(other)\n        return d\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the fingerprint of the Member.\"\"\"\n        return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.__eq__","title":"<code>__eq__(other: object) -&gt; bool</code>","text":"<p>Check equality based on value.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality based on value.\"\"\"\n    if not isinstance(other, Member):\n        return False\n    return self._value == other._value\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Overwrite hash since its added to sets.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Overwrite __hash__ since its added to sets.\"\"\"\n    return hash(self.__repr__())\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.__init__","title":"<code>__init__(value: str) -&gt; None</code>","text":"<p>Create new member with str value.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Create new member with str value.\"\"\"\n    self._value = value\n    self._check_type(value, str)\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Overwrite repr for better string representation.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overwrite __repr__ for better string representation.\"\"\"\n    return f\"{type(self).__name__}(value={self._value})\"\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.combine","title":"<code>combine(other: Meta) -&gt; Member | Div</code>","text":"<p>Return self if other == self else return Div containing both.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def combine(self, other: Meta) -&gt; Member | Div:\n    \"\"\"Return self if other == self else return Div containing both.\"\"\"\n    if self == other:\n        return self\n    d = Div(self)\n    d.set_value(other)\n    return d\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the fingerprint of the Member.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the fingerprint of the Member.\"\"\"\n    return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.get_value","title":"<code>get_value() -&gt; str</code>","text":"<p>Return str value.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def get_value(self) -&gt; str:\n    \"\"\"Return str value.\"\"\"\n    return self._value\n</code></pre>"},{"location":"reference/#framcore.metadata.Member.Member.set_value","title":"<code>set_value(value: str) -&gt; None</code>","text":"<p>Set str value. TypeError if not str.</p> Source code in <code>framcore/metadata/Member.py</code> <pre><code>def set_value(self, value: str) -&gt; None:\n    \"\"\"Set str value. TypeError if not str.\"\"\"\n    self._check_type(value, str)\n    self._value = value\n</code></pre>"},{"location":"reference/#framcore.metadata.Meta","title":"<code>Meta</code>","text":""},{"location":"reference/#framcore.metadata.Meta.Meta","title":"<code>Meta</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Metadata-interface class for components.</p> <p>The interface is there to support validation and aggregation. - Some types of metadata should not have any missing values - Different types of metadata should be aggregated differently (e.g. ignore, sum, mean, keep all in list, etc.)</p> Source code in <code>framcore/metadata/Meta.py</code> <pre><code>class Meta(Base, ABC):\n    \"\"\"\n    Metadata-interface class for components.\n\n    The interface is there to support validation and aggregation.\n    - Some types of metadata should not have any missing values\n    - Different types of metadata should be aggregated differently (e.g. ignore, sum, mean, keep all in list, etc.)\n    \"\"\"\n\n    @abstractmethod\n    def get_value(self) -&gt; Any:  # noqa: ANN401\n        \"\"\"Return metadata value.\"\"\"\n        pass\n\n    @abstractmethod\n    def set_value(self, value: Any) -&gt; None:  # noqa: ANN401\n        \"\"\"\n        Set metadata value.\n\n        Error if incorrect type or value.\n\n        Some Meta types may be immutable and thus error if\n        set_value is called with any value.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def combine(self, other: Meta) -&gt; Meta | None:\n        \"\"\"How should this metadata type be aggregated?.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Return fingerprint.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/#framcore.metadata.Meta.Meta.combine","title":"<code>combine(other: Meta) -&gt; Meta | None</code>  <code>abstractmethod</code>","text":"<p>How should this metadata type be aggregated?.</p> Source code in <code>framcore/metadata/Meta.py</code> <pre><code>@abstractmethod\ndef combine(self, other: Meta) -&gt; Meta | None:\n    \"\"\"How should this metadata type be aggregated?.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.metadata.Meta.Meta.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>  <code>abstractmethod</code>","text":"<p>Return fingerprint.</p> Source code in <code>framcore/metadata/Meta.py</code> <pre><code>@abstractmethod\ndef get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Return fingerprint.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.metadata.Meta.Meta.get_value","title":"<code>get_value() -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Return metadata value.</p> Source code in <code>framcore/metadata/Meta.py</code> <pre><code>@abstractmethod\ndef get_value(self) -&gt; Any:  # noqa: ANN401\n    \"\"\"Return metadata value.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.metadata.Meta.Meta.set_value","title":"<code>set_value(value: Any) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set metadata value.</p> <p>Error if incorrect type or value.</p> <p>Some Meta types may be immutable and thus error if set_value is called with any value.</p> Source code in <code>framcore/metadata/Meta.py</code> <pre><code>@abstractmethod\ndef set_value(self, value: Any) -&gt; None:  # noqa: ANN401\n    \"\"\"\n    Set metadata value.\n\n    Error if incorrect type or value.\n\n    Some Meta types may be immutable and thus error if\n    set_value is called with any value.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.populators","title":"<code>populators</code>","text":""},{"location":"reference/#framcore.populators.Populator","title":"<code>Populator</code>","text":"<p>Populator API, for creating a system of Components, TimeVectors and Curves (and Expr) for a Model object.</p>"},{"location":"reference/#framcore.populators.Populator.Populator","title":"<code>Populator</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Populate a model with data from a data source.</p> Source code in <code>framcore/populators/Populator.py</code> <pre><code>class Populator(Base, ABC):\n    \"\"\"Populate a model with data from a data source.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Set up ID and reference registration containers.\n\n        These are used to check if IDs and references actually exist in the system.\n        \"\"\"\n        super().__init__()\n\n        self._registered_ids: dict[str, list[object]] = {}\n        self._registered_refs: dict[str, set[str]] = {}\n\n    def populate(self, model: Model) -&gt; None:\n        \"\"\"\n        Add data objects from a database to an input Model.\n\n        These data objects shall be of class Component, TimeVector, and Curve.\n        The method _populate should be overwritten in a subclass of Populator.\n        In this way, it is used to create objects from any database.\n\n        Args:\n            model (Model): Model which will have the objects added to it.\n\n        \"\"\"\n        self._check_type(model, Model)\n        new_data = self._populate()\n\n        # check that the new_data dict complies with the type hints of _populate?\n        for existing_id in model.get_data():\n            self._register_id(existing_id, model)\n        errors = list(self._check_duplicate_ids())\n        model.get_data().update(new_data)\n        errors += list(self._check_references(model.get_data()))\n        self._report_errors(errors)\n\n    @abstractmethod\n    def _populate(self) -&gt; dict[str, Component | TimeVector | Curve | Expr]:\n        \"\"\"Create and return Components, TimeVectors and Curves. Possibly also Exprs.\"\"\"\n        pass\n\n    def _check_duplicate_ids(self) -&gt; dict[str, list[object]]:\n        \"\"\"\n        Retrieve dictionary with ids of duplicated objects and their corresponding source.\n\n        Returns:\n            dict[str, list[object]]: keys are ids and values are lists of sources.\n\n        \"\"\"\n        return {f\"Duplicate ID found: '{duplicate_id}' in sources {sources}\" for duplicate_id, sources in self._registered_ids.items() if len(sources) &gt; 1}\n\n    def _check_references(self, data: dict[str, Component | TimeVector | Curve | Expr]) -&gt; set:\n        errors = set()\n        for ref, referencers in self._registered_refs.items():\n            if ref not in data:\n                msg = f\"References to an invalid ID found. ID '{ref}' is not connected to any data.\"\n                try:\n                    sources = {source_id: data[source_id] for source_id in referencers}\n                except KeyError:\n                    errors.add(\n                        msg + f\" Sub Components referencing the faulty ID: {referencers}\",\n                    )\n                else:\n                    errors.add(\n                        msg + f\" Components referencing the faulty ID: {sources}\",\n                    )\n        return errors\n\n    def _report_errors(self, errors: list[str]) -&gt; None:\n        if errors:\n            n = len(errors)\n            s = \"s\" if n &gt; 1 else \"\"\n            error_str = \"\\n\".join(errors)\n            message = f\"Found {n} error{s}:\\n{error_str}\"\n            raise RuntimeError(message)\n\n    def _register_id(self, new_id: str, source: object) -&gt; None:\n        \"\"\"\n        Register an id and its source.\n\n        Args:\n            new_id (str): New id to be registered.\n            source (object): Source of the new id.\n\n        \"\"\"\n        if new_id in self._registered_ids:\n            self._registered_ids[new_id].append(source)\n        else:\n            self._registered_ids[new_id] = [source]\n\n    def _register_references(self, component_id: str, references: set) -&gt; None:\n        for ref in references:\n            if ref in self._registered_refs:\n                self._registered_refs[ref].add(component_id)\n            else:\n                self._registered_refs[ref] = {component_id}\n</code></pre>"},{"location":"reference/#framcore.populators.Populator.Populator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Set up ID and reference registration containers.</p> <p>These are used to check if IDs and references actually exist in the system.</p> Source code in <code>framcore/populators/Populator.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Set up ID and reference registration containers.\n\n    These are used to check if IDs and references actually exist in the system.\n    \"\"\"\n    super().__init__()\n\n    self._registered_ids: dict[str, list[object]] = {}\n    self._registered_refs: dict[str, set[str]] = {}\n</code></pre>"},{"location":"reference/#framcore.populators.Populator.Populator.populate","title":"<code>populate(model: Model) -&gt; None</code>","text":"<p>Add data objects from a database to an input Model.</p> <p>These data objects shall be of class Component, TimeVector, and Curve. The method _populate should be overwritten in a subclass of Populator. In this way, it is used to create objects from any database.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Model which will have the objects added to it.</p> required Source code in <code>framcore/populators/Populator.py</code> <pre><code>def populate(self, model: Model) -&gt; None:\n    \"\"\"\n    Add data objects from a database to an input Model.\n\n    These data objects shall be of class Component, TimeVector, and Curve.\n    The method _populate should be overwritten in a subclass of Populator.\n    In this way, it is used to create objects from any database.\n\n    Args:\n        model (Model): Model which will have the objects added to it.\n\n    \"\"\"\n    self._check_type(model, Model)\n    new_data = self._populate()\n\n    # check that the new_data dict complies with the type hints of _populate?\n    for existing_id in model.get_data():\n        self._register_id(existing_id, model)\n    errors = list(self._check_duplicate_ids())\n    model.get_data().update(new_data)\n    errors += list(self._check_references(model.get_data()))\n    self._report_errors(errors)\n</code></pre>"},{"location":"reference/#framcore.querydbs","title":"<code>querydbs</code>","text":""},{"location":"reference/#framcore.querydbs.CacheDB","title":"<code>CacheDB</code>","text":""},{"location":"reference/#framcore.querydbs.CacheDB.CacheDB","title":"<code>CacheDB</code>","text":"<p>               Bases: <code>QueryDB</code></p> <p>Stores models and precomputed values.</p> Source code in <code>framcore/querydbs/CacheDB.py</code> <pre><code>class CacheDB(QueryDB):\n    \"\"\"Stores models and precomputed values.\"\"\"\n\n    def __init__(self, model: Model, *models: tuple[Model]) -&gt; None:\n        \"\"\"\n        Initialize CacheDB with one or more Model instances.\n\n        Args:\n            model (Model): The primary Model instance.\n            *models (tuple[Model]): Additional Model instances.\n\n        \"\"\"\n        self._models: tuple[Model] = (model, *models)\n        self._cache = dict()\n        self._min_elapsed_seconds = 0.01\n\n    def set_min_elapsed_seconds(self, value: float) -&gt; None:\n        \"\"\"Values that takes below this threshold to compute, does not get cached.\"\"\"\n        self._check_type(value, float)\n        self._check_float(value=value, lower_bound=0.0, upper_bound=None)\n        self._min_elapsed_seconds = value\n\n    def get_min_elapsed_seconds(self) -&gt; float:\n        \"\"\"Values that takes below this threshold to compute, does not get cached.\"\"\"\n        return self._min_elapsed_seconds\n\n    def _get(self, key: object) -&gt; object:\n        if key in self._cache:\n            return self._cache[key]\n        for m in self._models:\n            data = m.get_data()\n            if key in data:\n                return data[key]\n        message = f\"Key '{key}' not found.\"\n        raise KeyError(message)\n\n    def _has_key(self, key: object) -&gt; bool:\n        return key in self._cache or any(key in m.get_data() for m in self._models)\n\n    def _put(self, key: object, value: object, elapsed_seconds: float) -&gt; None:\n        if elapsed_seconds &lt; self._min_elapsed_seconds:\n            return\n        self._cache[key] = value\n\n    def _get_data(self) -&gt; dict:\n        return self._models[0].get_data()\n</code></pre>"},{"location":"reference/#framcore.querydbs.CacheDB.CacheDB.__init__","title":"<code>__init__(model: Model, *models: tuple[Model]) -&gt; None</code>","text":"<p>Initialize CacheDB with one or more Model instances.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The primary Model instance.</p> required <code>*models</code> <code>tuple[Model]</code> <p>Additional Model instances.</p> <code>()</code> Source code in <code>framcore/querydbs/CacheDB.py</code> <pre><code>def __init__(self, model: Model, *models: tuple[Model]) -&gt; None:\n    \"\"\"\n    Initialize CacheDB with one or more Model instances.\n\n    Args:\n        model (Model): The primary Model instance.\n        *models (tuple[Model]): Additional Model instances.\n\n    \"\"\"\n    self._models: tuple[Model] = (model, *models)\n    self._cache = dict()\n    self._min_elapsed_seconds = 0.01\n</code></pre>"},{"location":"reference/#framcore.querydbs.CacheDB.CacheDB.get_min_elapsed_seconds","title":"<code>get_min_elapsed_seconds() -&gt; float</code>","text":"<p>Values that takes below this threshold to compute, does not get cached.</p> Source code in <code>framcore/querydbs/CacheDB.py</code> <pre><code>def get_min_elapsed_seconds(self) -&gt; float:\n    \"\"\"Values that takes below this threshold to compute, does not get cached.\"\"\"\n    return self._min_elapsed_seconds\n</code></pre>"},{"location":"reference/#framcore.querydbs.CacheDB.CacheDB.set_min_elapsed_seconds","title":"<code>set_min_elapsed_seconds(value: float) -&gt; None</code>","text":"<p>Values that takes below this threshold to compute, does not get cached.</p> Source code in <code>framcore/querydbs/CacheDB.py</code> <pre><code>def set_min_elapsed_seconds(self, value: float) -&gt; None:\n    \"\"\"Values that takes below this threshold to compute, does not get cached.\"\"\"\n    self._check_type(value, float)\n    self._check_float(value=value, lower_bound=0.0, upper_bound=None)\n    self._min_elapsed_seconds = value\n</code></pre>"},{"location":"reference/#framcore.querydbs.ModelDB","title":"<code>ModelDB</code>","text":""},{"location":"reference/#framcore.querydbs.ModelDB.ModelDB","title":"<code>ModelDB</code>","text":"<p>               Bases: <code>QueryDB</code></p> <p>A database-like interface for querying multiple Model instances.</p> Source code in <code>framcore/querydbs/ModelDB.py</code> <pre><code>class ModelDB(QueryDB):\n    \"\"\"A database-like interface for querying multiple Model instances.\"\"\"\n\n    def __init__(self, model: Model, *models: tuple[Model]) -&gt; None:\n        \"\"\"\n        Initialize ModelDB with one or more Model instances.\n\n        Args:\n            model (Model): The primary Model instance.\n            *models (tuple[Model]): Additional Model instances.\n\n        \"\"\"\n        self._models: tuple[Model] = (model, *models)\n\n    def _get(self, key: object) -&gt; object:\n        for m in self._models:\n            data = m.get_data()\n            if key in data:\n                return data[key]\n        message = f\"Key '{key}' not found.\"\n        raise KeyError(message)\n\n    def _has_key(self, key: object) -&gt; bool:\n        return any(key in m.get_data() for m in self._models)\n\n    def _put(self, key: object, value: object, elapsed_seconds: float) -&gt; None:\n        return None\n\n    def _get_data(self) -&gt; dict:\n        return self._models[0].get_data()\n</code></pre>"},{"location":"reference/#framcore.querydbs.ModelDB.ModelDB.__init__","title":"<code>__init__(model: Model, *models: tuple[Model]) -&gt; None</code>","text":"<p>Initialize ModelDB with one or more Model instances.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The primary Model instance.</p> required <code>*models</code> <code>tuple[Model]</code> <p>Additional Model instances.</p> <code>()</code> Source code in <code>framcore/querydbs/ModelDB.py</code> <pre><code>def __init__(self, model: Model, *models: tuple[Model]) -&gt; None:\n    \"\"\"\n    Initialize ModelDB with one or more Model instances.\n\n    Args:\n        model (Model): The primary Model instance.\n        *models (tuple[Model]): Additional Model instances.\n\n    \"\"\"\n    self._models: tuple[Model] = (model, *models)\n</code></pre>"},{"location":"reference/#framcore.querydbs.QueryDB","title":"<code>QueryDB</code>","text":""},{"location":"reference/#framcore.querydbs.QueryDB.QueryDB","title":"<code>QueryDB</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Abstract base class for database queries.</p> <p>Provides an interface for getting, putting, and checking keys in a database. Subclasses must implement the _get, _put, and _has_key methods.</p> Source code in <code>framcore/querydbs/QueryDB.py</code> <pre><code>class QueryDB(Base, ABC):\n    \"\"\"\n    Abstract base class for database queries.\n\n    Provides an interface for getting, putting, and checking keys in a database.\n    Subclasses must implement the _get, _put, and _has_key methods.\n\n    \"\"\"\n\n    def get(self, key: object) -&gt; object:\n        \"\"\"Get value behind key from db.\"\"\"\n        return self._get(key)\n\n    def put(self, key: object, value: object, elapsed_seconds: float) -&gt; None:\n        \"\"\"Put value in db behind key (maybe, depending on implementation).\"\"\"\n        self._put(key, value, elapsed_seconds)\n\n    def has_key(self, key: str) -&gt; bool:\n        \"\"\"Return True if db has value behind key.\"\"\"\n        return self._has_key(key)\n\n    def get_data(self) -&gt; dict:\n        \"\"\"Return output of get_data called on first underlying model.\"\"\"\n        return self._get_data()\n\n    @abstractmethod\n    def _get(self, key: object) -&gt; object:\n        pass\n\n    @abstractmethod\n    def _put(self, key: object, value: object, elapsed_seconds: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    def _has_key(self, key: object) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def _get_data(self) -&gt; dict:\n        pass\n</code></pre>"},{"location":"reference/#framcore.querydbs.QueryDB.QueryDB.get","title":"<code>get(key: object) -&gt; object</code>","text":"<p>Get value behind key from db.</p> Source code in <code>framcore/querydbs/QueryDB.py</code> <pre><code>def get(self, key: object) -&gt; object:\n    \"\"\"Get value behind key from db.\"\"\"\n    return self._get(key)\n</code></pre>"},{"location":"reference/#framcore.querydbs.QueryDB.QueryDB.get_data","title":"<code>get_data() -&gt; dict</code>","text":"<p>Return output of get_data called on first underlying model.</p> Source code in <code>framcore/querydbs/QueryDB.py</code> <pre><code>def get_data(self) -&gt; dict:\n    \"\"\"Return output of get_data called on first underlying model.\"\"\"\n    return self._get_data()\n</code></pre>"},{"location":"reference/#framcore.querydbs.QueryDB.QueryDB.has_key","title":"<code>has_key(key: str) -&gt; bool</code>","text":"<p>Return True if db has value behind key.</p> Source code in <code>framcore/querydbs/QueryDB.py</code> <pre><code>def has_key(self, key: str) -&gt; bool:\n    \"\"\"Return True if db has value behind key.\"\"\"\n    return self._has_key(key)\n</code></pre>"},{"location":"reference/#framcore.querydbs.QueryDB.QueryDB.put","title":"<code>put(key: object, value: object, elapsed_seconds: float) -&gt; None</code>","text":"<p>Put value in db behind key (maybe, depending on implementation).</p> Source code in <code>framcore/querydbs/QueryDB.py</code> <pre><code>def put(self, key: object, value: object, elapsed_seconds: float) -&gt; None:\n    \"\"\"Put value in db behind key (maybe, depending on implementation).\"\"\"\n    self._put(key, value, elapsed_seconds)\n</code></pre>"},{"location":"reference/#framcore.solvers","title":"<code>solvers</code>","text":""},{"location":"reference/#framcore.solvers.Solver","title":"<code>Solver</code>","text":""},{"location":"reference/#framcore.solvers.Solver.Solver","title":"<code>Solver</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>Solver inteface class.</p> <p>In FRAM we call energy market models for Solvers. They take a populated Model and configurations from a SolverConfig, and transfers this to the solver software. Then it solves the energy market model, and writes results back to the Model.</p> Source code in <code>framcore/solvers/Solver.py</code> <pre><code>class Solver(Base, ABC):\n    \"\"\"\n    Solver inteface class.\n\n    In FRAM we call energy market models for Solvers. They take a populated Model and configurations from a SolverConfig,\n    and transfers this to the solver software. Then it solves the energy market model, and writes results back to the Model.\n    \"\"\"\n\n    _FILENAME_MODEL = \"model.pickle\"\n    _FILENAME_SOLVER = \"solver.pickle\"\n\n    def solve(self, model: Model) -&gt; None:\n        \"\"\"\n        Inititiate the solve.\n\n        It takes the populated Model and configurations from self.SolverConfig, and transfers this to the solver software.\n        Then it solves the energy market model, and writes results back to the Model.\n\n        At the end of the solve, the Model (now with results) and the Solver object (with configurations) are pickled to the solve folder.\n        - model.pickle can be used to inspect results later.\n        - solver.pickle allows reuse of the same solver configurations (with solve_folder set to None to avoid overwriting).\n        TODO: Could also pickle the Model before solving, to have a record of the input model.\n\n        \"\"\"\n        self._check_type(model, Model)\n\n        config = self.get_config()\n\n        folder = config.get_solve_folder()\n\n        if folder is None:\n            raise ValueError(\"A folder for the Solver has not been set yet. Use Solver.get_config().set_solve_folder(folder)\")\n\n        Path.mkdir(folder, parents=True, exist_ok=True)\n\n        self._solve(folder, model)\n\n        with Path.open(folder / self._FILENAME_MODEL, \"wb\") as f:\n            pickle.dump(model, f)\n\n        c = deepcopy(self)\n        c.get_config().set_solve_folder(None)\n        with Path.open(folder / self._FILENAME_SOLVER, \"wb\") as f:\n            pickle.dump(c, f)\n\n    @abstractmethod\n    def get_config(self) -&gt; SolverConfig:\n        \"\"\"Return the solver's config object.\"\"\"\n        pass\n\n    @abstractmethod\n    def _solve(self, folder: Path, model: Model) -&gt; None:\n        \"\"\"Solve the model inplace. Write to folder. Must be implemented by specific solvers.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/#framcore.solvers.Solver.Solver.get_config","title":"<code>get_config() -&gt; SolverConfig</code>  <code>abstractmethod</code>","text":"<p>Return the solver's config object.</p> Source code in <code>framcore/solvers/Solver.py</code> <pre><code>@abstractmethod\ndef get_config(self) -&gt; SolverConfig:\n    \"\"\"Return the solver's config object.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.solvers.Solver.Solver.solve","title":"<code>solve(model: Model) -&gt; None</code>","text":"<p>Inititiate the solve.</p> <p>It takes the populated Model and configurations from self.SolverConfig, and transfers this to the solver software. Then it solves the energy market model, and writes results back to the Model.</p> <p>At the end of the solve, the Model (now with results) and the Solver object (with configurations) are pickled to the solve folder. - model.pickle can be used to inspect results later. - solver.pickle allows reuse of the same solver configurations (with solve_folder set to None to avoid overwriting). TODO: Could also pickle the Model before solving, to have a record of the input model.</p> Source code in <code>framcore/solvers/Solver.py</code> <pre><code>def solve(self, model: Model) -&gt; None:\n    \"\"\"\n    Inititiate the solve.\n\n    It takes the populated Model and configurations from self.SolverConfig, and transfers this to the solver software.\n    Then it solves the energy market model, and writes results back to the Model.\n\n    At the end of the solve, the Model (now with results) and the Solver object (with configurations) are pickled to the solve folder.\n    - model.pickle can be used to inspect results later.\n    - solver.pickle allows reuse of the same solver configurations (with solve_folder set to None to avoid overwriting).\n    TODO: Could also pickle the Model before solving, to have a record of the input model.\n\n    \"\"\"\n    self._check_type(model, Model)\n\n    config = self.get_config()\n\n    folder = config.get_solve_folder()\n\n    if folder is None:\n        raise ValueError(\"A folder for the Solver has not been set yet. Use Solver.get_config().set_solve_folder(folder)\")\n\n    Path.mkdir(folder, parents=True, exist_ok=True)\n\n    self._solve(folder, model)\n\n    with Path.open(folder / self._FILENAME_MODEL, \"wb\") as f:\n        pickle.dump(model, f)\n\n    c = deepcopy(self)\n    c.get_config().set_solve_folder(None)\n    with Path.open(folder / self._FILENAME_SOLVER, \"wb\") as f:\n        pickle.dump(c, f)\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig","title":"<code>SolverConfig</code>","text":"<p>Definition of SolverConfig interface.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig","title":"<code>SolverConfig</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>SolverConfig inteface class.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>class SolverConfig(Base, ABC):\n    \"\"\"SolverConfig inteface class.\"\"\"\n\n    _SIMULATION_MODE_SERIAL = \"serial\"\n    _SIMULATION_MODE_FORECAST = \"forecast\"\n\n    _DIFF_POLICY_ERROR = \"error\"\n    _DIFF_POLICY_IGNORE = \"ignore\"\n    _DIFF_POLICY_BACKUP = \"backup\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Create internal variables with default values.\"\"\"\n        self._simulation_mode: str | None = None\n        self._diff_policy: str = self._DIFF_POLICY_ERROR\n        self._show_screen_output: bool = False\n        self._currency: str | None = None\n        self._num_cpu_cores: int = 1\n        self._is_float32 = True\n        self._first_weather_year: int | None = None\n        self._num_weather_years: int | None = None\n        self._first_simulation_year: int | None = None\n        self._num_simulation_years: int | None = None\n        self._data_period: TimeIndex | None = None\n        self._commodity_unit_flow_default: str | None = None\n        self._commodity_unit_stock_default: str | None = None\n        self._commodity_unit_flows: dict[str, str] = {}\n        self._commodity_unit_stocks: dict[str, str] = {}\n        self._solve_folder: Path | None = None\n\n    def set_solve_folder(self, folder: Path | str | None) -&gt; None:\n        \"\"\"Set folder where solve related files will be written.\"\"\"\n        self._check_type(folder, (str, Path, type(None)))\n        if isinstance(folder, str):\n            folder = Path(folder)\n        self._solve_folder = folder\n\n    def get_solve_folder(self) -&gt; Path | None:\n        \"\"\"Get folder where solve related files will be written.\"\"\"\n        return self._solve_folder\n\n    def set_commodity_units(\n        self,\n        commodity: str,\n        stock_unit: str,\n        flow_unit: str | None = None,\n        is_default: bool | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the stock and flow units for a commodity.\n\n        Parameters\n        ----------\n        commodity : str\n            The name of the commodity.\n        stock_unit : str\n            The unit for the commodity stock.\n        flow_unit : str or None, optional\n            The unit for the commodity flow, representing the rate of change of the stock unit over time.\n        is_default : bool or None, optional\n            If True, set these units as the default for all commodities.\n\n        Raises\n        ------\n        ValueError\n            If the flow unit is incompatible with the stock unit.\n\n        \"\"\"\n        self._check_type(commodity, str)\n        self._check_type(stock_unit, str)\n        self._check_type(flow_unit, (str, type(None)))\n        self._check_type(is_default, (bool, type(None)))\n        if flow_unit:\n            candidate = f\"{stock_unit}/s\"\n            if not is_convertable(candidate, flow_unit):\n                message = (\n                    f\"Incompatible units for commodity '{commodity}': stock_unit '{stock_unit}' flow_unit '{flow_unit}'\"\n                    \"The flow_unit must represent the rate of change of the stock_unit over time.\"\n                )\n                raise ValueError(message)\n        if is_default:\n            self._warn_if_changed_defaults(stock_unit, flow_unit)\n            self._commodity_unit_stock_default = stock_unit\n            if flow_unit:\n                self._commodity_unit_flow_default = flow_unit\n        else:\n            self._commodity_unit_stocks[commodity] = stock_unit\n            self._commodity_unit_flows[commodity] = flow_unit\n\n    def get_unit_stock(self, commodity: str) -&gt; str:\n        \"\"\"\n        Get the stock unit for a given commodity.\n\n        Parameters\n        ----------\n        commodity : str\n            The name of the commodity.\n\n        Returns\n        -------\n        str\n            The stock unit for the commodity.\n\n        Raises\n        ------\n        ValueError\n            If no stock unit is set for the commodity.\n\n        \"\"\"\n        if commodity not in self._commodity_unit_stocks and not self._commodity_unit_stock_default:\n            message = f\"No stock unit set for '{commodity}'.\"\n            raise ValueError(message)\n        return self._commodity_unit_stocks.get(commodity, self._commodity_unit_stock_default)\n\n    def get_unit_flow(self, commodity: str) -&gt; str | None:\n        \"\"\"\n        Get the flow unit for a given commodity.\n\n        Parameters\n        ----------\n        commodity : str\n            The name of the commodity.\n\n        Returns\n        -------\n        str or None\n            The flow unit for the commodity, or None if not set.\n\n        \"\"\"\n        return self._commodity_unit_flows.get(commodity, self._commodity_unit_flow_default)\n\n    def _warn_if_changed_defaults(self, stock_unit: str, flow_unit: str) -&gt; None:\n        if self._commodity_unit_flow_default and flow_unit != self._commodity_unit_flow_default:\n            message = f\"Replacing flow default from {self._commodity_unit_flow_default} to {flow_unit}. Usually default is only set once.\"\n            self.send_warning_event(message)\n        if self._commodity_unit_stock_default and stock_unit != self._commodity_unit_stock_default:\n            message = f\"Replacing stock default from {self._commodity_unit_stock_default} to {stock_unit}. Usually default is only set once.\"\n            self.send_warning_event(message)\n\n    def get_num_cpu_cores(self) -&gt; int:\n        \"\"\"Return number of cpu cores the Solver can use.\"\"\"\n        return self._num_cpu_cores\n\n    def set_num_cpu_cores(self, n: int) -&gt; int:\n        \"\"\"Set number of cpu cores the Solver can use.\"\"\"\n        self._num_cpu_cores = n\n\n    def set_currency(self, currency: str) -&gt; None:\n        \"\"\"Set currency.\"\"\"\n        self._check_type(currency, str)\n        self._currency = currency\n\n    def get_currency(self) -&gt; str | None:\n        \"\"\"Get currency.\"\"\"\n        return self._currency\n\n    def set_screen_output_on(self) -&gt; None:\n        \"\"\"Print output from Solver to stdout and logfile.\"\"\"\n        self._show_screen_output = True\n\n    def set_screen_output_off(self) -&gt; None:\n        \"\"\"Only print output from Solver to logfile.\"\"\"\n        self._show_screen_output = False\n\n    def show_screen_output(self) -&gt; bool:\n        \"\"\"Return True if screen output is set to be shown.\"\"\"\n        return self._show_screen_output\n\n    def set_diff_policy_error(self) -&gt; None:\n        \"\"\"Error if non-empty diff during solve.\"\"\"\n        self._diff_policy = self._DIFF_POLICY_ERROR\n\n    def set_diff_policy_ignore(self) -&gt; None:\n        \"\"\"Ignore if non-empty diff during solve.\"\"\"\n        self._diff_policy = self._DIFF_POLICY_IGNORE\n\n    def set_diff_policy_backup(self) -&gt; None:\n        \"\"\"Copy existing folder to folder/backup_[timestamp] folder if non-empty diff during solve.\"\"\"\n        self._diff_policy = self._DIFF_POLICY_BACKUP\n\n    def is_diff_policy_error(self) -&gt; bool:\n        \"\"\"Return True if error diff policy.\"\"\"\n        return self._diff_policy == self._DIFF_POLICY_ERROR\n\n    def is_diff_policy_ignore(self) -&gt; bool:\n        \"\"\"Return True if ignore diff policy.\"\"\"\n        return self._diff_policy == self._DIFF_POLICY_IGNORE\n\n    def is_diff_policy_backup(self) -&gt; bool:\n        \"\"\"Return True if backup diff policy.\"\"\"\n        return self._diff_policy == self._DIFF_POLICY_BACKUP\n\n    def set_simulation_mode_serial(self) -&gt; None:\n        \"\"\"Activate serial simulation mode.\"\"\"\n        self._simulation_mode = self._SIMULATION_MODE_SERIAL\n\n    def is_simulation_mode_serial(self) -&gt; bool:\n        \"\"\"Return True if serial simulation mode.\"\"\"\n        return self._simulation_mode == self._SIMULATION_MODE_SERIAL\n\n    def set_data_period(self, period: TimeIndex) -&gt; None:\n        \"\"\"Set period used in level value queries.\"\"\"\n        self._check_type(period, TimeIndex)\n        self._data_period = period\n\n    def get_data_period(self) -&gt; TimeIndex | None:\n        \"\"\"Get period used in level value queries.\"\"\"\n        return self._data_period\n\n    def set_simulation_years(self, first_year: int, num_years: int) -&gt; None:\n        \"\"\"Set subset of scenario years. For serial simulation.\"\"\"\n        self._check_type(first_year, int)\n        self._check_type(num_years, int)\n        self._check_int(first_year, lower_bound=0, upper_bound=None)\n        self._check_int(num_years, lower_bound=1, upper_bound=None)\n        self._first_simulation_year = first_year\n        self._num_simulation_years = num_years\n\n    def get_simulation_years(self) -&gt; tuple[int, int]:\n        \"\"\"\n        Get simulation years (first_year, num_years).\n\n        Return weather years as fallback if serial simulation.\n        \"\"\"\n        if (self._first_simulation_year is None or self._num_simulation_years is None) and self.is_simulation_mode_serial():\n            first_weather_year, num_weather_years = self.get_weather_years()\n            if first_weather_year is not None and num_weather_years is not None:\n                return first_weather_year, num_weather_years\n\n        if self._first_simulation_year is None or self._num_simulation_years is None:\n            message = \"Simulation years not set.\"\n            raise ValueError(message)\n        return (self._first_simulation_year, self._num_simulation_years)\n\n    def set_weather_years(self, first_year: int, num_years: int) -&gt; None:\n        \"\"\"Set weather scenario period used in profiles.\"\"\"\n        self._check_type(first_year, int)\n        self._check_type(num_years, int)\n        self._check_int(first_year, lower_bound=0, upper_bound=None)\n        self._check_int(num_years, lower_bound=1, upper_bound=None)\n        self._first_weather_year = first_year\n        self._num_weather_years = num_years\n\n    def get_weather_years(self) -&gt; tuple[int, int]:\n        \"\"\"Get weather scenario period (first_year, num_years) used in profiles.\"\"\"\n        if self._first_weather_year &lt; 0 or self._num_weather_years &lt; 0:\n            message = \"Scenario years not set.\"\n            raise ValueError(message)\n        return (self._first_weather_year, self._num_weather_years)\n\n    def use_float32(self) -&gt; None:\n        \"\"\"Use single precision floating point numbers in data management.\"\"\"\n        self._is_float32 = True\n\n    def use_float64(self) -&gt; None:\n        \"\"\"Use double precision floating point numbers in data management.\"\"\"\n        self._is_float32 = False\n\n    def is_float32(self) -&gt; bool:\n        \"\"\"Return if single precision in data management, else double precision.\"\"\"\n        return self._is_float32\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Create internal variables with default values.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create internal variables with default values.\"\"\"\n    self._simulation_mode: str | None = None\n    self._diff_policy: str = self._DIFF_POLICY_ERROR\n    self._show_screen_output: bool = False\n    self._currency: str | None = None\n    self._num_cpu_cores: int = 1\n    self._is_float32 = True\n    self._first_weather_year: int | None = None\n    self._num_weather_years: int | None = None\n    self._first_simulation_year: int | None = None\n    self._num_simulation_years: int | None = None\n    self._data_period: TimeIndex | None = None\n    self._commodity_unit_flow_default: str | None = None\n    self._commodity_unit_stock_default: str | None = None\n    self._commodity_unit_flows: dict[str, str] = {}\n    self._commodity_unit_stocks: dict[str, str] = {}\n    self._solve_folder: Path | None = None\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_currency","title":"<code>get_currency() -&gt; str | None</code>","text":"<p>Get currency.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_currency(self) -&gt; str | None:\n    \"\"\"Get currency.\"\"\"\n    return self._currency\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_data_period","title":"<code>get_data_period() -&gt; TimeIndex | None</code>","text":"<p>Get period used in level value queries.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_data_period(self) -&gt; TimeIndex | None:\n    \"\"\"Get period used in level value queries.\"\"\"\n    return self._data_period\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_num_cpu_cores","title":"<code>get_num_cpu_cores() -&gt; int</code>","text":"<p>Return number of cpu cores the Solver can use.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_num_cpu_cores(self) -&gt; int:\n    \"\"\"Return number of cpu cores the Solver can use.\"\"\"\n    return self._num_cpu_cores\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_simulation_years","title":"<code>get_simulation_years() -&gt; tuple[int, int]</code>","text":"<p>Get simulation years (first_year, num_years).</p> <p>Return weather years as fallback if serial simulation.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_simulation_years(self) -&gt; tuple[int, int]:\n    \"\"\"\n    Get simulation years (first_year, num_years).\n\n    Return weather years as fallback if serial simulation.\n    \"\"\"\n    if (self._first_simulation_year is None or self._num_simulation_years is None) and self.is_simulation_mode_serial():\n        first_weather_year, num_weather_years = self.get_weather_years()\n        if first_weather_year is not None and num_weather_years is not None:\n            return first_weather_year, num_weather_years\n\n    if self._first_simulation_year is None or self._num_simulation_years is None:\n        message = \"Simulation years not set.\"\n        raise ValueError(message)\n    return (self._first_simulation_year, self._num_simulation_years)\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_solve_folder","title":"<code>get_solve_folder() -&gt; Path | None</code>","text":"<p>Get folder where solve related files will be written.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_solve_folder(self) -&gt; Path | None:\n    \"\"\"Get folder where solve related files will be written.\"\"\"\n    return self._solve_folder\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_unit_flow","title":"<code>get_unit_flow(commodity: str) -&gt; str | None</code>","text":"<p>Get the flow unit for a given commodity.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_unit_flow--parameters","title":"Parameters","text":"<p>commodity : str     The name of the commodity.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_unit_flow--returns","title":"Returns","text":"<p>str or None     The flow unit for the commodity, or None if not set.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_unit_flow(self, commodity: str) -&gt; str | None:\n    \"\"\"\n    Get the flow unit for a given commodity.\n\n    Parameters\n    ----------\n    commodity : str\n        The name of the commodity.\n\n    Returns\n    -------\n    str or None\n        The flow unit for the commodity, or None if not set.\n\n    \"\"\"\n    return self._commodity_unit_flows.get(commodity, self._commodity_unit_flow_default)\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_unit_stock","title":"<code>get_unit_stock(commodity: str) -&gt; str</code>","text":"<p>Get the stock unit for a given commodity.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_unit_stock--parameters","title":"Parameters","text":"<p>commodity : str     The name of the commodity.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_unit_stock--returns","title":"Returns","text":"<p>str     The stock unit for the commodity.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_unit_stock--raises","title":"Raises","text":"<p>ValueError     If no stock unit is set for the commodity.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_unit_stock(self, commodity: str) -&gt; str:\n    \"\"\"\n    Get the stock unit for a given commodity.\n\n    Parameters\n    ----------\n    commodity : str\n        The name of the commodity.\n\n    Returns\n    -------\n    str\n        The stock unit for the commodity.\n\n    Raises\n    ------\n    ValueError\n        If no stock unit is set for the commodity.\n\n    \"\"\"\n    if commodity not in self._commodity_unit_stocks and not self._commodity_unit_stock_default:\n        message = f\"No stock unit set for '{commodity}'.\"\n        raise ValueError(message)\n    return self._commodity_unit_stocks.get(commodity, self._commodity_unit_stock_default)\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.get_weather_years","title":"<code>get_weather_years() -&gt; tuple[int, int]</code>","text":"<p>Get weather scenario period (first_year, num_years) used in profiles.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def get_weather_years(self) -&gt; tuple[int, int]:\n    \"\"\"Get weather scenario period (first_year, num_years) used in profiles.\"\"\"\n    if self._first_weather_year &lt; 0 or self._num_weather_years &lt; 0:\n        message = \"Scenario years not set.\"\n        raise ValueError(message)\n    return (self._first_weather_year, self._num_weather_years)\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.is_diff_policy_backup","title":"<code>is_diff_policy_backup() -&gt; bool</code>","text":"<p>Return True if backup diff policy.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def is_diff_policy_backup(self) -&gt; bool:\n    \"\"\"Return True if backup diff policy.\"\"\"\n    return self._diff_policy == self._DIFF_POLICY_BACKUP\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.is_diff_policy_error","title":"<code>is_diff_policy_error() -&gt; bool</code>","text":"<p>Return True if error diff policy.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def is_diff_policy_error(self) -&gt; bool:\n    \"\"\"Return True if error diff policy.\"\"\"\n    return self._diff_policy == self._DIFF_POLICY_ERROR\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.is_diff_policy_ignore","title":"<code>is_diff_policy_ignore() -&gt; bool</code>","text":"<p>Return True if ignore diff policy.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def is_diff_policy_ignore(self) -&gt; bool:\n    \"\"\"Return True if ignore diff policy.\"\"\"\n    return self._diff_policy == self._DIFF_POLICY_IGNORE\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.is_float32","title":"<code>is_float32() -&gt; bool</code>","text":"<p>Return if single precision in data management, else double precision.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def is_float32(self) -&gt; bool:\n    \"\"\"Return if single precision in data management, else double precision.\"\"\"\n    return self._is_float32\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.is_simulation_mode_serial","title":"<code>is_simulation_mode_serial() -&gt; bool</code>","text":"<p>Return True if serial simulation mode.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def is_simulation_mode_serial(self) -&gt; bool:\n    \"\"\"Return True if serial simulation mode.\"\"\"\n    return self._simulation_mode == self._SIMULATION_MODE_SERIAL\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_commodity_units","title":"<code>set_commodity_units(commodity: str, stock_unit: str, flow_unit: str | None = None, is_default: bool | None = None) -&gt; None</code>","text":"<p>Set the stock and flow units for a commodity.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_commodity_units--parameters","title":"Parameters","text":"<p>commodity : str     The name of the commodity. stock_unit : str     The unit for the commodity stock. flow_unit : str or None, optional     The unit for the commodity flow, representing the rate of change of the stock unit over time. is_default : bool or None, optional     If True, set these units as the default for all commodities.</p>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_commodity_units--raises","title":"Raises","text":"<p>ValueError     If the flow unit is incompatible with the stock unit.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_commodity_units(\n    self,\n    commodity: str,\n    stock_unit: str,\n    flow_unit: str | None = None,\n    is_default: bool | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the stock and flow units for a commodity.\n\n    Parameters\n    ----------\n    commodity : str\n        The name of the commodity.\n    stock_unit : str\n        The unit for the commodity stock.\n    flow_unit : str or None, optional\n        The unit for the commodity flow, representing the rate of change of the stock unit over time.\n    is_default : bool or None, optional\n        If True, set these units as the default for all commodities.\n\n    Raises\n    ------\n    ValueError\n        If the flow unit is incompatible with the stock unit.\n\n    \"\"\"\n    self._check_type(commodity, str)\n    self._check_type(stock_unit, str)\n    self._check_type(flow_unit, (str, type(None)))\n    self._check_type(is_default, (bool, type(None)))\n    if flow_unit:\n        candidate = f\"{stock_unit}/s\"\n        if not is_convertable(candidate, flow_unit):\n            message = (\n                f\"Incompatible units for commodity '{commodity}': stock_unit '{stock_unit}' flow_unit '{flow_unit}'\"\n                \"The flow_unit must represent the rate of change of the stock_unit over time.\"\n            )\n            raise ValueError(message)\n    if is_default:\n        self._warn_if_changed_defaults(stock_unit, flow_unit)\n        self._commodity_unit_stock_default = stock_unit\n        if flow_unit:\n            self._commodity_unit_flow_default = flow_unit\n    else:\n        self._commodity_unit_stocks[commodity] = stock_unit\n        self._commodity_unit_flows[commodity] = flow_unit\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_currency","title":"<code>set_currency(currency: str) -&gt; None</code>","text":"<p>Set currency.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_currency(self, currency: str) -&gt; None:\n    \"\"\"Set currency.\"\"\"\n    self._check_type(currency, str)\n    self._currency = currency\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_data_period","title":"<code>set_data_period(period: TimeIndex) -&gt; None</code>","text":"<p>Set period used in level value queries.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_data_period(self, period: TimeIndex) -&gt; None:\n    \"\"\"Set period used in level value queries.\"\"\"\n    self._check_type(period, TimeIndex)\n    self._data_period = period\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_diff_policy_backup","title":"<code>set_diff_policy_backup() -&gt; None</code>","text":"<p>Copy existing folder to folder/backup_[timestamp] folder if non-empty diff during solve.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_diff_policy_backup(self) -&gt; None:\n    \"\"\"Copy existing folder to folder/backup_[timestamp] folder if non-empty diff during solve.\"\"\"\n    self._diff_policy = self._DIFF_POLICY_BACKUP\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_diff_policy_error","title":"<code>set_diff_policy_error() -&gt; None</code>","text":"<p>Error if non-empty diff during solve.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_diff_policy_error(self) -&gt; None:\n    \"\"\"Error if non-empty diff during solve.\"\"\"\n    self._diff_policy = self._DIFF_POLICY_ERROR\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_diff_policy_ignore","title":"<code>set_diff_policy_ignore() -&gt; None</code>","text":"<p>Ignore if non-empty diff during solve.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_diff_policy_ignore(self) -&gt; None:\n    \"\"\"Ignore if non-empty diff during solve.\"\"\"\n    self._diff_policy = self._DIFF_POLICY_IGNORE\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_num_cpu_cores","title":"<code>set_num_cpu_cores(n: int) -&gt; int</code>","text":"<p>Set number of cpu cores the Solver can use.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_num_cpu_cores(self, n: int) -&gt; int:\n    \"\"\"Set number of cpu cores the Solver can use.\"\"\"\n    self._num_cpu_cores = n\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_screen_output_off","title":"<code>set_screen_output_off() -&gt; None</code>","text":"<p>Only print output from Solver to logfile.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_screen_output_off(self) -&gt; None:\n    \"\"\"Only print output from Solver to logfile.\"\"\"\n    self._show_screen_output = False\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_screen_output_on","title":"<code>set_screen_output_on() -&gt; None</code>","text":"<p>Print output from Solver to stdout and logfile.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_screen_output_on(self) -&gt; None:\n    \"\"\"Print output from Solver to stdout and logfile.\"\"\"\n    self._show_screen_output = True\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_simulation_mode_serial","title":"<code>set_simulation_mode_serial() -&gt; None</code>","text":"<p>Activate serial simulation mode.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_simulation_mode_serial(self) -&gt; None:\n    \"\"\"Activate serial simulation mode.\"\"\"\n    self._simulation_mode = self._SIMULATION_MODE_SERIAL\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_simulation_years","title":"<code>set_simulation_years(first_year: int, num_years: int) -&gt; None</code>","text":"<p>Set subset of scenario years. For serial simulation.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_simulation_years(self, first_year: int, num_years: int) -&gt; None:\n    \"\"\"Set subset of scenario years. For serial simulation.\"\"\"\n    self._check_type(first_year, int)\n    self._check_type(num_years, int)\n    self._check_int(first_year, lower_bound=0, upper_bound=None)\n    self._check_int(num_years, lower_bound=1, upper_bound=None)\n    self._first_simulation_year = first_year\n    self._num_simulation_years = num_years\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_solve_folder","title":"<code>set_solve_folder(folder: Path | str | None) -&gt; None</code>","text":"<p>Set folder where solve related files will be written.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_solve_folder(self, folder: Path | str | None) -&gt; None:\n    \"\"\"Set folder where solve related files will be written.\"\"\"\n    self._check_type(folder, (str, Path, type(None)))\n    if isinstance(folder, str):\n        folder = Path(folder)\n    self._solve_folder = folder\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.set_weather_years","title":"<code>set_weather_years(first_year: int, num_years: int) -&gt; None</code>","text":"<p>Set weather scenario period used in profiles.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def set_weather_years(self, first_year: int, num_years: int) -&gt; None:\n    \"\"\"Set weather scenario period used in profiles.\"\"\"\n    self._check_type(first_year, int)\n    self._check_type(num_years, int)\n    self._check_int(first_year, lower_bound=0, upper_bound=None)\n    self._check_int(num_years, lower_bound=1, upper_bound=None)\n    self._first_weather_year = first_year\n    self._num_weather_years = num_years\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.show_screen_output","title":"<code>show_screen_output() -&gt; bool</code>","text":"<p>Return True if screen output is set to be shown.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def show_screen_output(self) -&gt; bool:\n    \"\"\"Return True if screen output is set to be shown.\"\"\"\n    return self._show_screen_output\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.use_float32","title":"<code>use_float32() -&gt; None</code>","text":"<p>Use single precision floating point numbers in data management.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def use_float32(self) -&gt; None:\n    \"\"\"Use single precision floating point numbers in data management.\"\"\"\n    self._is_float32 = True\n</code></pre>"},{"location":"reference/#framcore.solvers.SolverConfig.SolverConfig.use_float64","title":"<code>use_float64() -&gt; None</code>","text":"<p>Use double precision floating point numbers in data management.</p> Source code in <code>framcore/solvers/SolverConfig.py</code> <pre><code>def use_float64(self) -&gt; None:\n    \"\"\"Use double precision floating point numbers in data management.\"\"\"\n    self._is_float32 = False\n</code></pre>"},{"location":"reference/#framcore.timeindexes","title":"<code>timeindexes</code>","text":"<p>FRAM time indexes package provides functionality for handling time-related data.</p>"},{"location":"reference/#framcore.timeindexes.AverageYearRange","title":"<code>AverageYearRange</code>","text":""},{"location":"reference/#framcore.timeindexes.AverageYearRange.AverageYearRange","title":"<code>AverageYearRange</code>","text":"<p>               Bases: <code>SinglePeriodTimeIndex</code></p> <p>AverageYearRange represents a period over a range of years. No extrapolation and represents full iso calendar years.</p> Source code in <code>framcore/timeindexes/AverageYearRange.py</code> <pre><code>class AverageYearRange(SinglePeriodTimeIndex):\n    \"\"\"AverageYearRange represents a period over a range of years. No extrapolation and represents full iso calendar years.\"\"\"\n\n    def __init__(self, start_year: int, num_years: int) -&gt; None:\n        \"\"\"\n        Initialize AverageYearRange with a year range. No extrapolation and represents full iso calendar years.\n\n        Args:\n            start_year (int): First year in the range.\n            num_years (int): Number of years in the range.\n\n        \"\"\"\n        start_time = datetime.fromisocalendar(start_year, 1, 1)\n        end_time = datetime.fromisocalendar(start_year + num_years, 1, 1)\n        period_duration = end_time - start_time\n        super().__init__(\n            start_time=start_time,\n            period_duration=period_duration,\n            is_52_week_years=False,\n            extrapolate_first_point=False,\n            extrapolate_last_point=False,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.AverageYearRange.AverageYearRange.__init__","title":"<code>__init__(start_year: int, num_years: int) -&gt; None</code>","text":"<p>Initialize AverageYearRange with a year range. No extrapolation and represents full iso calendar years.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <code>int</code> <p>First year in the range.</p> required <code>num_years</code> <code>int</code> <p>Number of years in the range.</p> required Source code in <code>framcore/timeindexes/AverageYearRange.py</code> <pre><code>def __init__(self, start_year: int, num_years: int) -&gt; None:\n    \"\"\"\n    Initialize AverageYearRange with a year range. No extrapolation and represents full iso calendar years.\n\n    Args:\n        start_year (int): First year in the range.\n        num_years (int): Number of years in the range.\n\n    \"\"\"\n    start_time = datetime.fromisocalendar(start_year, 1, 1)\n    end_time = datetime.fromisocalendar(start_year + num_years, 1, 1)\n    period_duration = end_time - start_time\n    super().__init__(\n        start_time=start_time,\n        period_duration=period_duration,\n        is_52_week_years=False,\n        extrapolate_first_point=False,\n        extrapolate_last_point=False,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ConstantTimeIndex","title":"<code>ConstantTimeIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.ConstantTimeIndex.ConstantTimeIndex","title":"<code>ConstantTimeIndex</code>","text":"<p>               Bases: <code>SinglePeriodTimeIndex</code></p> <p>ConstantTimeIndex that is constant over time. For use in ConstantTimeVector.</p> <p>Represents a period of 52 weeks starting from the iso calendar week 1 of 1985. Extrapolates both first and last point.</p> Source code in <code>framcore/timeindexes/ConstantTimeIndex.py</code> <pre><code>class ConstantTimeIndex(SinglePeriodTimeIndex):\n    \"\"\"\n    ConstantTimeIndex that is constant over time. For use in ConstantTimeVector.\n\n    Represents a period of 52 weeks starting from the iso calendar week 1 of 1985. Extrapolates both first and last point.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize ConstantTimeIndex.\"\"\"\n        super().__init__(\n            start_time=datetime.fromisocalendar(1985, 1, 1),\n            period_duration=timedelta(weeks=52),\n            is_52_week_years=True,\n            extrapolate_first_point=True,\n            extrapolate_last_point=True,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ConstantTimeIndex.ConstantTimeIndex.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize ConstantTimeIndex.</p> Source code in <code>framcore/timeindexes/ConstantTimeIndex.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize ConstantTimeIndex.\"\"\"\n    super().__init__(\n        start_time=datetime.fromisocalendar(1985, 1, 1),\n        period_duration=timedelta(weeks=52),\n        is_52_week_years=True,\n        extrapolate_first_point=True,\n        extrapolate_last_point=True,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.DailyIndex","title":"<code>DailyIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.DailyIndex.DailyIndex","title":"<code>DailyIndex</code>","text":"<p>               Bases: <code>ProfileTimeIndex</code></p> <p>ProfileTimeIndex with one or more whole years with daily resolution. Either years with 52 weeks or full iso calendar years.</p> <p>No extrapolation inherited from ProfileTimeIndex.</p> Source code in <code>framcore/timeindexes/DailyIndex.py</code> <pre><code>class DailyIndex(ProfileTimeIndex):\n    \"\"\"\n    ProfileTimeIndex with one or more whole years with daily resolution. Either years with 52 weeks or full iso calendar years.\n\n    No extrapolation inherited from ProfileTimeIndex.\n    \"\"\"\n\n    def __init__(\n        self,\n        start_year: int,\n        num_years: int,\n        is_52_week_years: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize DailyIndex over a number of years. Either years with 52 weeks or full iso calendar years.\n\n        Args:\n            start_year (int): First year in the index.\n            num_years (int): Number of years in the index.\n            is_52_week_years (bool, optional): Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.\n\n        \"\"\"\n        super().__init__(\n            start_year=start_year,\n            num_years=num_years,\n            period_duration=timedelta(days=1),\n            is_52_week_years=is_52_week_years,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.DailyIndex.DailyIndex.__init__","title":"<code>__init__(start_year: int, num_years: int, is_52_week_years: bool = True) -&gt; None</code>","text":"<p>Initialize DailyIndex over a number of years. Either years with 52 weeks or full iso calendar years.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <code>int</code> <p>First year in the index.</p> required <code>num_years</code> <code>int</code> <p>Number of years in the index.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.</p> <code>True</code> Source code in <code>framcore/timeindexes/DailyIndex.py</code> <pre><code>def __init__(\n    self,\n    start_year: int,\n    num_years: int,\n    is_52_week_years: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize DailyIndex over a number of years. Either years with 52 weeks or full iso calendar years.\n\n    Args:\n        start_year (int): First year in the index.\n        num_years (int): Number of years in the index.\n        is_52_week_years (bool, optional): Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.\n\n    \"\"\"\n    super().__init__(\n        start_year=start_year,\n        num_years=num_years,\n        period_duration=timedelta(days=1),\n        is_52_week_years=is_52_week_years,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex","title":"<code>FixedFrequencyTimeIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex","title":"<code>FixedFrequencyTimeIndex</code>","text":"<p>               Bases: <code>TimeIndex</code></p> <p>TimeIndex with fixed frequency.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>class FixedFrequencyTimeIndex(TimeIndex):\n    \"\"\"TimeIndex with fixed frequency.\"\"\"\n\n    def __init__(\n        self,\n        start_time: datetime,\n        period_duration: timedelta,\n        num_periods: int,\n        is_52_week_years: bool,\n        extrapolate_first_point: bool,\n        extrapolate_last_point: bool,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a FixedFrequencyTimeIndex.\n\n        Args:\n            start_time (datetime): The starting datetime of the time index.\n            period_duration (timedelta): The duration of each period.\n            num_periods (int): The number of periods in the time index. Must be greater than 0.\n            is_52_week_years (bool): Whether to use 52-week years.\n            extrapolate_first_point (bool): Whether to allow extrapolation of the first point.\n            extrapolate_last_point (bool): Whether to allow extrapolation of the last point.\n\n        \"\"\"\n        if num_periods &lt;= 0:\n            msg = f\"num_periods must be a positive integer. Got {num_periods}.\"\n            raise ValueError(msg)\n        if period_duration &lt; timedelta(seconds=1):\n            msg = f\"period_duration must be at least one second. Got {period_duration}.\"\n            raise ValueError(msg)\n        if not period_duration.total_seconds().is_integer():\n            msg = f\"period_duration must be a whole number of seconds, got {period_duration.total_seconds()} s\"\n            raise ValueError(msg)\n        if is_52_week_years and start_time.isocalendar().week == 53:  # noqa: PLR2004\n            raise ValueError(\"Week of start_time must not be 53 when is_52_week_years is True.\")\n        self._check_type(num_periods, int)\n        self._start_time = start_time\n        self._period_duration = period_duration\n        self._num_periods = num_periods\n        self._is_52_week_years = is_52_week_years\n        self._extrapolate_first_point = extrapolate_first_point\n        self._extrapolate_last_point = extrapolate_last_point\n\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Check if equal to other.\"\"\"\n        if not isinstance(other, FixedFrequencyTimeIndex):\n            return False\n        return (\n            self._start_time == other._start_time\n            and self._period_duration == other._period_duration\n            and self._num_periods == other._num_periods\n            and self._is_52_week_years == other._is_52_week_years\n            and self._extrapolate_first_point == other._extrapolate_first_point\n            and self._extrapolate_last_point == other._extrapolate_last_point\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash value for the FixedFrequencyTimeIndex.\"\"\"\n        return hash(\n            (\n                self._start_time,\n                self._period_duration,\n                self._num_periods,\n                self._is_52_week_years,\n                self._extrapolate_first_point,\n                self._extrapolate_last_point,\n            ),\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the FixedFrequencyTimeIndex.\"\"\"\n        return (\n            f\"{type(self).__name__}(\"\n            f\"start_time={self._start_time}, \"\n            f\"period_duration={self._period_duration}, \"\n            f\"num_periods={self._num_periods}, \"\n            f\"is_52_week_years={self._is_52_week_years}, \"\n            f\"extrapolate_first_point={self._extrapolate_first_point}, \"\n            f\"extrapolate_last_point={self._extrapolate_last_point})\"\n        )\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the fingerprint.\"\"\"\n        return self.get_fingerprint_default()\n\n    def get_timezone(self) -&gt; tzinfo | None:\n        \"\"\"Get the timezone.\"\"\"\n        return self._start_time.tzinfo\n\n    def get_start_time(self) -&gt; datetime:\n        \"\"\"Get the start time.\"\"\"\n        return self._start_time\n\n    def get_period_duration(self) -&gt; timedelta:\n        \"\"\"Get the period duration.\"\"\"\n        return self._period_duration\n\n    def get_num_periods(self) -&gt; int:\n        \"\"\"Get the number of points.\"\"\"\n        return self._num_periods\n\n    def is_constant(self) -&gt; bool:\n        \"\"\"\n        Return True if the time index is constant (single period and both extrapolation flags are True).\n\n        Returns\n        -------\n        bool\n            True if the time index is constant, False otherwise.\n\n        \"\"\"\n        return self._num_periods == 1 and self._extrapolate_first_point == self._extrapolate_last_point is True\n\n    def is_whole_years(self) -&gt; bool:\n        \"\"\"\n        Return True if index covers one or more full years.\n\n        The start_time must be the first week and weekday of a year. For real ISO time,\n        the stop_time must also be the first week and weekday of a year. For 52-week years,\n        the total duration must be an integer number of 52-week years.\n        \"\"\"\n        start_time = self.get_start_time()\n        start_year, start_week, start_weekday = start_time.isocalendar()\n        if not start_week == start_weekday == 1:\n            return False\n\n        if not self.is_52_week_years():\n            period_duration = self.get_period_duration()\n            num_periods = self.get_num_periods()\n            stop_time = start_time + num_periods * period_duration\n            stop_year, stop_week, stop_weekday = stop_time.isocalendar()\n            if stop_year &lt; start_year:\n                msg = f\"Stop year must be after start year. Current stop year: {stop_year} and start year: {start_year}\"\n                raise ValueError(msg)\n            return stop_week == stop_weekday == 1\n\n        period_duration = self.get_period_duration()\n        num_periods = self.get_num_periods()\n        seconds_52_week_year = 52 * 168 * 3600\n        num_years = (period_duration * num_periods).total_seconds() / seconds_52_week_year\n        return num_years.is_integer()\n\n    def get_reference_period(self) -&gt; ReferencePeriod | None:\n        \"\"\"Get the reference period (only if is_whole_years() is True).\"\"\"\n        if self.is_whole_years():\n            start_year = self.get_start_time().isocalendar().year\n            if self._is_52_week_years:\n                num_years = (self.get_num_periods() * self.get_period_duration()) // timedelta(weeks=52)\n            else:\n                stop_year = self.get_stop_time().isocalendar().year\n                num_years = stop_year - start_year\n            return ReferencePeriod(start_year=start_year, num_years=num_years)\n        return None\n\n    def is_52_week_years(self) -&gt; bool:\n        \"\"\"Return True if 52-week years and False if real ISO time.\"\"\"\n        return self._is_52_week_years\n\n    def is_one_year(self) -&gt; bool:\n        \"\"\"Return True if exactly one whole year.\"\"\"\n        start_time = self.get_start_time()\n        start_year, start_week, start_weekday = start_time.isocalendar()\n        if not start_week == start_weekday == 1:\n            return False\n\n        if not self.is_52_week_years():\n            period_duration = self.get_period_duration()\n            num_periods = self.get_num_periods()\n            stop_time = start_time + num_periods * period_duration\n            stop_year, stop_week, stop_weekday = stop_time.isocalendar()\n            if not stop_week == stop_weekday == 1:\n                return False\n            return start_year + 1 == stop_year\n\n        period_duration = self.get_period_duration()\n        num_periods = self.get_num_periods()\n        seconds_52_week_year = 52 * 168 * 3600\n        num_years = (period_duration * num_periods).total_seconds() / seconds_52_week_year\n        return num_years == 1.0\n\n    def extrapolate_first_point(self) -&gt; bool:\n        \"\"\"Return True if first value can be extrapolated backwards to fill missing values.\"\"\"\n        return self._extrapolate_first_point\n\n    def extrapolate_last_point(self) -&gt; bool:\n        \"\"\"Return True if last value can be extrapolated forward to fill missing values.\"\"\"\n        return self._extrapolate_last_point\n\n    def get_period_average(self, vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float:\n        \"\"\"Get the average over the period from the vector.\"\"\"\n        self._check_type(vector, np.ndarray)\n        self._check_type(start_time, datetime)\n        self._check_type(duration, timedelta)\n        self._check_type(is_52_week_years, bool)\n\n        if vector.shape != (self.get_num_periods(),):\n            msg = f\"Vector shape {vector.shape} does not match number of periods {self.get_num_periods()} of timeindex ({self}).\"\n            raise ValueError(msg)\n        target_timeindex = FixedFrequencyTimeIndex(\n            start_time=start_time,\n            period_duration=duration,\n            num_periods=1,\n            is_52_week_years=is_52_week_years,\n            extrapolate_first_point=self.extrapolate_first_point(),\n            extrapolate_last_point=self.extrapolate_last_point(),\n        )\n        target_vector = np.zeros(1, dtype=vector.dtype)\n        self.write_into_fixed_frequency(\n            target_vector=target_vector,\n            target_timeindex=target_timeindex,\n            input_vector=vector,\n        )\n        return target_vector[0]\n\n    def write_into_fixed_frequency(\n        self,\n        target_vector: NDArray,\n        target_timeindex: FixedFrequencyTimeIndex,\n        input_vector: NDArray,\n    ) -&gt; None:\n        \"\"\"\n        Write the given input_vector into the target_vector according to the target_timeindex, applying necessary transformations.\n\n        Parameters\n        ----------\n        target_vector : NDArray\n            The array where the input_vector will be written to, modified in place.\n        target_timeindex : FixedFrequencyTimeIndex\n            The time index defining the fixed frequency structure for writing the input_vector into the target_vector.\n        input_vector : NDArray\n            The array containing the data to be written into the target_vector.\n\n        Notes\n        -----\n        - If the object is constant (as determined by `self.is_constant()`), the input_vector is expected to have a single value,\n          which will be used to fill the entire target_vector.\n        - Otherwise, the method delegates the operation to `_write_into_fixed_frequency_recursive` for handling more complex cases.\n\n        \"\"\"\n        if self.is_constant():\n            assert input_vector.size == 1\n            target_vector.fill(input_vector[0])\n        else:\n            self._write_into_fixed_frequency_recursive(target_vector, target_timeindex, input_vector)\n\n    def _write_into_fixed_frequency_recursive(  # noqa: C901\n        self,\n        target_vector: NDArray,\n        target_timeindex: FixedFrequencyTimeIndex,\n        input_vector: NDArray,\n        _depth: int = 0,  # only for recursion depth tracking\n    ) -&gt; None:\n        \"\"\"\n        Recursively write the input_vector into the target_vector according to the target_timeindex, applying necessary transformations.\n\n        Parameters\n        ----------\n        target_vector : NDArray\n            The array where the input_vector will be written to, modified in place.\n        target_timeindex : FixedFrequencyTimeIndex\n            The time index defining the fixed frequency structure for writing the input_vector into the target_vector.\n        input_vector : NDArray\n            The array containing the data to be written into the target_vector.\n\n        \"\"\"\n        if _depth &gt; 100:  # noqa: PLR2004\n            raise RecursionError(\"Maximum recursion depth (100) exceeded in _write_into_fixed_frequency_recursive.\")\n\n        if self == target_timeindex:\n            np.copyto(target_vector, input_vector)\n            return\n\n        transformed_timeindex = None\n\n        # Check differences between self and target_timeindex and apply transformations recursively\n        if not target_timeindex._is_compatible_resolution(self):\n            transformed_timeindex, transformed_vector = self._transform_to_compatible_resolution(input_vector, target_timeindex)\n\n        elif target_timeindex.is_52_week_years() and not self.is_52_week_years():\n            transformed_timeindex, transformed_vector = self._convert_to_52_week_years(input_vector=input_vector)\n\n        elif not target_timeindex.is_52_week_years() and self.is_52_week_years():\n            transformed_timeindex, transformed_vector = self._convert_to_iso_time(input_vector=input_vector)\n\n        elif not self._is_same_period(target_timeindex):\n            if self.is_one_year():\n                transformed_timeindex, transformed_vector = self._repeat_oneyear(input_vector, target_timeindex)\n            else:\n                transformed_timeindex, transformed_vector = self._adjust_period(input_vector, target_timeindex)\n\n        elif not self.is_same_resolution(target_timeindex):\n            if target_timeindex.get_period_duration() &lt; self._period_duration:\n                v_ops.disaggregate(\n                    input_vector=input_vector,\n                    output_vector=target_vector,\n                    is_disaggfunc_repeat=True,\n                )\n            else:\n                v_ops.aggregate(\n                    input_vector=input_vector,\n                    output_vector=target_vector,\n                    is_aggfunc_sum=False,\n                )\n\n        # Recursively write the transformed vector into the target vector\n        if transformed_timeindex is not None:\n            transformed_timeindex._write_into_fixed_frequency_recursive(  # noqa: SLF001\n                target_vector=target_vector,\n                target_timeindex=target_timeindex,\n                input_vector=transformed_vector,\n                _depth=_depth + 1,\n            )\n\n    def _convert_to_iso_time(self, input_vector: NDArray) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        \"\"\"\n        Convert the input vector to ISO time format.\n\n        Parameters\n        ----------\n        input_vector : NDArray\n            The input vector to be transformed into ISO time format.\n\n        Returns\n        -------\n        tuple[FixedFrequencyTimeIndex, NDArray]\n            A tuple containing the transformed FixedFrequencyTimeIndex and the transformed input vector.\n\n        \"\"\"\n        transformed_vector = v_ops.convert_to_isotime(input_vector=input_vector, startdate=self._start_time, period_duration=self._period_duration)\n\n        transformed_timeindex = self.copy_with(\n            start_time=self._start_time,\n            num_periods=transformed_vector.size,\n            is_52_week_years=False,\n        )\n\n        return transformed_timeindex, transformed_vector\n\n    def _convert_to_52_week_years(self, input_vector: NDArray) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        \"\"\"\n        Convert the input vector to a 52-week year format.\n\n        This method adjusts the start time of the source index (if needed) and transforms the input vector to match the 52-week year format.\n\n        Parameters\n        ----------\n        input_vector : NDArray\n            The input vector to be transformed.\n        startdate : datetime\n            The start date of the input vector.\n        period_duration : timedelta\n            The duration of each period in the input vector.\n\n        Returns\n        -------\n            tuple[FixedFrequencyTimeIndex, NDArray]\n                A tuple containing the transformed FixedFrequencyTimeIndex and the transformed input vector.\n\n        \"\"\"\n        adjusted_start_time, transformed_vector = v_ops.convert_to_modeltime(\n            input_vector=input_vector,\n            startdate=self._start_time,\n            period_duration=self._period_duration,\n        )\n        transformed_timeindex = self.copy_with(\n            start_time=adjusted_start_time,\n            num_periods=transformed_vector.size,\n            is_52_week_years=True,\n        )\n\n        return transformed_timeindex, transformed_vector\n\n    def _is_compatible_resolution(self, other: FixedFrequencyTimeIndex) -&gt; bool:\n        \"\"\"Check if the period duration and start time are compatible with another FixedFrequencyTimeIndex.\"\"\"\n        return self._is_compatible_period(other) and self._is_compatible_starttime(other)\n\n    def _is_compatible_period(self, other: FixedFrequencyTimeIndex) -&gt; bool:\n        modulus = self._period_duration.total_seconds() % other.get_period_duration().total_seconds()\n        return modulus == 0\n\n    def _is_compatible_starttime(self, other: FixedFrequencyTimeIndex) -&gt; bool:\n        delta = abs(self._start_time - other.get_start_time()).total_seconds()\n        modulus = delta % other._period_duration.total_seconds()\n        return modulus == 0\n\n    def _transform_to_compatible_resolution(\n        self,\n        input_vector: NDArray,\n        target_timeindex: FixedFrequencyTimeIndex,\n    ) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        \"\"\"\n        Transform the input vector and source time index to match the target time index resolution.\n\n        Parameters\n        ----------\n        input_vector : NDArray\n            The input vector to be transformed.\n        target_timeindex : FixedFrequencyTimeIndex\n            The target time index to match the resolution of.\n\n        Returns\n        -------\n        tuple[FixedFrequencyTimeIndex, NDArray]\n            A tuple containing the transformed FixedFrequencyTimeIndex and the transformed input vector.\n\n        \"\"\"\n        new_period_duration = timedelta(\n            seconds=math.gcd(\n                int(self._period_duration.total_seconds()),\n                int(target_timeindex.get_period_duration().total_seconds()),\n                int((self._start_time - target_timeindex.get_start_time()).total_seconds()),\n            ),\n        )\n\n        transformed_timeindex = self.copy_with(\n            period_duration=new_period_duration,\n            num_periods=int(self._period_duration.total_seconds() // new_period_duration.total_seconds()) * self._num_periods,\n        )\n\n        transformed_vector = np.zeros(transformed_timeindex.get_num_periods(), dtype=input_vector.dtype)\n        v_ops.disaggregate(\n            input_vector=input_vector,\n            output_vector=transformed_vector,\n            is_disaggfunc_repeat=True,\n        )\n\n        return transformed_timeindex, transformed_vector\n\n    def _is_same_period(self, other: FixedFrequencyTimeIndex) -&gt; bool:\n        \"\"\"Check if the start and stop times are the same.\"\"\"\n        return self._start_time == other.get_start_time() and self.get_stop_time() == other.get_stop_time()\n\n    def is_same_resolution(self, other: FixedFrequencyTimeIndex) -&gt; bool:\n        \"\"\"Check if the period duration is the same.\"\"\"\n        return self._period_duration == other.get_period_duration()\n\n    def get_stop_time(self) -&gt; datetime:\n        \"\"\"Get the stop time of the TimeIndex.\"\"\"\n        if not self._is_52_week_years:\n            return self._start_time + self._period_duration * self._num_periods\n\n        return v_ops.calculate_52_week_years_stop_time(\n            start_time=self._start_time,\n            period_duration=self._period_duration,\n            num_periods=self._num_periods,\n        )\n\n    def slice(\n        self,\n        input_vector: NDArray,\n        start_year: int,\n        num_years: int,\n        target_start_year: int,\n        target_num_years: int,\n    ) -&gt; NDArray:\n        \"\"\"Periodize the input vector to match the target timeindex.\"\"\"\n        if self._is_52_week_years:\n            return v_ops.periodize_modeltime(input_vector, start_year, num_years, target_start_year, target_num_years)\n        return v_ops.periodize_isotime(input_vector, start_year, num_years, target_start_year, target_num_years)\n\n    def _slice_start(self, input_vector: NDArray, target_index: FixedFrequencyTimeIndex) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        \"\"\"\n        Slice the input vector to match the target time index.\n\n        This method handles slicing the input vector to fit the target time index,\n        ensuring that the start time aligns correctly.\n        \"\"\"\n        num_periods_to_slice = self._periods_between(\n            self._start_time,\n            target_index.get_start_time(),\n            self._period_duration,\n            self._is_52_week_years,\n        )\n        transformed_timeindex = self.copy_with(\n            start_time=target_index.get_start_time(),\n            num_periods=self._num_periods - num_periods_to_slice,\n        )\n        transformed_vector = input_vector[num_periods_to_slice:]\n\n        return transformed_timeindex, transformed_vector\n\n    def _slice_end(self, input_vector: NDArray, target_index: FixedFrequencyTimeIndex) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        \"\"\"\n        Slice the input vector to match the target time index.\n\n        This method handles slicing the input vector to fit the target time index,\n        ensuring that the stop time aligns correctly.\n        \"\"\"\n        num_periods_to_slice = self._periods_between(\n            self.get_stop_time(),\n            target_index.get_stop_time(),\n            self._period_duration,\n            self._is_52_week_years,\n        )\n        transformed_timeindex = self.copy_with(num_periods=self._num_periods - num_periods_to_slice)\n        transformed_vector = input_vector[:-num_periods_to_slice]\n\n        return transformed_timeindex, transformed_vector\n\n    def total_duration(self) -&gt; timedelta:\n        \"\"\"Get the duration of the TimeIndex.\"\"\"\n        return self._period_duration * self._num_periods\n\n    def _extend_start(\n        self,\n        input_vector: NDArray,\n        target_timeindex: FixedFrequencyTimeIndex,\n    ) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        \"\"\"\n        Extend the start of the input vector to match the target time index.\n\n        This method handles extrapolation of the first point if allowed.\n        \"\"\"\n        if not self._extrapolate_first_point:\n            raise ValueError(\"Cannot extend start without extrapolation.\")\n\n        num_periods_to_extend = self._periods_between(\n            self._start_time,\n            target_timeindex.get_start_time(),\n            self._period_duration,\n            self._is_52_week_years,\n        )\n        extended_vector = np.concatenate((np.full(num_periods_to_extend, input_vector[0]), input_vector))\n\n        transformed_timeindex = self.copy_with(\n            start_time=target_timeindex.get_start_time(),\n            num_periods=self._num_periods + num_periods_to_extend,\n        )\n\n        return transformed_timeindex, extended_vector\n\n    def _extend_end(\n        self,\n        input_vector: NDArray,\n        target_timeindex: FixedFrequencyTimeIndex,\n    ) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        if not self._extrapolate_last_point:\n            raise ValueError(\"Cannot extend end without extrapolation.\")\n\n        num_periods_to_extend = self._periods_between(\n            self.get_stop_time(),\n            target_timeindex.get_stop_time(),\n            self._period_duration,\n            self._is_52_week_years,\n        )\n        extended_vector = np.concatenate((input_vector, np.full(num_periods_to_extend, input_vector[-1])))\n        target_timeindex = self.copy_with(num_periods=self._num_periods + num_periods_to_extend)\n\n        return target_timeindex, extended_vector\n\n    def _repeat_oneyear(self, input_vector: NDArray, target_timeindex: FixedFrequencyTimeIndex) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        \"\"\"\n        Repeat the one-year time index.\n\n        This method creates a new time vector by repeating the input vector over the time period defined by the target time index.\n\n        Parameters\n        ----------\n        input_vector : NDArray\n            The input vector to be repeated.\n        target_timeindex : FixedFrequencyTimeIndex\n            The target time index defining the start and duration of the target period.\n\n        Returns\n        -------\n        tuple[FixedFrequencyTimeIndex, NDArray]\n            A tuple containing the new FixedFrequencyTimeIndex and the transformed input vector.\n\n        \"\"\"\n        if self.is_52_week_years():\n            transformed_vector = self._repeat_one_year_modeltime(\n                input_vector=input_vector,\n                target_timeindex=target_timeindex,\n            )\n        else:\n            transformed_vector = self._repeat_one_year_isotime(\n                input_vector=input_vector,\n                target_timeindex=target_timeindex,\n            )\n        transformed_timeindex = self.copy_with(\n            start_time=target_timeindex.get_start_time(),\n            num_periods=transformed_vector.size,\n        )\n\n        return transformed_timeindex, transformed_vector\n\n    def _repeat_one_year_isotime(self, input_vector: NDArray, target_timeindex: FixedFrequencyTimeIndex) -&gt; NDArray:\n        \"\"\"\n        Repeat the one-year ISO time index.\n\n        This method creates a new time vector by repeating the input vector over the time period defined by the target time index.\n\n        Parameters\n        ----------\n        input_vector : NDArray\n            The input vector to be repeated.\n        target_timeindex : FixedFrequencyTimeIndex\n            The target time index defining the start and stop times for the repetition.\n\n        Returns\n        -------\n        NDArray\n            The repeated vector that matches the target time index.\n\n        \"\"\"\n        return v_ops.repeat_oneyear_isotime(\n            input_vector=input_vector,\n            input_start_date=self._start_time,\n            period_duration=self.get_period_duration(),\n            output_start_date=target_timeindex.get_start_time(),\n            output_end_date=target_timeindex.get_stop_time(),\n        )\n\n    def _repeat_one_year_modeltime(self, input_vector: NDArray, target_timeindex: FixedFrequencyTimeIndex) -&gt; NDArray:\n        \"\"\"\n        Repeat the one-year model time index.\n\n        This method creates a new time vector by repeating the input vector over the time period defined by the target time index.\n\n        Parameters\n        ----------\n        input_vector : NDArray\n            The input vector to be repeated.\n        target_timeindex : FixedFrequencyTimeIndex\n            The target time index defining the start and stop times for the repetition.\n\n        Returns\n        -------\n        NDArray\n            The repeated vector that matches the target time index.\n\n        \"\"\"\n        return v_ops.repeat_oneyear_modeltime(\n            input_vector=input_vector,\n            input_start_date=self._start_time,\n            period_duration=self.get_period_duration(),\n            output_start_date=target_timeindex.get_start_time(),\n            output_end_date=target_timeindex.get_stop_time(),\n        )\n\n    def _adjust_period(self, input_vector: NDArray, target_timeindex: FixedFrequencyTimeIndex) -&gt; tuple[FixedFrequencyTimeIndex, NDArray]:\n        if target_timeindex.get_start_time() &lt; self._start_time:\n            if self._extrapolate_first_point:\n                return self._extend_start(input_vector, target_timeindex)\n            msg = (\n                \"Cannot write into fixed frequency: incompatible time indices. \"\n                \"Start time of the target index is before the start time of the source index \"\n                \"and extrapolate_first_point is False.\\n\"\n                f\"Input timeindex: {self}\\n\"\n                f\"Target timeindex: {target_timeindex}\"\n            )\n            raise ValueError(msg)\n        if target_timeindex.get_stop_time() &gt; self.get_stop_time():\n            if self._extrapolate_last_point:\n                return self._extend_end(input_vector, target_timeindex)\n            msg = (\n                \"Cannot write into fixed frequency: incompatible time indices. \"\n                \"'stop_time' of the target index is after the 'stop_time' of the source index \"\n                \"and 'extrapolate_last_point' is False.\\n\"\n                f\"Input timeindex: {self}\\n\"\n                f\"Target timeindex: {target_timeindex}\"\n            )\n            raise ValueError(msg)\n        if target_timeindex.get_start_time() &gt; self.get_start_time():\n            return self._slice_start(input_vector, target_timeindex)\n\n        if target_timeindex.get_stop_time() &lt; self.get_stop_time():\n            return self._slice_end(input_vector, target_timeindex)\n        return target_timeindex, input_vector\n\n    def _periods_between(self, first_time: datetime, second_time: datetime, period_duration: timedelta, is_52_week_years: bool) -&gt; int:\n        \"\"\"\n        Calculate the number of periods between two times.\n\n        Parameters\n        ----------\n        first_time : datetime\n            The first time point.\n        second_time : datetime\n            The second time point.\n        period_duration : timedelta\n            The duration of each period.\n        is_52_week_years : bool\n            Whether to use 52-week years.\n\n        Returns\n        -------\n        int\n            The number of periods between the two times.\n\n        \"\"\"\n        start = min(first_time, second_time)\n        end = max(first_time, second_time)\n        total_period = end - start\n\n        if is_52_week_years:\n            weeks_53 = v_ops._find_all_week_53_periods(start, end)  # noqa: SLF001\n            total_period -= timedelta(weeks=len(weeks_53))\n\n        return abs(total_period) // period_duration\n\n    def copy_with(\n        self,\n        start_time: datetime | None = None,\n        period_duration: timedelta | None = None,\n        num_periods: int | None = None,\n        is_52_week_years: bool | None = None,\n        extrapolate_first_point: bool | None = None,\n        extrapolate_last_point: bool | None = None,\n    ) -&gt; FixedFrequencyTimeIndex:\n        \"\"\"\n        Create a copy of the FixedFrequencyTimeIndex with the same attributes, allowing specific fields to be overridden.\n\n        Parameters\n        ----------\n        start_time : datetime, optional\n            Override for the start time.\n        period_duration : timedelta, optional\n            Override for the period duration.\n        num_periods : int, optional\n            Override for the number of periods.\n        is_52_week_years : bool, optional\n            Override for 52-week years flag.\n        extrapolate_first_point : bool, optional\n            Override for extrapolate first point flag.\n        extrapolate_last_point : bool, optional\n            Override for extrapolate last point flag.\n\n        Returns\n        -------\n        FixedFrequencyTimeIndex\n            A new instance with the updated attributes.\n\n        \"\"\"\n        return FixedFrequencyTimeIndex(\n            start_time=start_time if start_time is not None else self._start_time,\n            period_duration=period_duration if period_duration is not None else self._period_duration,\n            num_periods=num_periods if num_periods is not None else self._num_periods,\n            is_52_week_years=is_52_week_years if is_52_week_years is not None else self._is_52_week_years,\n            extrapolate_first_point=extrapolate_first_point if extrapolate_first_point is not None else self._extrapolate_first_point,\n            extrapolate_last_point=extrapolate_last_point if extrapolate_last_point is not None else self._extrapolate_last_point,\n        )\n\n    def copy_as_reference_period(self, reference_period: ReferencePeriod) -&gt; FixedFrequencyTimeIndex:\n        \"\"\"\n        Create a copy of the FixedFrequencyTimeIndex with one period matching the given reference period.\n\n        Parameters\n        ----------\n        reference_period : ReferencePeriod\n            The reference period to match for the output.\n\n        Returns\n        -------\n        FixedFrequencyTimeIndex\n            A new instance with the updated attributes.\n\n        \"\"\"\n        if reference_period is None:\n            raise ValueError(\"Cannot copy as reference period when provided reference_period is None.\")\n\n        start_year = reference_period.get_start_year()\n        num_years = reference_period.get_num_years()\n        start_time = datetime.fromisocalendar(start_year, 1, 1)\n\n        if self.is_52_week_years():\n            period_duration = timedelta(weeks=52 * num_years)\n        else:\n            stop_time = datetime.fromisocalendar(start_year + num_years, 1, 1)\n            period_duration = stop_time - start_time\n        return self.copy_with(\n            start_time=start_time,\n            num_periods=1,\n            period_duration=period_duration,\n        )\n\n    def get_datetime_list(self) -&gt; list[datetime]:\n        \"\"\"\n        Return list of datetime including stop time.\n\n        Note: When `is_52_week_years` is True, the returned list will skip any datetimes that fall in week 53.\n        \"\"\"\n        start_time = self.get_start_time()\n        num_periods = self.get_num_periods()\n        period_duration = self.get_period_duration()\n\n        if not self._is_52_week_years:\n            return [start_time + i * period_duration for i in range(num_periods + 1)]\n\n        datetime_list = []\n        i = 0\n        count = 0\n        while count &lt;= num_periods:\n            current = start_time + i * period_duration\n            if current.isocalendar().week != 53:  # noqa: PLR2004\n                datetime_list.append(current)\n                count += 1\n            i += 1\n\n        return datetime_list\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Check if equal to other.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Check if equal to other.\"\"\"\n    if not isinstance(other, FixedFrequencyTimeIndex):\n        return False\n    return (\n        self._start_time == other._start_time\n        and self._period_duration == other._period_duration\n        and self._num_periods == other._num_periods\n        and self._is_52_week_years == other._is_52_week_years\n        and self._extrapolate_first_point == other._extrapolate_first_point\n        and self._extrapolate_last_point == other._extrapolate_last_point\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Return the hash value for the FixedFrequencyTimeIndex.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash value for the FixedFrequencyTimeIndex.\"\"\"\n    return hash(\n        (\n            self._start_time,\n            self._period_duration,\n            self._num_periods,\n            self._is_52_week_years,\n            self._extrapolate_first_point,\n            self._extrapolate_last_point,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.__init__","title":"<code>__init__(start_time: datetime, period_duration: timedelta, num_periods: int, is_52_week_years: bool, extrapolate_first_point: bool, extrapolate_last_point: bool) -&gt; None</code>","text":"<p>Initialize a FixedFrequencyTimeIndex.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>datetime</code> <p>The starting datetime of the time index.</p> required <code>period_duration</code> <code>timedelta</code> <p>The duration of each period.</p> required <code>num_periods</code> <code>int</code> <p>The number of periods in the time index. Must be greater than 0.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years.</p> required <code>extrapolate_first_point</code> <code>bool</code> <p>Whether to allow extrapolation of the first point.</p> required <code>extrapolate_last_point</code> <code>bool</code> <p>Whether to allow extrapolation of the last point.</p> required Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def __init__(\n    self,\n    start_time: datetime,\n    period_duration: timedelta,\n    num_periods: int,\n    is_52_week_years: bool,\n    extrapolate_first_point: bool,\n    extrapolate_last_point: bool,\n) -&gt; None:\n    \"\"\"\n    Initialize a FixedFrequencyTimeIndex.\n\n    Args:\n        start_time (datetime): The starting datetime of the time index.\n        period_duration (timedelta): The duration of each period.\n        num_periods (int): The number of periods in the time index. Must be greater than 0.\n        is_52_week_years (bool): Whether to use 52-week years.\n        extrapolate_first_point (bool): Whether to allow extrapolation of the first point.\n        extrapolate_last_point (bool): Whether to allow extrapolation of the last point.\n\n    \"\"\"\n    if num_periods &lt;= 0:\n        msg = f\"num_periods must be a positive integer. Got {num_periods}.\"\n        raise ValueError(msg)\n    if period_duration &lt; timedelta(seconds=1):\n        msg = f\"period_duration must be at least one second. Got {period_duration}.\"\n        raise ValueError(msg)\n    if not period_duration.total_seconds().is_integer():\n        msg = f\"period_duration must be a whole number of seconds, got {period_duration.total_seconds()} s\"\n        raise ValueError(msg)\n    if is_52_week_years and start_time.isocalendar().week == 53:  # noqa: PLR2004\n        raise ValueError(\"Week of start_time must not be 53 when is_52_week_years is True.\")\n    self._check_type(num_periods, int)\n    self._start_time = start_time\n    self._period_duration = period_duration\n    self._num_periods = num_periods\n    self._is_52_week_years = is_52_week_years\n    self._extrapolate_first_point = extrapolate_first_point\n    self._extrapolate_last_point = extrapolate_last_point\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a string representation of the FixedFrequencyTimeIndex.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the FixedFrequencyTimeIndex.\"\"\"\n    return (\n        f\"{type(self).__name__}(\"\n        f\"start_time={self._start_time}, \"\n        f\"period_duration={self._period_duration}, \"\n        f\"num_periods={self._num_periods}, \"\n        f\"is_52_week_years={self._is_52_week_years}, \"\n        f\"extrapolate_first_point={self._extrapolate_first_point}, \"\n        f\"extrapolate_last_point={self._extrapolate_last_point})\"\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.copy_as_reference_period","title":"<code>copy_as_reference_period(reference_period: ReferencePeriod) -&gt; FixedFrequencyTimeIndex</code>","text":"<p>Create a copy of the FixedFrequencyTimeIndex with one period matching the given reference period.</p>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.copy_as_reference_period--parameters","title":"Parameters","text":"<p>reference_period : ReferencePeriod     The reference period to match for the output.</p>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.copy_as_reference_period--returns","title":"Returns","text":"<p>FixedFrequencyTimeIndex     A new instance with the updated attributes.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def copy_as_reference_period(self, reference_period: ReferencePeriod) -&gt; FixedFrequencyTimeIndex:\n    \"\"\"\n    Create a copy of the FixedFrequencyTimeIndex with one period matching the given reference period.\n\n    Parameters\n    ----------\n    reference_period : ReferencePeriod\n        The reference period to match for the output.\n\n    Returns\n    -------\n    FixedFrequencyTimeIndex\n        A new instance with the updated attributes.\n\n    \"\"\"\n    if reference_period is None:\n        raise ValueError(\"Cannot copy as reference period when provided reference_period is None.\")\n\n    start_year = reference_period.get_start_year()\n    num_years = reference_period.get_num_years()\n    start_time = datetime.fromisocalendar(start_year, 1, 1)\n\n    if self.is_52_week_years():\n        period_duration = timedelta(weeks=52 * num_years)\n    else:\n        stop_time = datetime.fromisocalendar(start_year + num_years, 1, 1)\n        period_duration = stop_time - start_time\n    return self.copy_with(\n        start_time=start_time,\n        num_periods=1,\n        period_duration=period_duration,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.copy_with","title":"<code>copy_with(start_time: datetime | None = None, period_duration: timedelta | None = None, num_periods: int | None = None, is_52_week_years: bool | None = None, extrapolate_first_point: bool | None = None, extrapolate_last_point: bool | None = None) -&gt; FixedFrequencyTimeIndex</code>","text":"<p>Create a copy of the FixedFrequencyTimeIndex with the same attributes, allowing specific fields to be overridden.</p>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.copy_with--parameters","title":"Parameters","text":"<p>start_time : datetime, optional     Override for the start time. period_duration : timedelta, optional     Override for the period duration. num_periods : int, optional     Override for the number of periods. is_52_week_years : bool, optional     Override for 52-week years flag. extrapolate_first_point : bool, optional     Override for extrapolate first point flag. extrapolate_last_point : bool, optional     Override for extrapolate last point flag.</p>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.copy_with--returns","title":"Returns","text":"<p>FixedFrequencyTimeIndex     A new instance with the updated attributes.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def copy_with(\n    self,\n    start_time: datetime | None = None,\n    period_duration: timedelta | None = None,\n    num_periods: int | None = None,\n    is_52_week_years: bool | None = None,\n    extrapolate_first_point: bool | None = None,\n    extrapolate_last_point: bool | None = None,\n) -&gt; FixedFrequencyTimeIndex:\n    \"\"\"\n    Create a copy of the FixedFrequencyTimeIndex with the same attributes, allowing specific fields to be overridden.\n\n    Parameters\n    ----------\n    start_time : datetime, optional\n        Override for the start time.\n    period_duration : timedelta, optional\n        Override for the period duration.\n    num_periods : int, optional\n        Override for the number of periods.\n    is_52_week_years : bool, optional\n        Override for 52-week years flag.\n    extrapolate_first_point : bool, optional\n        Override for extrapolate first point flag.\n    extrapolate_last_point : bool, optional\n        Override for extrapolate last point flag.\n\n    Returns\n    -------\n    FixedFrequencyTimeIndex\n        A new instance with the updated attributes.\n\n    \"\"\"\n    return FixedFrequencyTimeIndex(\n        start_time=start_time if start_time is not None else self._start_time,\n        period_duration=period_duration if period_duration is not None else self._period_duration,\n        num_periods=num_periods if num_periods is not None else self._num_periods,\n        is_52_week_years=is_52_week_years if is_52_week_years is not None else self._is_52_week_years,\n        extrapolate_first_point=extrapolate_first_point if extrapolate_first_point is not None else self._extrapolate_first_point,\n        extrapolate_last_point=extrapolate_last_point if extrapolate_last_point is not None else self._extrapolate_last_point,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.extrapolate_first_point","title":"<code>extrapolate_first_point() -&gt; bool</code>","text":"<p>Return True if first value can be extrapolated backwards to fill missing values.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def extrapolate_first_point(self) -&gt; bool:\n    \"\"\"Return True if first value can be extrapolated backwards to fill missing values.\"\"\"\n    return self._extrapolate_first_point\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.extrapolate_last_point","title":"<code>extrapolate_last_point() -&gt; bool</code>","text":"<p>Return True if last value can be extrapolated forward to fill missing values.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def extrapolate_last_point(self) -&gt; bool:\n    \"\"\"Return True if last value can be extrapolated forward to fill missing values.\"\"\"\n    return self._extrapolate_last_point\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_datetime_list","title":"<code>get_datetime_list() -&gt; list[datetime]</code>","text":"<p>Return list of datetime including stop time.</p> <p>Note: When <code>is_52_week_years</code> is True, the returned list will skip any datetimes that fall in week 53.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_datetime_list(self) -&gt; list[datetime]:\n    \"\"\"\n    Return list of datetime including stop time.\n\n    Note: When `is_52_week_years` is True, the returned list will skip any datetimes that fall in week 53.\n    \"\"\"\n    start_time = self.get_start_time()\n    num_periods = self.get_num_periods()\n    period_duration = self.get_period_duration()\n\n    if not self._is_52_week_years:\n        return [start_time + i * period_duration for i in range(num_periods + 1)]\n\n    datetime_list = []\n    i = 0\n    count = 0\n    while count &lt;= num_periods:\n        current = start_time + i * period_duration\n        if current.isocalendar().week != 53:  # noqa: PLR2004\n            datetime_list.append(current)\n            count += 1\n        i += 1\n\n    return datetime_list\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the fingerprint.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the fingerprint.\"\"\"\n    return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_num_periods","title":"<code>get_num_periods() -&gt; int</code>","text":"<p>Get the number of points.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_num_periods(self) -&gt; int:\n    \"\"\"Get the number of points.\"\"\"\n    return self._num_periods\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_period_average","title":"<code>get_period_average(vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float</code>","text":"<p>Get the average over the period from the vector.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_period_average(self, vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float:\n    \"\"\"Get the average over the period from the vector.\"\"\"\n    self._check_type(vector, np.ndarray)\n    self._check_type(start_time, datetime)\n    self._check_type(duration, timedelta)\n    self._check_type(is_52_week_years, bool)\n\n    if vector.shape != (self.get_num_periods(),):\n        msg = f\"Vector shape {vector.shape} does not match number of periods {self.get_num_periods()} of timeindex ({self}).\"\n        raise ValueError(msg)\n    target_timeindex = FixedFrequencyTimeIndex(\n        start_time=start_time,\n        period_duration=duration,\n        num_periods=1,\n        is_52_week_years=is_52_week_years,\n        extrapolate_first_point=self.extrapolate_first_point(),\n        extrapolate_last_point=self.extrapolate_last_point(),\n    )\n    target_vector = np.zeros(1, dtype=vector.dtype)\n    self.write_into_fixed_frequency(\n        target_vector=target_vector,\n        target_timeindex=target_timeindex,\n        input_vector=vector,\n    )\n    return target_vector[0]\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_period_duration","title":"<code>get_period_duration() -&gt; timedelta</code>","text":"<p>Get the period duration.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_period_duration(self) -&gt; timedelta:\n    \"\"\"Get the period duration.\"\"\"\n    return self._period_duration\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_reference_period","title":"<code>get_reference_period() -&gt; ReferencePeriod | None</code>","text":"<p>Get the reference period (only if is_whole_years() is True).</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_reference_period(self) -&gt; ReferencePeriod | None:\n    \"\"\"Get the reference period (only if is_whole_years() is True).\"\"\"\n    if self.is_whole_years():\n        start_year = self.get_start_time().isocalendar().year\n        if self._is_52_week_years:\n            num_years = (self.get_num_periods() * self.get_period_duration()) // timedelta(weeks=52)\n        else:\n            stop_year = self.get_stop_time().isocalendar().year\n            num_years = stop_year - start_year\n        return ReferencePeriod(start_year=start_year, num_years=num_years)\n    return None\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_start_time","title":"<code>get_start_time() -&gt; datetime</code>","text":"<p>Get the start time.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_start_time(self) -&gt; datetime:\n    \"\"\"Get the start time.\"\"\"\n    return self._start_time\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_stop_time","title":"<code>get_stop_time() -&gt; datetime</code>","text":"<p>Get the stop time of the TimeIndex.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_stop_time(self) -&gt; datetime:\n    \"\"\"Get the stop time of the TimeIndex.\"\"\"\n    if not self._is_52_week_years:\n        return self._start_time + self._period_duration * self._num_periods\n\n    return v_ops.calculate_52_week_years_stop_time(\n        start_time=self._start_time,\n        period_duration=self._period_duration,\n        num_periods=self._num_periods,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.get_timezone","title":"<code>get_timezone() -&gt; tzinfo | None</code>","text":"<p>Get the timezone.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def get_timezone(self) -&gt; tzinfo | None:\n    \"\"\"Get the timezone.\"\"\"\n    return self._start_time.tzinfo\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.is_52_week_years","title":"<code>is_52_week_years() -&gt; bool</code>","text":"<p>Return True if 52-week years and False if real ISO time.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def is_52_week_years(self) -&gt; bool:\n    \"\"\"Return True if 52-week years and False if real ISO time.\"\"\"\n    return self._is_52_week_years\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.is_constant","title":"<code>is_constant() -&gt; bool</code>","text":"<p>Return True if the time index is constant (single period and both extrapolation flags are True).</p>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.is_constant--returns","title":"Returns","text":"<p>bool     True if the time index is constant, False otherwise.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def is_constant(self) -&gt; bool:\n    \"\"\"\n    Return True if the time index is constant (single period and both extrapolation flags are True).\n\n    Returns\n    -------\n    bool\n        True if the time index is constant, False otherwise.\n\n    \"\"\"\n    return self._num_periods == 1 and self._extrapolate_first_point == self._extrapolate_last_point is True\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.is_one_year","title":"<code>is_one_year() -&gt; bool</code>","text":"<p>Return True if exactly one whole year.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def is_one_year(self) -&gt; bool:\n    \"\"\"Return True if exactly one whole year.\"\"\"\n    start_time = self.get_start_time()\n    start_year, start_week, start_weekday = start_time.isocalendar()\n    if not start_week == start_weekday == 1:\n        return False\n\n    if not self.is_52_week_years():\n        period_duration = self.get_period_duration()\n        num_periods = self.get_num_periods()\n        stop_time = start_time + num_periods * period_duration\n        stop_year, stop_week, stop_weekday = stop_time.isocalendar()\n        if not stop_week == stop_weekday == 1:\n            return False\n        return start_year + 1 == stop_year\n\n    period_duration = self.get_period_duration()\n    num_periods = self.get_num_periods()\n    seconds_52_week_year = 52 * 168 * 3600\n    num_years = (period_duration * num_periods).total_seconds() / seconds_52_week_year\n    return num_years == 1.0\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.is_same_resolution","title":"<code>is_same_resolution(other: FixedFrequencyTimeIndex) -&gt; bool</code>","text":"<p>Check if the period duration is the same.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def is_same_resolution(self, other: FixedFrequencyTimeIndex) -&gt; bool:\n    \"\"\"Check if the period duration is the same.\"\"\"\n    return self._period_duration == other.get_period_duration()\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.is_whole_years","title":"<code>is_whole_years() -&gt; bool</code>","text":"<p>Return True if index covers one or more full years.</p> <p>The start_time must be the first week and weekday of a year. For real ISO time, the stop_time must also be the first week and weekday of a year. For 52-week years, the total duration must be an integer number of 52-week years.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def is_whole_years(self) -&gt; bool:\n    \"\"\"\n    Return True if index covers one or more full years.\n\n    The start_time must be the first week and weekday of a year. For real ISO time,\n    the stop_time must also be the first week and weekday of a year. For 52-week years,\n    the total duration must be an integer number of 52-week years.\n    \"\"\"\n    start_time = self.get_start_time()\n    start_year, start_week, start_weekday = start_time.isocalendar()\n    if not start_week == start_weekday == 1:\n        return False\n\n    if not self.is_52_week_years():\n        period_duration = self.get_period_duration()\n        num_periods = self.get_num_periods()\n        stop_time = start_time + num_periods * period_duration\n        stop_year, stop_week, stop_weekday = stop_time.isocalendar()\n        if stop_year &lt; start_year:\n            msg = f\"Stop year must be after start year. Current stop year: {stop_year} and start year: {start_year}\"\n            raise ValueError(msg)\n        return stop_week == stop_weekday == 1\n\n    period_duration = self.get_period_duration()\n    num_periods = self.get_num_periods()\n    seconds_52_week_year = 52 * 168 * 3600\n    num_years = (period_duration * num_periods).total_seconds() / seconds_52_week_year\n    return num_years.is_integer()\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.slice","title":"<code>slice(input_vector: NDArray, start_year: int, num_years: int, target_start_year: int, target_num_years: int) -&gt; NDArray</code>","text":"<p>Periodize the input vector to match the target timeindex.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def slice(\n    self,\n    input_vector: NDArray,\n    start_year: int,\n    num_years: int,\n    target_start_year: int,\n    target_num_years: int,\n) -&gt; NDArray:\n    \"\"\"Periodize the input vector to match the target timeindex.\"\"\"\n    if self._is_52_week_years:\n        return v_ops.periodize_modeltime(input_vector, start_year, num_years, target_start_year, target_num_years)\n    return v_ops.periodize_isotime(input_vector, start_year, num_years, target_start_year, target_num_years)\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.total_duration","title":"<code>total_duration() -&gt; timedelta</code>","text":"<p>Get the duration of the TimeIndex.</p> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def total_duration(self) -&gt; timedelta:\n    \"\"\"Get the duration of the TimeIndex.\"\"\"\n    return self._period_duration * self._num_periods\n</code></pre>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.write_into_fixed_frequency","title":"<code>write_into_fixed_frequency(target_vector: NDArray, target_timeindex: FixedFrequencyTimeIndex, input_vector: NDArray) -&gt; None</code>","text":"<p>Write the given input_vector into the target_vector according to the target_timeindex, applying necessary transformations.</p>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.write_into_fixed_frequency--parameters","title":"Parameters","text":"<p>target_vector : NDArray     The array where the input_vector will be written to, modified in place. target_timeindex : FixedFrequencyTimeIndex     The time index defining the fixed frequency structure for writing the input_vector into the target_vector. input_vector : NDArray     The array containing the data to be written into the target_vector.</p>"},{"location":"reference/#framcore.timeindexes.FixedFrequencyTimeIndex.FixedFrequencyTimeIndex.write_into_fixed_frequency--notes","title":"Notes","text":"<ul> <li>If the object is constant (as determined by <code>self.is_constant()</code>), the input_vector is expected to have a single value,   which will be used to fill the entire target_vector.</li> <li>Otherwise, the method delegates the operation to <code>_write_into_fixed_frequency_recursive</code> for handling more complex cases.</li> </ul> Source code in <code>framcore/timeindexes/FixedFrequencyTimeIndex.py</code> <pre><code>def write_into_fixed_frequency(\n    self,\n    target_vector: NDArray,\n    target_timeindex: FixedFrequencyTimeIndex,\n    input_vector: NDArray,\n) -&gt; None:\n    \"\"\"\n    Write the given input_vector into the target_vector according to the target_timeindex, applying necessary transformations.\n\n    Parameters\n    ----------\n    target_vector : NDArray\n        The array where the input_vector will be written to, modified in place.\n    target_timeindex : FixedFrequencyTimeIndex\n        The time index defining the fixed frequency structure for writing the input_vector into the target_vector.\n    input_vector : NDArray\n        The array containing the data to be written into the target_vector.\n\n    Notes\n    -----\n    - If the object is constant (as determined by `self.is_constant()`), the input_vector is expected to have a single value,\n      which will be used to fill the entire target_vector.\n    - Otherwise, the method delegates the operation to `_write_into_fixed_frequency_recursive` for handling more complex cases.\n\n    \"\"\"\n    if self.is_constant():\n        assert input_vector.size == 1\n        target_vector.fill(input_vector[0])\n    else:\n        self._write_into_fixed_frequency_recursive(target_vector, target_timeindex, input_vector)\n</code></pre>"},{"location":"reference/#framcore.timeindexes.HourlyIndex","title":"<code>HourlyIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.HourlyIndex.HourlyIndex","title":"<code>HourlyIndex</code>","text":"<p>               Bases: <code>ProfileTimeIndex</code></p> <p>ProfileTimeIndex with one or more whole years with hourly resolution. Either years with 52 weeks or full iso calendar years.</p> <p>No extrapolation inherited from ProfileTimeIndex.</p> Source code in <code>framcore/timeindexes/HourlyIndex.py</code> <pre><code>class HourlyIndex(ProfileTimeIndex):\n    \"\"\"\n    ProfileTimeIndex with one or more whole years with hourly resolution. Either years with 52 weeks or full iso calendar years.\n\n    No extrapolation inherited from ProfileTimeIndex.\n    \"\"\"\n\n    def __init__(\n        self,\n        start_year: int,\n        num_years: int,\n        is_52_week_years: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize HourlyIndex over a number of years. Either years with 52 weeks or full iso calendar years.\n\n        Args:\n            start_year (int): First year in the index.\n            num_years (int): Number of years in the index.\n            is_52_week_years (bool, optional): Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.\n\n        \"\"\"\n        super().__init__(\n            start_year=start_year,\n            num_years=num_years,\n            period_duration=timedelta(hours=1),\n            is_52_week_years=is_52_week_years,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.HourlyIndex.HourlyIndex.__init__","title":"<code>__init__(start_year: int, num_years: int, is_52_week_years: bool = True) -&gt; None</code>","text":"<p>Initialize HourlyIndex over a number of years. Either years with 52 weeks or full iso calendar years.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <code>int</code> <p>First year in the index.</p> required <code>num_years</code> <code>int</code> <p>Number of years in the index.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.</p> <code>True</code> Source code in <code>framcore/timeindexes/HourlyIndex.py</code> <pre><code>def __init__(\n    self,\n    start_year: int,\n    num_years: int,\n    is_52_week_years: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize HourlyIndex over a number of years. Either years with 52 weeks or full iso calendar years.\n\n    Args:\n        start_year (int): First year in the index.\n        num_years (int): Number of years in the index.\n        is_52_week_years (bool, optional): Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.\n\n    \"\"\"\n    super().__init__(\n        start_year=start_year,\n        num_years=num_years,\n        period_duration=timedelta(hours=1),\n        is_52_week_years=is_52_week_years,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.IsoCalendarDay","title":"<code>IsoCalendarDay</code>","text":""},{"location":"reference/#framcore.timeindexes.IsoCalendarDay.IsoCalendarDay","title":"<code>IsoCalendarDay</code>","text":"<p>               Bases: <code>SinglePeriodTimeIndex</code></p> <p>Represents a single ISO calendar day using year, week, and day values.</p> <p>Inherits from SinglePeriodTimeIndex and provides a time index for one day, constructed from datetime.fromisocalendar(year, week, day).</p> Source code in <code>framcore/timeindexes/IsoCalendarDay.py</code> <pre><code>class IsoCalendarDay(SinglePeriodTimeIndex):\n    \"\"\"\n    Represents a single ISO calendar day using year, week, and day values.\n\n    Inherits from SinglePeriodTimeIndex and provides a time index for one day,\n    constructed from datetime.fromisocalendar(year, week, day).\n\n    \"\"\"\n\n    def __init__(self, year: int, week: int, day: int) -&gt; None:\n        \"\"\"\n        IsoCalendarDay represent a day from datetime.fromisocalendar(year, week, day).\n\n        No extrapolation and is_52_week_years=False. Useful for testing.\n\n        Args:\n            year (int): The ISO year.\n            week (int): The ISO week number (1-53).\n            day (int): The ISO weekday (1=Monday, 7=Sunday).\n\n        \"\"\"\n        super().__init__(\n            start_time=datetime.fromisocalendar(year, week, day),\n            period_duration=timedelta(days=1),\n            is_52_week_years=False,\n            extrapolate_first_point=False,\n            extrapolate_last_point=False,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.IsoCalendarDay.IsoCalendarDay.__init__","title":"<code>__init__(year: int, week: int, day: int) -&gt; None</code>","text":"<p>IsoCalendarDay represent a day from datetime.fromisocalendar(year, week, day).</p> <p>No extrapolation and is_52_week_years=False. Useful for testing.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The ISO year.</p> required <code>week</code> <code>int</code> <p>The ISO week number (1-53).</p> required <code>day</code> <code>int</code> <p>The ISO weekday (1=Monday, 7=Sunday).</p> required Source code in <code>framcore/timeindexes/IsoCalendarDay.py</code> <pre><code>def __init__(self, year: int, week: int, day: int) -&gt; None:\n    \"\"\"\n    IsoCalendarDay represent a day from datetime.fromisocalendar(year, week, day).\n\n    No extrapolation and is_52_week_years=False. Useful for testing.\n\n    Args:\n        year (int): The ISO year.\n        week (int): The ISO week number (1-53).\n        day (int): The ISO weekday (1=Monday, 7=Sunday).\n\n    \"\"\"\n    super().__init__(\n        start_time=datetime.fromisocalendar(year, week, day),\n        period_duration=timedelta(days=1),\n        is_52_week_years=False,\n        extrapolate_first_point=False,\n        extrapolate_last_point=False,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex","title":"<code>ListTimeIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex","title":"<code>ListTimeIndex</code>","text":"<p>               Bases: <code>TimeIndex</code></p> <p>ListTimeIndex class for TimeIndexes with a list of timestamps. Subclass of TimeIndex.</p> <p>This TimeIndex is defined by a list of timestamps, with possible irregular intervals.The last timestamp is not necessarily the end of the time vector, and the first timestamp is not necessarily the start of the time vector if extrapolation is enabled.</p> <p>ListTimeIndex is not recommended for large time vectors, as it is less efficient.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>class ListTimeIndex(TimeIndex):\n    \"\"\"\n    ListTimeIndex class for TimeIndexes with a list of timestamps. Subclass of TimeIndex.\n\n    This TimeIndex is defined by a list of timestamps, with possible irregular intervals.The last timestamp is not\n    necessarily the end of the time vector, and the first timestamp is not necessarily the start of the time vector\n    if extrapolation is enabled.\n\n    ListTimeIndex is not recommended for large time vectors, as it is less efficient.\n    \"\"\"\n\n    def __init__(\n        self,\n        datetime_list: list[datetime],\n        is_52_week_years: bool,\n        extrapolate_first_point: bool,\n        extrapolate_last_point: bool,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ListTimeIndex class.\n\n        Args:\n            datetime_list (list[datetime]): List of datetime objects defining the time index. Must be ordered and contain more than one element.\n            is_52_week_years (bool): Whether to use 52-week years. If False, full iso calendar years are used.\n            extrapolate_first_point (bool): Whether to extrapolate the first point.\n            extrapolate_last_point (bool): Whether to extrapolate the last point.\n\n        Raises:\n            ValueError: If datetime_list has less than two elements or is not ordered.\n\n        \"\"\"\n        dts = datetime_list\n        if len(dts) &lt;= 1:\n            msg = f\"datetime_list must contain more than one element. Got {datetime_list}\"\n            raise ValueError(msg)\n        if not all(dts[i] &lt; dts[i + 1] for i in range(len(dts) - 1)):\n            msg = f\"All elements of datetime_list must be smaller/lower than the succeeding element. Dates must be ordered. Got {datetime_list}.\"\n            raise ValueError(msg)\n        if len(set(dt.tzinfo for dt in dts if dt is not None)) &gt; 1:\n            msg = f\"Datetime objects in datetime_list have differing time zone information: {set(dt.tzinfo for dt in dts if dt is not None)}\"\n            raise ValueError(msg)\n        if is_52_week_years and any(dts[i].isocalendar().week == 53 for i in range(len(dts))):  # noqa: PLR2004\n            msg = \"When is_52_week_years is True, datetime_list should not contain week 53 datetimes.\"\n            raise ValueError(msg)\n\n        self._datetime_list = datetime_list\n        self._is_52_week_years = is_52_week_years\n        self._extrapolate_first_point = extrapolate_first_point\n        self._extrapolate_last_point = extrapolate_last_point\n\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Check if two ListTimeIndexes are equal.\"\"\"\n        if not isinstance(other, type(self)):\n            return False\n        return (\n            self._datetime_list == other._datetime_list\n            and self._extrapolate_first_point == other._extrapolate_first_point\n            and self._extrapolate_last_point == other._extrapolate_last_point\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the ListTimeIndex.\"\"\"\n        return hash(\n            (\n                tuple(self._datetime_list),\n                self._extrapolate_first_point,\n                self._extrapolate_last_point,\n            ),\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the string representation of the ListTimeIndex.\"\"\"\n        return (\n            \"ListTimeIndex(\"\n            f\"datetimelist={self._datetime_list}, \"\n            f\"extrapolate_first_point={self._extrapolate_first_point}, \"\n            f\"extrapolate_last_point={self._extrapolate_last_point})\"\n        )\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the fingerprint of the ListTimeIndex.\"\"\"\n        fingerprint = Fingerprint()\n        fingerprint.add(\"datetime_list\", self._datetime_list)\n        fingerprint.add(\"is_52_week_years\", self._is_52_week_years)\n        fingerprint.add(\"extrapolate_first_point\", self._extrapolate_first_point)\n        fingerprint.add(\"extrapolate_last_point\", self._extrapolate_last_point)\n        return fingerprint\n\n    def get_datetime_list(self) -&gt; list[datetime]:\n        \"\"\"Get a list of all periods (num_periods + 1 datetimes).\"\"\"\n        return self._datetime_list.copy()\n\n    def get_timezone(self) -&gt; tzinfo | None:\n        \"\"\"Get the timezone of the TimeIndex.\"\"\"\n        return self._datetime_list[0].tzinfo\n\n    def get_num_periods(self) -&gt; int:\n        \"\"\"Get the number of periods in the TimeIndex.\"\"\"\n        return len(self._datetime_list) - 1\n\n    def is_52_week_years(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex is based on 52-week years.\"\"\"\n        return self._is_52_week_years\n\n    def is_one_year(self) -&gt; bool:\n        \"\"\"Return True if exactly one whole year.\"\"\"\n        if self._extrapolate_first_point or self._extrapolate_last_point:\n            return False\n        start_time = self._datetime_list[0]\n        stop_time = self._datetime_list[-1]\n        start_year, start_week, start_weekday = start_time.isocalendar()\n\n        if not start_weekday == start_week == 1:\n            return False\n\n        if self._is_52_week_years:\n            expected_stop_time = start_time + timedelta(weeks=52)\n            if expected_stop_time.isocalendar().week == 53:  # noqa: PLR2004\n                expected_stop_time += timedelta(weeks=1)\n            return stop_time == expected_stop_time\n\n        stop_year, stop_week, stop_weekday = stop_time.isocalendar()\n        return (start_year + 1 == stop_year) and (stop_weekday == stop_week == 1)\n\n    def is_whole_years(self) -&gt; bool:\n        \"\"\"Return True if index covers one or more full years.\"\"\"\n        start_time = self._datetime_list[0]\n        _, start_week, start_weekday = start_time.isocalendar()\n\n        if not start_week == start_weekday == 1:\n            return False\n\n        stop_time = self._datetime_list[-1]\n\n        if not self.is_52_week_years():\n            _, stop_week, stop_weekday = stop_time.isocalendar()\n            return stop_week == stop_weekday == 1\n\n        total_period = self.total_duration()\n        total_seconds = int(total_period.total_seconds())\n        seconds_per_year = 52 * 7 * 24 * 3600\n\n        return total_seconds % seconds_per_year == 0\n\n    def extrapolate_first_point(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex should extrapolate the first point.\"\"\"\n        return self._extrapolate_first_point\n\n    def extrapolate_last_point(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex should extrapolate the last point.\"\"\"\n        return self._extrapolate_last_point\n\n    def get_period_average(self, vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float:\n        \"\"\"Get the average over the period from the vector.\"\"\"\n        self._check_type(vector, np.ndarray)\n        self._check_type(start_time, datetime)\n        self._check_type(duration, timedelta)\n        self._check_type(is_52_week_years, bool)\n\n        if vector.shape != (self.get_num_periods(),):\n            msg = f\"Vector shape {vector.shape} does not match number of periods {self.get_num_periods()} of timeindex ({self}).\"\n            raise ValueError(msg)\n\n        if not self.extrapolate_first_point():\n            if start_time &lt; self._datetime_list[0]:\n                msg = f\"start_time {start_time} is before start of timeindex {self._datetime_list[0]}, and extrapolate_first_point is False.\"\n                raise ValueError(msg)\n            if (start_time + duration) &lt; self._datetime_list[0]:\n                msg = f\"End time {start_time + duration} is before start of timeindex {self._datetime_list[0]}, and extrapolate_first_point is False.\"\n                raise ValueError(msg)\n\n        if not self.extrapolate_last_point():\n            if (start_time + duration) &gt; self._datetime_list[-1]:\n                msg = f\"End time {start_time + duration} is after end of timeindex {self._datetime_list[-1]}, and extrapolate_last_point is False.\"\n                raise ValueError(msg)\n            if start_time &gt; self._datetime_list[-1]:\n                msg = f\"start_time {start_time} is after end of timeindex {self._datetime_list[-1]}, and extrapolate_last_point is False.\"\n                raise ValueError(msg)\n\n        target_timeindex = FixedFrequencyTimeIndex(\n            start_time=start_time,\n            period_duration=duration,\n            num_periods=1,\n            is_52_week_years=is_52_week_years,\n            extrapolate_first_point=self.extrapolate_first_point(),\n            extrapolate_last_point=self.extrapolate_last_point(),\n        )\n\n        target_vector = np.zeros(1, dtype=vector.dtype)\n        self.write_into_fixed_frequency(\n            target_vector=target_vector,\n            target_timeindex=target_timeindex,\n            input_vector=vector,\n        )\n        return target_vector[0]\n\n    def write_into_fixed_frequency(\n        self,\n        target_vector: NDArray,\n        target_timeindex: FixedFrequencyTimeIndex,\n        input_vector: NDArray,\n    ) -&gt; None:\n        \"\"\"Write the input vector into the target vector using the target FixedFrequencyTimeIndex.\"\"\"\n        self._check_type(target_vector, np.ndarray)\n        self._check_type(target_timeindex, FixedFrequencyTimeIndex)\n        self._check_type(input_vector, np.ndarray)\n\n        dts: list[datetime] = self._datetime_list\n\n        durations = set(self._microseconds(period_duration(dts[i], dts[i + 1], self._is_52_week_years)) for i in range(len(dts) - 1))\n        smallest_common_period_duration = functools.reduce(math.gcd, durations)\n\n        num_periods_ff = self._microseconds(self.total_duration()) // smallest_common_period_duration\n        input_vector_ff = np.zeros(num_periods_ff, dtype=target_vector.dtype)\n\n        i_start_ff = 0\n        for i in range(len(dts) - 1):\n            num_periods = self._microseconds(period_duration(dts[i], dts[i + 1], self._is_52_week_years)) // smallest_common_period_duration\n            i_stop_ff = i_start_ff + num_periods\n            input_vector_ff[i_start_ff:i_stop_ff] = input_vector[i]\n            i_start_ff = i_stop_ff\n\n        input_timeindex_ff = FixedFrequencyTimeIndex(\n            start_time=dts[0],\n            num_periods=num_periods_ff,\n            period_duration=timedelta(microseconds=smallest_common_period_duration),\n            is_52_week_years=self.is_52_week_years(),\n            extrapolate_first_point=self.extrapolate_first_point(),\n            extrapolate_last_point=self.extrapolate_last_point(),\n        )\n\n        input_timeindex_ff.write_into_fixed_frequency(\n            target_vector=target_vector,\n            target_timeindex=target_timeindex,\n            input_vector=input_vector_ff,\n        )\n\n    def total_duration(self) -&gt; timedelta:\n        \"\"\"\n        Return the total duration covered by the time index.\n\n        Returns\n        -------\n        timedelta\n            The duration from the first to the last datetime in the index, skipping all weeks 53 periods if 52-week time format.\n\n        \"\"\"\n        start_time = self._datetime_list[0]\n        end_time = self._datetime_list[-1]\n        return period_duration(start_time, end_time, self.is_52_week_years())\n\n    def _microseconds(self, duration: timedelta) -&gt; int:\n        return int(duration.total_seconds() * 1e6)\n\n    def is_constant(self) -&gt; bool:\n        \"\"\"\n        Return True if the time index is constant (single period and both extrapolation flags are True).\n\n        Returns\n        -------\n        bool\n            True if the time index is constant, False otherwise.\n\n        \"\"\"\n        return self.get_num_periods() == 1 and self.extrapolate_first_point() == self.extrapolate_last_point() is True\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Check if two ListTimeIndexes are equal.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Check if two ListTimeIndexes are equal.\"\"\"\n    if not isinstance(other, type(self)):\n        return False\n    return (\n        self._datetime_list == other._datetime_list\n        and self._extrapolate_first_point == other._extrapolate_first_point\n        and self._extrapolate_last_point == other._extrapolate_last_point\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Return the hash of the ListTimeIndex.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the ListTimeIndex.\"\"\"\n    return hash(\n        (\n            tuple(self._datetime_list),\n            self._extrapolate_first_point,\n            self._extrapolate_last_point,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.__init__","title":"<code>__init__(datetime_list: list[datetime], is_52_week_years: bool, extrapolate_first_point: bool, extrapolate_last_point: bool) -&gt; None</code>","text":"<p>Initialize the ListTimeIndex class.</p> <p>Parameters:</p> Name Type Description Default <code>datetime_list</code> <code>list[datetime]</code> <p>List of datetime objects defining the time index. Must be ordered and contain more than one element.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years. If False, full iso calendar years are used.</p> required <code>extrapolate_first_point</code> <code>bool</code> <p>Whether to extrapolate the first point.</p> required <code>extrapolate_last_point</code> <code>bool</code> <p>Whether to extrapolate the last point.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If datetime_list has less than two elements or is not ordered.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def __init__(\n    self,\n    datetime_list: list[datetime],\n    is_52_week_years: bool,\n    extrapolate_first_point: bool,\n    extrapolate_last_point: bool,\n) -&gt; None:\n    \"\"\"\n    Initialize the ListTimeIndex class.\n\n    Args:\n        datetime_list (list[datetime]): List of datetime objects defining the time index. Must be ordered and contain more than one element.\n        is_52_week_years (bool): Whether to use 52-week years. If False, full iso calendar years are used.\n        extrapolate_first_point (bool): Whether to extrapolate the first point.\n        extrapolate_last_point (bool): Whether to extrapolate the last point.\n\n    Raises:\n        ValueError: If datetime_list has less than two elements or is not ordered.\n\n    \"\"\"\n    dts = datetime_list\n    if len(dts) &lt;= 1:\n        msg = f\"datetime_list must contain more than one element. Got {datetime_list}\"\n        raise ValueError(msg)\n    if not all(dts[i] &lt; dts[i + 1] for i in range(len(dts) - 1)):\n        msg = f\"All elements of datetime_list must be smaller/lower than the succeeding element. Dates must be ordered. Got {datetime_list}.\"\n        raise ValueError(msg)\n    if len(set(dt.tzinfo for dt in dts if dt is not None)) &gt; 1:\n        msg = f\"Datetime objects in datetime_list have differing time zone information: {set(dt.tzinfo for dt in dts if dt is not None)}\"\n        raise ValueError(msg)\n    if is_52_week_years and any(dts[i].isocalendar().week == 53 for i in range(len(dts))):  # noqa: PLR2004\n        msg = \"When is_52_week_years is True, datetime_list should not contain week 53 datetimes.\"\n        raise ValueError(msg)\n\n    self._datetime_list = datetime_list\n    self._is_52_week_years = is_52_week_years\n    self._extrapolate_first_point = extrapolate_first_point\n    self._extrapolate_last_point = extrapolate_last_point\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return the string representation of the ListTimeIndex.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the string representation of the ListTimeIndex.\"\"\"\n    return (\n        \"ListTimeIndex(\"\n        f\"datetimelist={self._datetime_list}, \"\n        f\"extrapolate_first_point={self._extrapolate_first_point}, \"\n        f\"extrapolate_last_point={self._extrapolate_last_point})\"\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.extrapolate_first_point","title":"<code>extrapolate_first_point() -&gt; bool</code>","text":"<p>Check if the TimeIndex should extrapolate the first point.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def extrapolate_first_point(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex should extrapolate the first point.\"\"\"\n    return self._extrapolate_first_point\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.extrapolate_last_point","title":"<code>extrapolate_last_point() -&gt; bool</code>","text":"<p>Check if the TimeIndex should extrapolate the last point.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def extrapolate_last_point(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex should extrapolate the last point.\"\"\"\n    return self._extrapolate_last_point\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.get_datetime_list","title":"<code>get_datetime_list() -&gt; list[datetime]</code>","text":"<p>Get a list of all periods (num_periods + 1 datetimes).</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def get_datetime_list(self) -&gt; list[datetime]:\n    \"\"\"Get a list of all periods (num_periods + 1 datetimes).\"\"\"\n    return self._datetime_list.copy()\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the fingerprint of the ListTimeIndex.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the fingerprint of the ListTimeIndex.\"\"\"\n    fingerprint = Fingerprint()\n    fingerprint.add(\"datetime_list\", self._datetime_list)\n    fingerprint.add(\"is_52_week_years\", self._is_52_week_years)\n    fingerprint.add(\"extrapolate_first_point\", self._extrapolate_first_point)\n    fingerprint.add(\"extrapolate_last_point\", self._extrapolate_last_point)\n    return fingerprint\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.get_num_periods","title":"<code>get_num_periods() -&gt; int</code>","text":"<p>Get the number of periods in the TimeIndex.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def get_num_periods(self) -&gt; int:\n    \"\"\"Get the number of periods in the TimeIndex.\"\"\"\n    return len(self._datetime_list) - 1\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.get_period_average","title":"<code>get_period_average(vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float</code>","text":"<p>Get the average over the period from the vector.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def get_period_average(self, vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float:\n    \"\"\"Get the average over the period from the vector.\"\"\"\n    self._check_type(vector, np.ndarray)\n    self._check_type(start_time, datetime)\n    self._check_type(duration, timedelta)\n    self._check_type(is_52_week_years, bool)\n\n    if vector.shape != (self.get_num_periods(),):\n        msg = f\"Vector shape {vector.shape} does not match number of periods {self.get_num_periods()} of timeindex ({self}).\"\n        raise ValueError(msg)\n\n    if not self.extrapolate_first_point():\n        if start_time &lt; self._datetime_list[0]:\n            msg = f\"start_time {start_time} is before start of timeindex {self._datetime_list[0]}, and extrapolate_first_point is False.\"\n            raise ValueError(msg)\n        if (start_time + duration) &lt; self._datetime_list[0]:\n            msg = f\"End time {start_time + duration} is before start of timeindex {self._datetime_list[0]}, and extrapolate_first_point is False.\"\n            raise ValueError(msg)\n\n    if not self.extrapolate_last_point():\n        if (start_time + duration) &gt; self._datetime_list[-1]:\n            msg = f\"End time {start_time + duration} is after end of timeindex {self._datetime_list[-1]}, and extrapolate_last_point is False.\"\n            raise ValueError(msg)\n        if start_time &gt; self._datetime_list[-1]:\n            msg = f\"start_time {start_time} is after end of timeindex {self._datetime_list[-1]}, and extrapolate_last_point is False.\"\n            raise ValueError(msg)\n\n    target_timeindex = FixedFrequencyTimeIndex(\n        start_time=start_time,\n        period_duration=duration,\n        num_periods=1,\n        is_52_week_years=is_52_week_years,\n        extrapolate_first_point=self.extrapolate_first_point(),\n        extrapolate_last_point=self.extrapolate_last_point(),\n    )\n\n    target_vector = np.zeros(1, dtype=vector.dtype)\n    self.write_into_fixed_frequency(\n        target_vector=target_vector,\n        target_timeindex=target_timeindex,\n        input_vector=vector,\n    )\n    return target_vector[0]\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.get_timezone","title":"<code>get_timezone() -&gt; tzinfo | None</code>","text":"<p>Get the timezone of the TimeIndex.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def get_timezone(self) -&gt; tzinfo | None:\n    \"\"\"Get the timezone of the TimeIndex.\"\"\"\n    return self._datetime_list[0].tzinfo\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.is_52_week_years","title":"<code>is_52_week_years() -&gt; bool</code>","text":"<p>Check if the TimeIndex is based on 52-week years.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def is_52_week_years(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex is based on 52-week years.\"\"\"\n    return self._is_52_week_years\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.is_constant","title":"<code>is_constant() -&gt; bool</code>","text":"<p>Return True if the time index is constant (single period and both extrapolation flags are True).</p>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.is_constant--returns","title":"Returns","text":"<p>bool     True if the time index is constant, False otherwise.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def is_constant(self) -&gt; bool:\n    \"\"\"\n    Return True if the time index is constant (single period and both extrapolation flags are True).\n\n    Returns\n    -------\n    bool\n        True if the time index is constant, False otherwise.\n\n    \"\"\"\n    return self.get_num_periods() == 1 and self.extrapolate_first_point() == self.extrapolate_last_point() is True\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.is_one_year","title":"<code>is_one_year() -&gt; bool</code>","text":"<p>Return True if exactly one whole year.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def is_one_year(self) -&gt; bool:\n    \"\"\"Return True if exactly one whole year.\"\"\"\n    if self._extrapolate_first_point or self._extrapolate_last_point:\n        return False\n    start_time = self._datetime_list[0]\n    stop_time = self._datetime_list[-1]\n    start_year, start_week, start_weekday = start_time.isocalendar()\n\n    if not start_weekday == start_week == 1:\n        return False\n\n    if self._is_52_week_years:\n        expected_stop_time = start_time + timedelta(weeks=52)\n        if expected_stop_time.isocalendar().week == 53:  # noqa: PLR2004\n            expected_stop_time += timedelta(weeks=1)\n        return stop_time == expected_stop_time\n\n    stop_year, stop_week, stop_weekday = stop_time.isocalendar()\n    return (start_year + 1 == stop_year) and (stop_weekday == stop_week == 1)\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.is_whole_years","title":"<code>is_whole_years() -&gt; bool</code>","text":"<p>Return True if index covers one or more full years.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def is_whole_years(self) -&gt; bool:\n    \"\"\"Return True if index covers one or more full years.\"\"\"\n    start_time = self._datetime_list[0]\n    _, start_week, start_weekday = start_time.isocalendar()\n\n    if not start_week == start_weekday == 1:\n        return False\n\n    stop_time = self._datetime_list[-1]\n\n    if not self.is_52_week_years():\n        _, stop_week, stop_weekday = stop_time.isocalendar()\n        return stop_week == stop_weekday == 1\n\n    total_period = self.total_duration()\n    total_seconds = int(total_period.total_seconds())\n    seconds_per_year = 52 * 7 * 24 * 3600\n\n    return total_seconds % seconds_per_year == 0\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.total_duration","title":"<code>total_duration() -&gt; timedelta</code>","text":"<p>Return the total duration covered by the time index.</p>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.total_duration--returns","title":"Returns","text":"<p>timedelta     The duration from the first to the last datetime in the index, skipping all weeks 53 periods if 52-week time format.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def total_duration(self) -&gt; timedelta:\n    \"\"\"\n    Return the total duration covered by the time index.\n\n    Returns\n    -------\n    timedelta\n        The duration from the first to the last datetime in the index, skipping all weeks 53 periods if 52-week time format.\n\n    \"\"\"\n    start_time = self._datetime_list[0]\n    end_time = self._datetime_list[-1]\n    return period_duration(start_time, end_time, self.is_52_week_years())\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ListTimeIndex.ListTimeIndex.write_into_fixed_frequency","title":"<code>write_into_fixed_frequency(target_vector: NDArray, target_timeindex: FixedFrequencyTimeIndex, input_vector: NDArray) -&gt; None</code>","text":"<p>Write the input vector into the target vector using the target FixedFrequencyTimeIndex.</p> Source code in <code>framcore/timeindexes/ListTimeIndex.py</code> <pre><code>def write_into_fixed_frequency(\n    self,\n    target_vector: NDArray,\n    target_timeindex: FixedFrequencyTimeIndex,\n    input_vector: NDArray,\n) -&gt; None:\n    \"\"\"Write the input vector into the target vector using the target FixedFrequencyTimeIndex.\"\"\"\n    self._check_type(target_vector, np.ndarray)\n    self._check_type(target_timeindex, FixedFrequencyTimeIndex)\n    self._check_type(input_vector, np.ndarray)\n\n    dts: list[datetime] = self._datetime_list\n\n    durations = set(self._microseconds(period_duration(dts[i], dts[i + 1], self._is_52_week_years)) for i in range(len(dts) - 1))\n    smallest_common_period_duration = functools.reduce(math.gcd, durations)\n\n    num_periods_ff = self._microseconds(self.total_duration()) // smallest_common_period_duration\n    input_vector_ff = np.zeros(num_periods_ff, dtype=target_vector.dtype)\n\n    i_start_ff = 0\n    for i in range(len(dts) - 1):\n        num_periods = self._microseconds(period_duration(dts[i], dts[i + 1], self._is_52_week_years)) // smallest_common_period_duration\n        i_stop_ff = i_start_ff + num_periods\n        input_vector_ff[i_start_ff:i_stop_ff] = input_vector[i]\n        i_start_ff = i_stop_ff\n\n    input_timeindex_ff = FixedFrequencyTimeIndex(\n        start_time=dts[0],\n        num_periods=num_periods_ff,\n        period_duration=timedelta(microseconds=smallest_common_period_duration),\n        is_52_week_years=self.is_52_week_years(),\n        extrapolate_first_point=self.extrapolate_first_point(),\n        extrapolate_last_point=self.extrapolate_last_point(),\n    )\n\n    input_timeindex_ff.write_into_fixed_frequency(\n        target_vector=target_vector,\n        target_timeindex=target_timeindex,\n        input_vector=input_vector_ff,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ModelYear","title":"<code>ModelYear</code>","text":""},{"location":"reference/#framcore.timeindexes.ModelYear.ModelYear","title":"<code>ModelYear</code>","text":"<p>               Bases: <code>SinglePeriodTimeIndex</code></p> <p>ModelYear represent a period of 52 weeks starting from the iso calendar week 1 of a specified year. No extrapolation.</p> Source code in <code>framcore/timeindexes/ModelYear.py</code> <pre><code>class ModelYear(SinglePeriodTimeIndex):\n    \"\"\"ModelYear represent a period of 52 weeks starting from the iso calendar week 1 of a specified year. No extrapolation.\"\"\"\n\n    def __init__(self, year: int) -&gt; None:\n        \"\"\"\n        Initialize ModelYear to a period of 52 weeks starting from the iso calendar week 1 of the specified year. No extrapolation.\n\n        Args:\n            year (int): Year to represent.\n\n        \"\"\"\n        super().__init__(\n            start_time=datetime.fromisocalendar(year, 1, 1),\n            period_duration=timedelta(weeks=52),\n            is_52_week_years=True,\n            extrapolate_first_point=False,\n            extrapolate_last_point=False,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ModelYear.ModelYear.__init__","title":"<code>__init__(year: int) -&gt; None</code>","text":"<p>Initialize ModelYear to a period of 52 weeks starting from the iso calendar week 1 of the specified year. No extrapolation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year to represent.</p> required Source code in <code>framcore/timeindexes/ModelYear.py</code> <pre><code>def __init__(self, year: int) -&gt; None:\n    \"\"\"\n    Initialize ModelYear to a period of 52 weeks starting from the iso calendar week 1 of the specified year. No extrapolation.\n\n    Args:\n        year (int): Year to represent.\n\n    \"\"\"\n    super().__init__(\n        start_time=datetime.fromisocalendar(year, 1, 1),\n        period_duration=timedelta(weeks=52),\n        is_52_week_years=True,\n        extrapolate_first_point=False,\n        extrapolate_last_point=False,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ModelYears","title":"<code>ModelYears</code>","text":""},{"location":"reference/#framcore.timeindexes.ModelYears.ModelYears","title":"<code>ModelYears</code>","text":"<p>               Bases: <code>ListTimeIndex</code></p> <p>ModelYears represents a collection of years as a ListTimeIndex. Extrapolation is enabled and full iso calendar is used.</p> Source code in <code>framcore/timeindexes/ModelYears.py</code> <pre><code>class ModelYears(ListTimeIndex):\n    \"\"\"ModelYears represents a collection of years as a ListTimeIndex. Extrapolation is enabled and full iso calendar is used.\"\"\"\n\n    def __init__(self, years: list[int]) -&gt; None:\n        \"\"\"\n        Initialize ModelYears with a list of years.\n\n        Args:\n            years (list[int]): List of years to represent.\n\n        \"\"\"\n        if not years:\n            raise ValueError(\"At least one year must be provided.\")\n\n        datetime_list = [datetime.fromisocalendar(year, 1, 1) for year in years]\n        datetime_list.append(datetime.fromisocalendar(years[-1] + 1, 1, 1))\n        super().__init__(\n            datetime_list=datetime_list,\n            is_52_week_years=False,\n            extrapolate_first_point=True,\n            extrapolate_last_point=True,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ModelYears.ModelYears.__init__","title":"<code>__init__(years: list[int]) -&gt; None</code>","text":"<p>Initialize ModelYears with a list of years.</p> <p>Parameters:</p> Name Type Description Default <code>years</code> <code>list[int]</code> <p>List of years to represent.</p> required Source code in <code>framcore/timeindexes/ModelYears.py</code> <pre><code>def __init__(self, years: list[int]) -&gt; None:\n    \"\"\"\n    Initialize ModelYears with a list of years.\n\n    Args:\n        years (list[int]): List of years to represent.\n\n    \"\"\"\n    if not years:\n        raise ValueError(\"At least one year must be provided.\")\n\n    datetime_list = [datetime.fromisocalendar(year, 1, 1) for year in years]\n    datetime_list.append(datetime.fromisocalendar(years[-1] + 1, 1, 1))\n    super().__init__(\n        datetime_list=datetime_list,\n        is_52_week_years=False,\n        extrapolate_first_point=True,\n        extrapolate_last_point=True,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.OneYearProfileTimeIndex","title":"<code>OneYearProfileTimeIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.OneYearProfileTimeIndex.OneYearProfileTimeIndex","title":"<code>OneYearProfileTimeIndex</code>","text":"<p>               Bases: <code>ProfileTimeIndex</code></p> <p>ProfileTimeIndex with fixed frequency over one year of either 52 or 53 weeks. No extrapolation inherited from ProfileTimeIndex.</p> <p>Attributes:</p> Name Type Description <code>period_duration</code> <code>timedelta</code> <p>Duration of each period.</p> <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years.</p> Source code in <code>framcore/timeindexes/OneYearProfileTimeIndex.py</code> <pre><code>class OneYearProfileTimeIndex(ProfileTimeIndex):\n    \"\"\"\n    ProfileTimeIndex with fixed frequency over one year of either 52 or 53 weeks. No extrapolation inherited from ProfileTimeIndex.\n\n    Attributes:\n        period_duration (timedelta): Duration of each period.\n        is_52_week_years (bool): Whether to use 52-week years.\n\n    \"\"\"\n\n    def __init__(self, period_duration: timedelta, is_52_week_years: bool) -&gt; None:\n        \"\"\"\n        Initialize a ProfileTimeIndex with a fixed frequency over one year.\n\n        If is_52_week_years is True, the period_duration must divide evenly into 52 weeks. If False, it must divide evenly into 53 weeks.\n        We use 1982 for 52-week years and 1981 for 53-week years.\n\n        Args:\n            period_duration (timedelta): Duration of each period.\n            is_52_week_years (bool): Whether to use 52-week years.\n\n        \"\"\"\n        year = 1982 if is_52_week_years else 1981\n        super().__init__(year, 1, period_duration, is_52_week_years)\n</code></pre>"},{"location":"reference/#framcore.timeindexes.OneYearProfileTimeIndex.OneYearProfileTimeIndex.__init__","title":"<code>__init__(period_duration: timedelta, is_52_week_years: bool) -&gt; None</code>","text":"<p>Initialize a ProfileTimeIndex with a fixed frequency over one year.</p> <p>If is_52_week_years is True, the period_duration must divide evenly into 52 weeks. If False, it must divide evenly into 53 weeks. We use 1982 for 52-week years and 1981 for 53-week years.</p> <p>Parameters:</p> Name Type Description Default <code>period_duration</code> <code>timedelta</code> <p>Duration of each period.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years.</p> required Source code in <code>framcore/timeindexes/OneYearProfileTimeIndex.py</code> <pre><code>def __init__(self, period_duration: timedelta, is_52_week_years: bool) -&gt; None:\n    \"\"\"\n    Initialize a ProfileTimeIndex with a fixed frequency over one year.\n\n    If is_52_week_years is True, the period_duration must divide evenly into 52 weeks. If False, it must divide evenly into 53 weeks.\n    We use 1982 for 52-week years and 1981 for 53-week years.\n\n    Args:\n        period_duration (timedelta): Duration of each period.\n        is_52_week_years (bool): Whether to use 52-week years.\n\n    \"\"\"\n    year = 1982 if is_52_week_years else 1981\n    super().__init__(year, 1, period_duration, is_52_week_years)\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ProfileTimeIndex","title":"<code>ProfileTimeIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.ProfileTimeIndex.ProfileTimeIndex","title":"<code>ProfileTimeIndex</code>","text":"<p>               Bases: <code>FixedFrequencyTimeIndex</code></p> <p>ProfileTimeIndex represent one or more whole years with fixed time resolution standard. No extrapolation.</p> Source code in <code>framcore/timeindexes/ProfileTimeIndex.py</code> <pre><code>class ProfileTimeIndex(FixedFrequencyTimeIndex):\n    \"\"\"ProfileTimeIndex represent one or more whole years with fixed time resolution standard. No extrapolation.\"\"\"\n\n    def __init__(\n        self,\n        start_year: int,\n        num_years: int,\n        period_duration: timedelta,\n        is_52_week_years: bool,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ProfileTimeIndex. No extrapolation.\n\n        Args:\n            start_year (int): First year in the index.\n            num_years (int): Number of years in the index.\n            period_duration (timedelta): Duration of each period in the index.\n            is_52_week_years (bool): Whether to use 52-week years. If False, full iso calendar years are used.\n\n        \"\"\"\n        start_time = datetime.fromisocalendar(start_year, 1, 1)\n        if not is_52_week_years:\n            stop_time = datetime.fromisocalendar(start_year + num_years, 1, 1)\n            num_periods = (stop_time - start_time).total_seconds() / period_duration.total_seconds()\n        else:\n            num_periods = timedelta(weeks=52 * num_years).total_seconds() / period_duration.total_seconds()\n        if not num_periods.is_integer():\n            msg = f\"Number of periods derived from input arguments must be an integer/whole number. Got {num_periods}.\"\n            raise ValueError(msg)\n        num_periods = int(num_periods)\n        super().__init__(\n            start_time=start_time,\n            period_duration=period_duration,\n            num_periods=num_periods,\n            is_52_week_years=is_52_week_years,\n            extrapolate_first_point=False,\n            extrapolate_last_point=False,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.ProfileTimeIndex.ProfileTimeIndex.__init__","title":"<code>__init__(start_year: int, num_years: int, period_duration: timedelta, is_52_week_years: bool) -&gt; None</code>","text":"<p>Initialize the ProfileTimeIndex. No extrapolation.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <code>int</code> <p>First year in the index.</p> required <code>num_years</code> <code>int</code> <p>Number of years in the index.</p> required <code>period_duration</code> <code>timedelta</code> <p>Duration of each period in the index.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years. If False, full iso calendar years are used.</p> required Source code in <code>framcore/timeindexes/ProfileTimeIndex.py</code> <pre><code>def __init__(\n    self,\n    start_year: int,\n    num_years: int,\n    period_duration: timedelta,\n    is_52_week_years: bool,\n) -&gt; None:\n    \"\"\"\n    Initialize the ProfileTimeIndex. No extrapolation.\n\n    Args:\n        start_year (int): First year in the index.\n        num_years (int): Number of years in the index.\n        period_duration (timedelta): Duration of each period in the index.\n        is_52_week_years (bool): Whether to use 52-week years. If False, full iso calendar years are used.\n\n    \"\"\"\n    start_time = datetime.fromisocalendar(start_year, 1, 1)\n    if not is_52_week_years:\n        stop_time = datetime.fromisocalendar(start_year + num_years, 1, 1)\n        num_periods = (stop_time - start_time).total_seconds() / period_duration.total_seconds()\n    else:\n        num_periods = timedelta(weeks=52 * num_years).total_seconds() / period_duration.total_seconds()\n    if not num_periods.is_integer():\n        msg = f\"Number of periods derived from input arguments must be an integer/whole number. Got {num_periods}.\"\n        raise ValueError(msg)\n    num_periods = int(num_periods)\n    super().__init__(\n        start_time=start_time,\n        period_duration=period_duration,\n        num_periods=num_periods,\n        is_52_week_years=is_52_week_years,\n        extrapolate_first_point=False,\n        extrapolate_last_point=False,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.SinglePeriodTimeIndex","title":"<code>SinglePeriodTimeIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.SinglePeriodTimeIndex.SinglePeriodTimeIndex","title":"<code>SinglePeriodTimeIndex</code>","text":"<p>               Bases: <code>FixedFrequencyTimeIndex</code></p> <p>FixedFrequencyTimeIndex with just one single step.</p> Source code in <code>framcore/timeindexes/SinglePeriodTimeIndex.py</code> <pre><code>class SinglePeriodTimeIndex(FixedFrequencyTimeIndex):\n    \"\"\"FixedFrequencyTimeIndex with just one single step.\"\"\"\n\n    def __init__(\n        self,\n        start_time: datetime,\n        period_duration: timedelta,\n        is_52_week_years: bool = False,\n        extrapolate_first_point: bool = False,\n        extrapolate_last_point: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a SinglePeriodTimeIndex with a single time period.\n\n        Args:\n            start_time (datetime): The start time of the period.\n            period_duration (timedelta): The duration of the period.\n            is_52_week_years (bool, optional): Whether to use 52-week years. Defaults to False.\n            extrapolate_first_point (bool, optional): Whether to extrapolate the first point. Defaults to False.\n            extrapolate_last_point (bool, optional): Whether to extrapolate the last point. Defaults to False.\n\n        \"\"\"\n        super().__init__(\n            start_time=start_time,\n            period_duration=period_duration,\n            num_periods=1,\n            is_52_week_years=is_52_week_years,\n            extrapolate_first_point=extrapolate_first_point,\n            extrapolate_last_point=extrapolate_last_point,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.SinglePeriodTimeIndex.SinglePeriodTimeIndex.__init__","title":"<code>__init__(start_time: datetime, period_duration: timedelta, is_52_week_years: bool = False, extrapolate_first_point: bool = False, extrapolate_last_point: bool = False) -&gt; None</code>","text":"<p>Initialize a SinglePeriodTimeIndex with a single time period.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>datetime</code> <p>The start time of the period.</p> required <code>period_duration</code> <code>timedelta</code> <p>The duration of the period.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years. Defaults to False.</p> <code>False</code> <code>extrapolate_first_point</code> <code>bool</code> <p>Whether to extrapolate the first point. Defaults to False.</p> <code>False</code> <code>extrapolate_last_point</code> <code>bool</code> <p>Whether to extrapolate the last point. Defaults to False.</p> <code>False</code> Source code in <code>framcore/timeindexes/SinglePeriodTimeIndex.py</code> <pre><code>def __init__(\n    self,\n    start_time: datetime,\n    period_duration: timedelta,\n    is_52_week_years: bool = False,\n    extrapolate_first_point: bool = False,\n    extrapolate_last_point: bool = False,\n) -&gt; None:\n    \"\"\"\n    Initialize a SinglePeriodTimeIndex with a single time period.\n\n    Args:\n        start_time (datetime): The start time of the period.\n        period_duration (timedelta): The duration of the period.\n        is_52_week_years (bool, optional): Whether to use 52-week years. Defaults to False.\n        extrapolate_first_point (bool, optional): Whether to extrapolate the first point. Defaults to False.\n        extrapolate_last_point (bool, optional): Whether to extrapolate the last point. Defaults to False.\n\n    \"\"\"\n    super().__init__(\n        start_time=start_time,\n        period_duration=period_duration,\n        num_periods=1,\n        is_52_week_years=is_52_week_years,\n        extrapolate_first_point=extrapolate_first_point,\n        extrapolate_last_point=extrapolate_last_point,\n    )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex","title":"<code>TimeIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex","title":"<code>TimeIndex</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>TimeIndex interface for TimeVectors.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>class TimeIndex(Base, ABC):\n    \"\"\"TimeIndex interface for TimeVectors.\"\"\"\n\n    @abstractmethod\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Check if two TimeIndexes are equal.\"\"\"\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute hash value..\"\"\"\n        pass\n\n    @abstractmethod\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the fingerprint of the TimeIndex.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_timezone(self) -&gt; tzinfo | None:\n        \"\"\"Get the timezone of the TimeIndex.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_num_periods(self) -&gt; bool:\n        \"\"\"Get the number of periods in the TimeIndex.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_52_week_years(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex is based on 52-week years.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_one_year(self) -&gt; bool:\n        \"\"\"\n        Check if the TimeIndex represents a single year.\n\n        Must be False if extrapolate_first_point and or extrapolate_last_point is True.\n\n        When True, can be repeted in profiles.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_whole_years(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex represents whole years.\"\"\"\n        pass\n\n    @abstractmethod\n    def extrapolate_first_point(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex should extrapolate the first point. Must be False if is_one_year is True.\"\"\"\n        pass\n\n    @abstractmethod\n    def extrapolate_last_point(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex should extrapolate the last point. Must be False if is_one_year is True.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_period_average(self, vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float:\n        \"\"\"Get the average over the period from the vector.\"\"\"\n        pass\n\n    @abstractmethod\n    def write_into_fixed_frequency(\n        self,\n        target_vector: NDArray,\n        target_timeindex: FixedFrequencyTimeIndex,\n        input_vector: NDArray,\n    ) -&gt; None:\n        \"\"\"\n        Write the input vector into the target vector based on the target FixedFrequencyTimeIndex.\n\n        Main functionality in FRAM to extracts data to the correct time period and resolution.\n        A conversion of the data into a specific time period and resolution follows these steps:\n        - If the TimeIndex is not a FixedFrequencyTimeIndex, convert the TimeIndex and the vector to this format.\n        - Then convert the data according to the target TimeIndex.\n        - It is easier to efficiently do time series operations between FixedFrequencyTimeIndex\n            and we only need to implement all the other conversion functionality once here.\n            For example, converting between 52-week and ISO-time TimeVectors, selecting a period, extrapolation or changing the resolution.\n        - And when we implement a new TimeIndex, we only need to implement the conversion to FixedFrequencyTimeIndex\n            and the rest of the conversion functionality can be reused.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_constant(self) -&gt; bool:\n        \"\"\"Check if the TimeIndex is constant.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.__eq__","title":"<code>__eq__(other) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if two TimeIndexes are equal.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Check if two TimeIndexes are equal.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.__hash__","title":"<code>__hash__() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Compute hash value..</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef __hash__(self) -&gt; int:\n    \"\"\"Compute hash value..\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.extrapolate_first_point","title":"<code>extrapolate_first_point() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if the TimeIndex should extrapolate the first point. Must be False if is_one_year is True.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef extrapolate_first_point(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex should extrapolate the first point. Must be False if is_one_year is True.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.extrapolate_last_point","title":"<code>extrapolate_last_point() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if the TimeIndex should extrapolate the last point. Must be False if is_one_year is True.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef extrapolate_last_point(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex should extrapolate the last point. Must be False if is_one_year is True.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>  <code>abstractmethod</code>","text":"<p>Get the fingerprint of the TimeIndex.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the fingerprint of the TimeIndex.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.get_num_periods","title":"<code>get_num_periods() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Get the number of periods in the TimeIndex.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef get_num_periods(self) -&gt; bool:\n    \"\"\"Get the number of periods in the TimeIndex.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.get_period_average","title":"<code>get_period_average(vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Get the average over the period from the vector.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef get_period_average(self, vector: NDArray, start_time: datetime, duration: timedelta, is_52_week_years: bool) -&gt; float:\n    \"\"\"Get the average over the period from the vector.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.get_timezone","title":"<code>get_timezone() -&gt; tzinfo | None</code>  <code>abstractmethod</code>","text":"<p>Get the timezone of the TimeIndex.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef get_timezone(self) -&gt; tzinfo | None:\n    \"\"\"Get the timezone of the TimeIndex.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.is_52_week_years","title":"<code>is_52_week_years() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if the TimeIndex is based on 52-week years.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef is_52_week_years(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex is based on 52-week years.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.is_constant","title":"<code>is_constant() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if the TimeIndex is constant.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef is_constant(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex is constant.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.is_one_year","title":"<code>is_one_year() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if the TimeIndex represents a single year.</p> <p>Must be False if extrapolate_first_point and or extrapolate_last_point is True.</p> <p>When True, can be repeted in profiles.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef is_one_year(self) -&gt; bool:\n    \"\"\"\n    Check if the TimeIndex represents a single year.\n\n    Must be False if extrapolate_first_point and or extrapolate_last_point is True.\n\n    When True, can be repeted in profiles.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.is_whole_years","title":"<code>is_whole_years() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if the TimeIndex represents whole years.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef is_whole_years(self) -&gt; bool:\n    \"\"\"Check if the TimeIndex represents whole years.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.TimeIndex.TimeIndex.write_into_fixed_frequency","title":"<code>write_into_fixed_frequency(target_vector: NDArray, target_timeindex: FixedFrequencyTimeIndex, input_vector: NDArray) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Write the input vector into the target vector based on the target FixedFrequencyTimeIndex.</p> <p>Main functionality in FRAM to extracts data to the correct time period and resolution. A conversion of the data into a specific time period and resolution follows these steps: - If the TimeIndex is not a FixedFrequencyTimeIndex, convert the TimeIndex and the vector to this format. - Then convert the data according to the target TimeIndex. - It is easier to efficiently do time series operations between FixedFrequencyTimeIndex     and we only need to implement all the other conversion functionality once here.     For example, converting between 52-week and ISO-time TimeVectors, selecting a period, extrapolation or changing the resolution. - And when we implement a new TimeIndex, we only need to implement the conversion to FixedFrequencyTimeIndex     and the rest of the conversion functionality can be reused.</p> Source code in <code>framcore/timeindexes/TimeIndex.py</code> <pre><code>@abstractmethod\ndef write_into_fixed_frequency(\n    self,\n    target_vector: NDArray,\n    target_timeindex: FixedFrequencyTimeIndex,\n    input_vector: NDArray,\n) -&gt; None:\n    \"\"\"\n    Write the input vector into the target vector based on the target FixedFrequencyTimeIndex.\n\n    Main functionality in FRAM to extracts data to the correct time period and resolution.\n    A conversion of the data into a specific time period and resolution follows these steps:\n    - If the TimeIndex is not a FixedFrequencyTimeIndex, convert the TimeIndex and the vector to this format.\n    - Then convert the data according to the target TimeIndex.\n    - It is easier to efficiently do time series operations between FixedFrequencyTimeIndex\n        and we only need to implement all the other conversion functionality once here.\n        For example, converting between 52-week and ISO-time TimeVectors, selecting a period, extrapolation or changing the resolution.\n    - And when we implement a new TimeIndex, we only need to implement the conversion to FixedFrequencyTimeIndex\n        and the rest of the conversion functionality can be reused.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timeindexes.WeeklyIndex","title":"<code>WeeklyIndex</code>","text":""},{"location":"reference/#framcore.timeindexes.WeeklyIndex.WeeklyIndex","title":"<code>WeeklyIndex</code>","text":"<p>               Bases: <code>ProfileTimeIndex</code></p> <p>ProfileTimeIndex with one or more whole years with weekly resolution. Either years with 52 weeks or full iso calendar years.</p> <p>No extrapolation inherited from ProfileTimeIndex.</p> Source code in <code>framcore/timeindexes/WeeklyIndex.py</code> <pre><code>class WeeklyIndex(ProfileTimeIndex):\n    \"\"\"\n    ProfileTimeIndex with one or more whole years with weekly resolution. Either years with 52 weeks or full iso calendar years.\n\n    No extrapolation inherited from ProfileTimeIndex.\n    \"\"\"\n\n    def __init__(\n        self,\n        start_year: int,\n        num_years: int,\n        is_52_week_years: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize WeeklyIndex with one or more whole years with weekly resolution. Either years with 52 weeks or full iso calendar years.\n\n        Args:\n            start_year (int): First year in the index.\n            num_years (int): Number of years in the index.\n            is_52_week_years (bool, optional): Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.\n\n        \"\"\"\n        super().__init__(\n            start_year=start_year,\n            num_years=num_years,\n            period_duration=timedelta(weeks=1),\n            is_52_week_years=is_52_week_years,\n        )\n</code></pre>"},{"location":"reference/#framcore.timeindexes.WeeklyIndex.WeeklyIndex.__init__","title":"<code>__init__(start_year: int, num_years: int, is_52_week_years: bool = True) -&gt; None</code>","text":"<p>Initialize WeeklyIndex with one or more whole years with weekly resolution. Either years with 52 weeks or full iso calendar years.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <code>int</code> <p>First year in the index.</p> required <code>num_years</code> <code>int</code> <p>Number of years in the index.</p> required <code>is_52_week_years</code> <code>bool</code> <p>Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.</p> <code>True</code> Source code in <code>framcore/timeindexes/WeeklyIndex.py</code> <pre><code>def __init__(\n    self,\n    start_year: int,\n    num_years: int,\n    is_52_week_years: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize WeeklyIndex with one or more whole years with weekly resolution. Either years with 52 weeks or full iso calendar years.\n\n    Args:\n        start_year (int): First year in the index.\n        num_years (int): Number of years in the index.\n        is_52_week_years (bool, optional): Whether to use 52-week years. If False, full iso calendar years are used. Defaults to True.\n\n    \"\"\"\n    super().__init__(\n        start_year=start_year,\n        num_years=num_years,\n        period_duration=timedelta(weeks=1),\n        is_52_week_years=is_52_week_years,\n    )\n</code></pre>"},{"location":"reference/#framcore.timevectors","title":"<code>timevectors</code>","text":""},{"location":"reference/#framcore.timevectors.ConstantTimeVector","title":"<code>ConstantTimeVector</code>","text":""},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector","title":"<code>ConstantTimeVector</code>","text":"<p>               Bases: <code>TimeVector</code></p> <p>ConstantTimeVector class for TimeVectors that are constant over time. Subclass of TimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>class ConstantTimeVector(TimeVector):\n    \"\"\"ConstantTimeVector class for TimeVectors that are constant over time. Subclass of TimeVector.\"\"\"\n\n    def __init__(\n        self,\n        scalar: float,\n        unit: str | None = None,\n        is_max_level: bool | None = None,\n        is_zero_one_profile: bool | None = None,\n        reference_period: ReferencePeriod | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ConstantTimeVector class.\n\n        Args:\n            scalar (float): Constant float value of the TimeVector.\n            unit (str | None): Unit of the value in the vector.\n            is_max_level (bool | None): Whether the vector represents the maximum level, average level given a\n                                        reference period, or not a level at all.\n            is_zero_one_profile (bool | None): Whether the vector represents a profile with values between 0 and 1, a\n                                               profile with values averaging to 1 over a given reference period, or is\n                                               not a profile.\n            reference_period (ReferencePeriod | None, optional): Given reference period if the vector represents average\n                                                                 level or mean one profile. Defaults to None.\n\n        Raises:\n            ValueError: When both is_max_level and is_zero_one_profile is not None. This would mean the TimeVector\n                        represents both a level and a profile, which is not allowed.\n\n        \"\"\"\n        self._scalar = float(scalar)\n        self._unit = unit\n        self._is_max_level = is_max_level\n        self._is_zero_one_profile = is_zero_one_profile\n        self._reference_period = reference_period\n\n        self._check_type(scalar, (float, np.float32))  # TODO: Accept np.float32 elsewhere aswell\n        self._check_type(unit, (str, type(None)))\n        self._check_type(is_max_level, (bool, type(None)))\n        self._check_type(is_zero_one_profile, (bool, type(None)))\n        self._check_type(reference_period, (ReferencePeriod, type(None)))\n\n        self._check_is_level_or_profile()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the string representation of the ConstantTimeVector.\"\"\"\n        ref_period = None\n        if self._reference_period is not None:\n            start_year = self._reference_period.get_start_year()\n            num_years = self._reference_period.get_num_years()\n            ref_period = f\"{start_year}-{start_year + num_years - 1}\"\n        unit = f\", unit={self._unit}\" if self._unit is not None else \"\"\n        ref_period = f\", reference_period={ref_period}\" if ref_period is not None else \"\"\n        is_max_level = f\", is_max_level={self._is_max_level}\"\n        return f\"ConstantTimeVector({self._scalar}{unit}{ref_period}{is_max_level})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality between two ConstantTimeVector objects.\"\"\"\n        if not isinstance(other, ConstantTimeVector):\n            return False\n        return (\n            self._scalar == other._scalar\n            and self._unit == other._unit\n            and self._is_max_level == other._is_max_level\n            and self._is_zero_one_profile == other._is_zero_one_profile\n            and self._reference_period == other._reference_period\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute the hash of the ConstantTimeVector.\"\"\"\n        return hash((self._scalar, self._unit, self._is_max_level, self._is_zero_one_profile, self._reference_period))\n\n    def get_expr_str(self) -&gt; str:\n        \"\"\"Simpler representation of self to show in Expr.\"\"\"\n        if self._unit:\n            return f\"{self._scalar} {self._unit}\"\n\n        return f\"{self._scalar}\"\n\n    def get_vector(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"Get the values of the TimeVector.\"\"\"\n        dtype = np.float32 if is_float32 else np.float64\n        out = np.zeros(1, dtype=dtype)\n        out[0] = self._scalar\n        return out\n\n    def get_timeindex(self) -&gt; ConstantTimeIndex:\n        \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n        return ConstantTimeIndex()\n\n    def is_constant(self) -&gt; bool:\n        \"\"\"Check if the TimeVector is constant.\"\"\"\n        return True\n\n    def is_max_level(self) -&gt; bool | None:\n        \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n        return self._is_max_level\n\n    def is_zero_one_profile(self) -&gt; bool | None:\n        \"\"\"Check if TimeVector is a profile with values between zero and one.\"\"\"\n        return self._is_zero_one_profile\n\n    def get_unit(self) -&gt; str | None:\n        \"\"\"Get the unit of the TimeVector.\"\"\"\n        return self._unit\n\n    def get_reference_period(self) -&gt; ReferencePeriod | None:\n        \"\"\"Get the reference period of the TimeVector.\"\"\"\n        if self._reference_period is not None:\n            return self._reference_period\n        if self.is_zero_one_profile() is False:\n            timeindex = self.get_timeindex()\n            return timeindex.get_reference_period()\n        return None\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the Fingerprint of the TimeVector.\"\"\"\n        return self.get_fingerprint_default()\n\n    def get_loader(self) -&gt; None:\n        \"\"\"Interface method Not applicable for this type. Return None.\"\"\"\n        return\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.__eq__","title":"<code>__eq__(other: object) -&gt; bool</code>","text":"<p>Check equality between two ConstantTimeVector objects.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality between two ConstantTimeVector objects.\"\"\"\n    if not isinstance(other, ConstantTimeVector):\n        return False\n    return (\n        self._scalar == other._scalar\n        and self._unit == other._unit\n        and self._is_max_level == other._is_max_level\n        and self._is_zero_one_profile == other._is_zero_one_profile\n        and self._reference_period == other._reference_period\n    )\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Compute the hash of the ConstantTimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute the hash of the ConstantTimeVector.\"\"\"\n    return hash((self._scalar, self._unit, self._is_max_level, self._is_zero_one_profile, self._reference_period))\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.__init__","title":"<code>__init__(scalar: float, unit: str | None = None, is_max_level: bool | None = None, is_zero_one_profile: bool | None = None, reference_period: ReferencePeriod | None = None) -&gt; None</code>","text":"<p>Initialize the ConstantTimeVector class.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>float</code> <p>Constant float value of the TimeVector.</p> required <code>unit</code> <code>str | None</code> <p>Unit of the value in the vector.</p> <code>None</code> <code>is_max_level</code> <code>bool | None</code> <p>Whether the vector represents the maximum level, average level given a                         reference period, or not a level at all.</p> <code>None</code> <code>is_zero_one_profile</code> <code>bool | None</code> <p>Whether the vector represents a profile with values between 0 and 1, a                                profile with values averaging to 1 over a given reference period, or is                                not a profile.</p> <code>None</code> <code>reference_period</code> <code>ReferencePeriod | None</code> <p>Given reference period if the vector represents average                                                  level or mean one profile. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When both is_max_level and is_zero_one_profile is not None. This would mean the TimeVector         represents both a level and a profile, which is not allowed.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def __init__(\n    self,\n    scalar: float,\n    unit: str | None = None,\n    is_max_level: bool | None = None,\n    is_zero_one_profile: bool | None = None,\n    reference_period: ReferencePeriod | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the ConstantTimeVector class.\n\n    Args:\n        scalar (float): Constant float value of the TimeVector.\n        unit (str | None): Unit of the value in the vector.\n        is_max_level (bool | None): Whether the vector represents the maximum level, average level given a\n                                    reference period, or not a level at all.\n        is_zero_one_profile (bool | None): Whether the vector represents a profile with values between 0 and 1, a\n                                           profile with values averaging to 1 over a given reference period, or is\n                                           not a profile.\n        reference_period (ReferencePeriod | None, optional): Given reference period if the vector represents average\n                                                             level or mean one profile. Defaults to None.\n\n    Raises:\n        ValueError: When both is_max_level and is_zero_one_profile is not None. This would mean the TimeVector\n                    represents both a level and a profile, which is not allowed.\n\n    \"\"\"\n    self._scalar = float(scalar)\n    self._unit = unit\n    self._is_max_level = is_max_level\n    self._is_zero_one_profile = is_zero_one_profile\n    self._reference_period = reference_period\n\n    self._check_type(scalar, (float, np.float32))  # TODO: Accept np.float32 elsewhere aswell\n    self._check_type(unit, (str, type(None)))\n    self._check_type(is_max_level, (bool, type(None)))\n    self._check_type(is_zero_one_profile, (bool, type(None)))\n    self._check_type(reference_period, (ReferencePeriod, type(None)))\n\n    self._check_is_level_or_profile()\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return the string representation of the ConstantTimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the string representation of the ConstantTimeVector.\"\"\"\n    ref_period = None\n    if self._reference_period is not None:\n        start_year = self._reference_period.get_start_year()\n        num_years = self._reference_period.get_num_years()\n        ref_period = f\"{start_year}-{start_year + num_years - 1}\"\n    unit = f\", unit={self._unit}\" if self._unit is not None else \"\"\n    ref_period = f\", reference_period={ref_period}\" if ref_period is not None else \"\"\n    is_max_level = f\", is_max_level={self._is_max_level}\"\n    return f\"ConstantTimeVector({self._scalar}{unit}{ref_period}{is_max_level})\"\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.get_expr_str","title":"<code>get_expr_str() -&gt; str</code>","text":"<p>Simpler representation of self to show in Expr.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def get_expr_str(self) -&gt; str:\n    \"\"\"Simpler representation of self to show in Expr.\"\"\"\n    if self._unit:\n        return f\"{self._scalar} {self._unit}\"\n\n    return f\"{self._scalar}\"\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the Fingerprint of the TimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the Fingerprint of the TimeVector.\"\"\"\n    return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.get_loader","title":"<code>get_loader() -&gt; None</code>","text":"<p>Interface method Not applicable for this type. Return None.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def get_loader(self) -&gt; None:\n    \"\"\"Interface method Not applicable for this type. Return None.\"\"\"\n    return\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.get_reference_period","title":"<code>get_reference_period() -&gt; ReferencePeriod | None</code>","text":"<p>Get the reference period of the TimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def get_reference_period(self) -&gt; ReferencePeriod | None:\n    \"\"\"Get the reference period of the TimeVector.\"\"\"\n    if self._reference_period is not None:\n        return self._reference_period\n    if self.is_zero_one_profile() is False:\n        timeindex = self.get_timeindex()\n        return timeindex.get_reference_period()\n    return None\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.get_timeindex","title":"<code>get_timeindex() -&gt; ConstantTimeIndex</code>","text":"<p>Get the TimeIndex of the TimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def get_timeindex(self) -&gt; ConstantTimeIndex:\n    \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n    return ConstantTimeIndex()\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.get_unit","title":"<code>get_unit() -&gt; str | None</code>","text":"<p>Get the unit of the TimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def get_unit(self) -&gt; str | None:\n    \"\"\"Get the unit of the TimeVector.\"\"\"\n    return self._unit\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.get_vector","title":"<code>get_vector(is_float32: bool) -&gt; NDArray</code>","text":"<p>Get the values of the TimeVector.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def get_vector(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"Get the values of the TimeVector.\"\"\"\n    dtype = np.float32 if is_float32 else np.float64\n    out = np.zeros(1, dtype=dtype)\n    out[0] = self._scalar\n    return out\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.is_constant","title":"<code>is_constant() -&gt; bool</code>","text":"<p>Check if the TimeVector is constant.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def is_constant(self) -&gt; bool:\n    \"\"\"Check if the TimeVector is constant.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.is_max_level","title":"<code>is_max_level() -&gt; bool | None</code>","text":"<p>Check if TimeVector is a level representing maximum Volume/Capacity.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def is_max_level(self) -&gt; bool | None:\n    \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n    return self._is_max_level\n</code></pre>"},{"location":"reference/#framcore.timevectors.ConstantTimeVector.ConstantTimeVector.is_zero_one_profile","title":"<code>is_zero_one_profile() -&gt; bool | None</code>","text":"<p>Check if TimeVector is a profile with values between zero and one.</p> Source code in <code>framcore/timevectors/ConstantTimeVector.py</code> <pre><code>def is_zero_one_profile(self) -&gt; bool | None:\n    \"\"\"Check if TimeVector is a profile with values between zero and one.\"\"\"\n    return self._is_zero_one_profile\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector","title":"<code>LinearTransformTimeVector</code>","text":""},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector","title":"<code>LinearTransformTimeVector</code>","text":"<p>               Bases: <code>TimeVector</code></p> <p>LinearTransformTimeVector represents a TimeVector as scale * timevector + shift. Immutable.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>class LinearTransformTimeVector(TimeVector):\n    \"\"\"LinearTransformTimeVector represents a TimeVector as scale * timevector + shift. Immutable.\"\"\"\n\n    def __init__(\n        self,\n        timevector: TimeVector,\n        scale: float,\n        shift: float,\n        unit: str | None,\n        is_max_level: bool | None = None,\n        is_zero_one_profile: bool | None = None,\n        reference_period: ReferencePeriod | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize LinearTransformTimeVector with a TimeVector, scale and shift.\n\n        May also override unit, is_max_level,  is_zero_one_profile and reference_period of the original timevector.\n\n        Args:\n            timevector (TimeVector): TimeVector.\n            scale (float): Scale factor.\n            shift (float): Shift value.\n            unit (str | None): Unit of the values in the transformed vector.\n            is_max_level (bool | None, optional): Whether the transformed vector represents the maximum level,\n                                                  average level given a reference period, or not a level at all.\n                                                  Defaults to None.\n            is_zero_one_profile (bool | None, optional): Whether the transformed vector represents a profile with values\n                                                        between 0 and 1, a profile with values averaging to 1 over a given\n                                                        reference period, or is not a profile. Defaults to None.\n            reference_period (ReferencePeriod | None, optional): Given reference period if the transformed vector\n                                                                 represents average level or mean one profile. Defaults to None.\n\n        \"\"\"\n        self._check_type(timevector, TimeVector)\n        self._check_type(scale, float)\n        self._check_type(shift, float)\n        self._check_type(unit, (str, type(None)))\n        self._check_type(is_max_level, (bool, type(None)))\n        self._check_type(is_zero_one_profile, (bool, type(None)))\n        self._check_type(reference_period, (ReferencePeriod, type(None)))\n        self._timevector = timevector\n        self._scale = scale\n        self._shift = shift\n        self._unit = unit\n        self._is_max_level = is_max_level\n        self._is_zero_one_profile = is_zero_one_profile\n        self._reference_period = reference_period\n\n        self._check_is_level_or_profile()\n\n    def get_vector(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"Get the values of the TimeVector.\"\"\"\n        vector = self._timevector.get_vector(is_float32)\n        if self._scale == 1.0 and self._shift == 0.0:\n            return vector\n        out = vector.copy()\n        if self._scale != 1.0:\n            np.multiply(out, self._scale, out=out)\n        if self._shift != 0.0:\n            np.add(out, self._shift, out=out)\n        return out\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the Fingerprint of the TimeVector.\"\"\"\n        return self.get_fingerprint_default()\n\n    def get_timeindex(self) -&gt; ConstantTimeIndex:\n        \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n        return self._timevector.get_timeindex()\n\n    def is_constant(self) -&gt; bool:\n        \"\"\"Check if the TimeVector is constant.\"\"\"\n        return self._timevector.is_constant()\n\n    def is_max_level(self) -&gt; bool | None:\n        \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n        return self._is_max_level\n\n    def is_zero_one_profile(self) -&gt; bool | None:\n        \"\"\"Check if TimeVector is a profile with values between zero and one.\"\"\"\n        return self._is_zero_one_profile\n\n    def get_unit(self) -&gt; str | None:\n        \"\"\"Get the unit of the TimeVector.\"\"\"\n        return self._unit\n\n    def get_reference_period(self) -&gt; ReferencePeriod | None:\n        \"\"\"Get the reference period of the TimeVector.\"\"\"\n        return self._reference_period\n\n    def get_loader(self) -&gt; TimeVectorLoader | None:\n        \"\"\"Call get_loader on underlying time vector.\"\"\"\n        return self._timevector.get_loader()\n\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Check if self and other are equal.\"\"\"\n        if not isinstance(other, type(self)):\n            return False\n        return (\n            self._timevector == other._timevector\n            and self._scale == other._scale\n            and self._shift == other._shift\n            and self._unit == other._unit\n            and self._is_max_level == other._is_max_level\n            and self._is_zero_one_profile == other._is_zero_one_profile\n            and self._reference_period == other._reference_period\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute the hash of the LinearTransformTimeVector.\"\"\"\n        return hash(\n            (\n                self._timevector,\n                self._scale,\n                self._shift,\n                self._unit,\n                self._is_max_level,\n                self._is_zero_one_profile,\n                self._reference_period,\n            ),\n        )\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Check if self and other are equal.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Check if self and other are equal.\"\"\"\n    if not isinstance(other, type(self)):\n        return False\n    return (\n        self._timevector == other._timevector\n        and self._scale == other._scale\n        and self._shift == other._shift\n        and self._unit == other._unit\n        and self._is_max_level == other._is_max_level\n        and self._is_zero_one_profile == other._is_zero_one_profile\n        and self._reference_period == other._reference_period\n    )\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Compute the hash of the LinearTransformTimeVector.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute the hash of the LinearTransformTimeVector.\"\"\"\n    return hash(\n        (\n            self._timevector,\n            self._scale,\n            self._shift,\n            self._unit,\n            self._is_max_level,\n            self._is_zero_one_profile,\n            self._reference_period,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.__init__","title":"<code>__init__(timevector: TimeVector, scale: float, shift: float, unit: str | None, is_max_level: bool | None = None, is_zero_one_profile: bool | None = None, reference_period: ReferencePeriod | None = None) -&gt; None</code>","text":"<p>Initialize LinearTransformTimeVector with a TimeVector, scale and shift.</p> <p>May also override unit, is_max_level,  is_zero_one_profile and reference_period of the original timevector.</p> <p>Parameters:</p> Name Type Description Default <code>timevector</code> <code>TimeVector</code> <p>TimeVector.</p> required <code>scale</code> <code>float</code> <p>Scale factor.</p> required <code>shift</code> <code>float</code> <p>Shift value.</p> required <code>unit</code> <code>str | None</code> <p>Unit of the values in the transformed vector.</p> required <code>is_max_level</code> <code>bool | None</code> <p>Whether the transformed vector represents the maximum level,                                   average level given a reference period, or not a level at all.                                   Defaults to None.</p> <code>None</code> <code>is_zero_one_profile</code> <code>bool | None</code> <p>Whether the transformed vector represents a profile with values                                         between 0 and 1, a profile with values averaging to 1 over a given                                         reference period, or is not a profile. Defaults to None.</p> <code>None</code> <code>reference_period</code> <code>ReferencePeriod | None</code> <p>Given reference period if the transformed vector                                                  represents average level or mean one profile. Defaults to None.</p> <code>None</code> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def __init__(\n    self,\n    timevector: TimeVector,\n    scale: float,\n    shift: float,\n    unit: str | None,\n    is_max_level: bool | None = None,\n    is_zero_one_profile: bool | None = None,\n    reference_period: ReferencePeriod | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize LinearTransformTimeVector with a TimeVector, scale and shift.\n\n    May also override unit, is_max_level,  is_zero_one_profile and reference_period of the original timevector.\n\n    Args:\n        timevector (TimeVector): TimeVector.\n        scale (float): Scale factor.\n        shift (float): Shift value.\n        unit (str | None): Unit of the values in the transformed vector.\n        is_max_level (bool | None, optional): Whether the transformed vector represents the maximum level,\n                                              average level given a reference period, or not a level at all.\n                                              Defaults to None.\n        is_zero_one_profile (bool | None, optional): Whether the transformed vector represents a profile with values\n                                                    between 0 and 1, a profile with values averaging to 1 over a given\n                                                    reference period, or is not a profile. Defaults to None.\n        reference_period (ReferencePeriod | None, optional): Given reference period if the transformed vector\n                                                             represents average level or mean one profile. Defaults to None.\n\n    \"\"\"\n    self._check_type(timevector, TimeVector)\n    self._check_type(scale, float)\n    self._check_type(shift, float)\n    self._check_type(unit, (str, type(None)))\n    self._check_type(is_max_level, (bool, type(None)))\n    self._check_type(is_zero_one_profile, (bool, type(None)))\n    self._check_type(reference_period, (ReferencePeriod, type(None)))\n    self._timevector = timevector\n    self._scale = scale\n    self._shift = shift\n    self._unit = unit\n    self._is_max_level = is_max_level\n    self._is_zero_one_profile = is_zero_one_profile\n    self._reference_period = reference_period\n\n    self._check_is_level_or_profile()\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the Fingerprint of the TimeVector.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the Fingerprint of the TimeVector.\"\"\"\n    return self.get_fingerprint_default()\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.get_loader","title":"<code>get_loader() -&gt; TimeVectorLoader | None</code>","text":"<p>Call get_loader on underlying time vector.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def get_loader(self) -&gt; TimeVectorLoader | None:\n    \"\"\"Call get_loader on underlying time vector.\"\"\"\n    return self._timevector.get_loader()\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.get_reference_period","title":"<code>get_reference_period() -&gt; ReferencePeriod | None</code>","text":"<p>Get the reference period of the TimeVector.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def get_reference_period(self) -&gt; ReferencePeriod | None:\n    \"\"\"Get the reference period of the TimeVector.\"\"\"\n    return self._reference_period\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.get_timeindex","title":"<code>get_timeindex() -&gt; ConstantTimeIndex</code>","text":"<p>Get the TimeIndex of the TimeVector.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def get_timeindex(self) -&gt; ConstantTimeIndex:\n    \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n    return self._timevector.get_timeindex()\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.get_unit","title":"<code>get_unit() -&gt; str | None</code>","text":"<p>Get the unit of the TimeVector.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def get_unit(self) -&gt; str | None:\n    \"\"\"Get the unit of the TimeVector.\"\"\"\n    return self._unit\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.get_vector","title":"<code>get_vector(is_float32: bool) -&gt; NDArray</code>","text":"<p>Get the values of the TimeVector.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def get_vector(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"Get the values of the TimeVector.\"\"\"\n    vector = self._timevector.get_vector(is_float32)\n    if self._scale == 1.0 and self._shift == 0.0:\n        return vector\n    out = vector.copy()\n    if self._scale != 1.0:\n        np.multiply(out, self._scale, out=out)\n    if self._shift != 0.0:\n        np.add(out, self._shift, out=out)\n    return out\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.is_constant","title":"<code>is_constant() -&gt; bool</code>","text":"<p>Check if the TimeVector is constant.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def is_constant(self) -&gt; bool:\n    \"\"\"Check if the TimeVector is constant.\"\"\"\n    return self._timevector.is_constant()\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.is_max_level","title":"<code>is_max_level() -&gt; bool | None</code>","text":"<p>Check if TimeVector is a level representing maximum Volume/Capacity.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def is_max_level(self) -&gt; bool | None:\n    \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n    return self._is_max_level\n</code></pre>"},{"location":"reference/#framcore.timevectors.LinearTransformTimeVector.LinearTransformTimeVector.is_zero_one_profile","title":"<code>is_zero_one_profile() -&gt; bool | None</code>","text":"<p>Check if TimeVector is a profile with values between zero and one.</p> Source code in <code>framcore/timevectors/LinearTransformTimeVector.py</code> <pre><code>def is_zero_one_profile(self) -&gt; bool | None:\n    \"\"\"Check if TimeVector is a profile with values between zero and one.\"\"\"\n    return self._is_zero_one_profile\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector","title":"<code>ListTimeVector</code>","text":""},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector","title":"<code>ListTimeVector</code>","text":"<p>               Bases: <code>TimeVector</code></p> <p>TimeVector with a numpy array of values paired with a timeindex.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>class ListTimeVector(TimeVector):\n    \"\"\"TimeVector with a numpy array of values paired with a timeindex.\"\"\"\n\n    def __init__(\n        self,\n        timeindex: TimeIndex,\n        vector: NDArray,\n        unit: str | None,\n        is_max_level: bool | None,\n        is_zero_one_profile: bool | None,\n        reference_period: ReferencePeriod | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ListTimeVector class.\n\n        Args:\n            timeindex (TimeIndex): Index of timestamps for the vector.\n            vector (NDArray): Array of vector values.\n            unit (str | None): Unit of the values in the vector.\n            is_max_level (bool | None): Whether the vector represents the maximum level, average level given a\n                                        reference period, or not a level at all.\n            is_zero_one_profile (bool | None): Whether the vector represents aprofile with values between 0 and 1, a\n                                               profile with values averaging to 1 over a given reference period, or is\n                                               not a profile.\n            reference_period (ReferencePeriod | None, optional): Given reference period if the vector represents average\n                                                                 level or mean one profile. Defaults to None.\n\n        Raises:\n            ValueError: When both is_max_level and is_zero_one_profile is not None. This would mean the TimeVector\n                        represents both a level and a profile, which is not allowed.\n            ValueError: When the shape of the vector does not match the number of periods in the timeindex.\n\n        \"\"\"\n        if vector.shape != (timeindex.get_num_periods(),):\n            msg = f\"Vector shape {vector.shape} does not match number of periods {timeindex.get_num_periods()} of timeindex ({timeindex}).\"\n            raise ValueError(msg)\n\n        self._timeindex = timeindex\n        self._vector = vector\n        self._unit = unit\n        self._reference_period = reference_period\n        self._is_max_level = is_max_level\n        self._is_zero_one_profile = is_zero_one_profile\n\n        self._check_type(timeindex, TimeIndex)\n        self._check_type(vector, np.ndarray)\n        self._check_type(unit, (str, type(None)))\n        self._check_type(is_max_level, (bool, type(None)))\n        self._check_type(is_zero_one_profile, (bool, type(None)))\n        self._check_type(reference_period, (ReferencePeriod, type(None)))\n\n        self._check_is_level_or_profile()\n\n    def __eq__(self, other: object) -&gt; None:\n        \"\"\"Check equality between two ListTimeVector objects.\"\"\"\n        if not isinstance(other, ListTimeVector):\n            return NotImplemented\n        return (\n            (self._timeindex == other._timeindex)\n            and np.array_equal(self._vector, other._vector)\n            and (self._unit == other._unit)\n            and (self._is_max_level == other._is_max_level)\n            and (self._is_zero_one_profile == other._is_zero_one_profile)\n            and (self._reference_period == other._reference_period)\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return hash of ListTimeVector object.\"\"\"\n        return hash((self._timeindex, self._vector.tobytes(), self._unit, self._is_max_level, self._is_zero_one_profile, self._reference_period))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the string representation of the ListTimeVector.\"\"\"\n        return f\"ListTimeVector(timeindex={self._timeindex}, vector={self._vector}, unit={self._unit}, reference_period={self._reference_period})\"\n\n    def get_vector(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"Get the vector of the TimeVector as a numpy array.\"\"\"\n        if is_float32:\n            return self._vector.astype(dtype=np.float32)\n        return self._vector\n\n    def get_timeindex(self) -&gt; TimeIndex:\n        \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n        return self._timeindex\n\n    def is_constant(self) -&gt; bool:\n        \"\"\"Check if the TimeVector is constant.\"\"\"\n        return False\n\n    def is_max_level(self) -&gt; bool:\n        \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n        return self._is_max_level\n\n    def is_zero_one_profile(self) -&gt; bool:\n        \"\"\"Check if TimeVector is a profile with vector between zero and one.\"\"\"\n        return self._is_zero_one_profile\n\n    def get_unit(self) -&gt; str | None:\n        \"\"\"Get the unit of the TimeVector.\"\"\"\n        return self._unit\n\n    def get_reference_period(self) -&gt; ReferencePeriod | None:\n        \"\"\"Get the reference period of the TimeVector.\"\"\"\n        return self._reference_period\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"\n        Get the fingerprint of the ListTimeVector.\n\n        Returns:\n            Fingerprint: The fingerprint of the ListTimeVector, excluding the reference period.\n\n        \"\"\"\n        excludes = {\"_reference_period\"}\n        return self.get_fingerprint_default(excludes=excludes)\n\n    def get_loader(self) -&gt; None:\n        \"\"\"Interface method Not applicable for this type. Return None.\"\"\"\n        return\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.__eq__","title":"<code>__eq__(other: object) -&gt; None</code>","text":"<p>Check equality between two ListTimeVector objects.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def __eq__(self, other: object) -&gt; None:\n    \"\"\"Check equality between two ListTimeVector objects.\"\"\"\n    if not isinstance(other, ListTimeVector):\n        return NotImplemented\n    return (\n        (self._timeindex == other._timeindex)\n        and np.array_equal(self._vector, other._vector)\n        and (self._unit == other._unit)\n        and (self._is_max_level == other._is_max_level)\n        and (self._is_zero_one_profile == other._is_zero_one_profile)\n        and (self._reference_period == other._reference_period)\n    )\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Return hash of ListTimeVector object.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return hash of ListTimeVector object.\"\"\"\n    return hash((self._timeindex, self._vector.tobytes(), self._unit, self._is_max_level, self._is_zero_one_profile, self._reference_period))\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.__init__","title":"<code>__init__(timeindex: TimeIndex, vector: NDArray, unit: str | None, is_max_level: bool | None, is_zero_one_profile: bool | None, reference_period: ReferencePeriod | None = None) -&gt; None</code>","text":"<p>Initialize the ListTimeVector class.</p> <p>Parameters:</p> Name Type Description Default <code>timeindex</code> <code>TimeIndex</code> <p>Index of timestamps for the vector.</p> required <code>vector</code> <code>NDArray</code> <p>Array of vector values.</p> required <code>unit</code> <code>str | None</code> <p>Unit of the values in the vector.</p> required <code>is_max_level</code> <code>bool | None</code> <p>Whether the vector represents the maximum level, average level given a                         reference period, or not a level at all.</p> required <code>is_zero_one_profile</code> <code>bool | None</code> <p>Whether the vector represents aprofile with values between 0 and 1, a                                profile with values averaging to 1 over a given reference period, or is                                not a profile.</p> required <code>reference_period</code> <code>ReferencePeriod | None</code> <p>Given reference period if the vector represents average                                                  level or mean one profile. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When both is_max_level and is_zero_one_profile is not None. This would mean the TimeVector         represents both a level and a profile, which is not allowed.</p> <code>ValueError</code> <p>When the shape of the vector does not match the number of periods in the timeindex.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def __init__(\n    self,\n    timeindex: TimeIndex,\n    vector: NDArray,\n    unit: str | None,\n    is_max_level: bool | None,\n    is_zero_one_profile: bool | None,\n    reference_period: ReferencePeriod | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the ListTimeVector class.\n\n    Args:\n        timeindex (TimeIndex): Index of timestamps for the vector.\n        vector (NDArray): Array of vector values.\n        unit (str | None): Unit of the values in the vector.\n        is_max_level (bool | None): Whether the vector represents the maximum level, average level given a\n                                    reference period, or not a level at all.\n        is_zero_one_profile (bool | None): Whether the vector represents aprofile with values between 0 and 1, a\n                                           profile with values averaging to 1 over a given reference period, or is\n                                           not a profile.\n        reference_period (ReferencePeriod | None, optional): Given reference period if the vector represents average\n                                                             level or mean one profile. Defaults to None.\n\n    Raises:\n        ValueError: When both is_max_level and is_zero_one_profile is not None. This would mean the TimeVector\n                    represents both a level and a profile, which is not allowed.\n        ValueError: When the shape of the vector does not match the number of periods in the timeindex.\n\n    \"\"\"\n    if vector.shape != (timeindex.get_num_periods(),):\n        msg = f\"Vector shape {vector.shape} does not match number of periods {timeindex.get_num_periods()} of timeindex ({timeindex}).\"\n        raise ValueError(msg)\n\n    self._timeindex = timeindex\n    self._vector = vector\n    self._unit = unit\n    self._reference_period = reference_period\n    self._is_max_level = is_max_level\n    self._is_zero_one_profile = is_zero_one_profile\n\n    self._check_type(timeindex, TimeIndex)\n    self._check_type(vector, np.ndarray)\n    self._check_type(unit, (str, type(None)))\n    self._check_type(is_max_level, (bool, type(None)))\n    self._check_type(is_zero_one_profile, (bool, type(None)))\n    self._check_type(reference_period, (ReferencePeriod, type(None)))\n\n    self._check_is_level_or_profile()\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return the string representation of the ListTimeVector.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the string representation of the ListTimeVector.\"\"\"\n    return f\"ListTimeVector(timeindex={self._timeindex}, vector={self._vector}, unit={self._unit}, reference_period={self._reference_period})\"\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the fingerprint of the ListTimeVector.</p> <p>Returns:</p> Name Type Description <code>Fingerprint</code> <code>Fingerprint</code> <p>The fingerprint of the ListTimeVector, excluding the reference period.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"\n    Get the fingerprint of the ListTimeVector.\n\n    Returns:\n        Fingerprint: The fingerprint of the ListTimeVector, excluding the reference period.\n\n    \"\"\"\n    excludes = {\"_reference_period\"}\n    return self.get_fingerprint_default(excludes=excludes)\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.get_loader","title":"<code>get_loader() -&gt; None</code>","text":"<p>Interface method Not applicable for this type. Return None.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def get_loader(self) -&gt; None:\n    \"\"\"Interface method Not applicable for this type. Return None.\"\"\"\n    return\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.get_reference_period","title":"<code>get_reference_period() -&gt; ReferencePeriod | None</code>","text":"<p>Get the reference period of the TimeVector.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def get_reference_period(self) -&gt; ReferencePeriod | None:\n    \"\"\"Get the reference period of the TimeVector.\"\"\"\n    return self._reference_period\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.get_timeindex","title":"<code>get_timeindex() -&gt; TimeIndex</code>","text":"<p>Get the TimeIndex of the TimeVector.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def get_timeindex(self) -&gt; TimeIndex:\n    \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n    return self._timeindex\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.get_unit","title":"<code>get_unit() -&gt; str | None</code>","text":"<p>Get the unit of the TimeVector.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def get_unit(self) -&gt; str | None:\n    \"\"\"Get the unit of the TimeVector.\"\"\"\n    return self._unit\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.get_vector","title":"<code>get_vector(is_float32: bool) -&gt; NDArray</code>","text":"<p>Get the vector of the TimeVector as a numpy array.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def get_vector(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"Get the vector of the TimeVector as a numpy array.\"\"\"\n    if is_float32:\n        return self._vector.astype(dtype=np.float32)\n    return self._vector\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.is_constant","title":"<code>is_constant() -&gt; bool</code>","text":"<p>Check if the TimeVector is constant.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def is_constant(self) -&gt; bool:\n    \"\"\"Check if the TimeVector is constant.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.is_max_level","title":"<code>is_max_level() -&gt; bool</code>","text":"<p>Check if TimeVector is a level representing maximum Volume/Capacity.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def is_max_level(self) -&gt; bool:\n    \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n    return self._is_max_level\n</code></pre>"},{"location":"reference/#framcore.timevectors.ListTimeVector.ListTimeVector.is_zero_one_profile","title":"<code>is_zero_one_profile() -&gt; bool</code>","text":"<p>Check if TimeVector is a profile with vector between zero and one.</p> Source code in <code>framcore/timevectors/ListTimeVector.py</code> <pre><code>def is_zero_one_profile(self) -&gt; bool:\n    \"\"\"Check if TimeVector is a profile with vector between zero and one.\"\"\"\n    return self._is_zero_one_profile\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector","title":"<code>LoadedTimeVector</code>","text":""},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector","title":"<code>LoadedTimeVector</code>","text":"<p>               Bases: <code>TimeVector</code></p> <p>TimeVector which gets its data from a data source via a TimeVectorLoader. Subclass of TimeVector.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>class LoadedTimeVector(TimeVector):\n    \"\"\"TimeVector which gets its data from a data source via a TimeVectorLoader. Subclass of TimeVector.\"\"\"\n\n    def __init__(self, vector_id: str, loader: TimeVectorLoader) -&gt; None:\n        \"\"\"\n        Store vector id and loader in instance variables, get unit from loader.\n\n        Args:\n            vector_id (str): Unique name of this vector.\n            loader (TimeVectorLoader): Object connected to a data source where vector_id is associated with a time\n                                       vector. The Loader object must also implement the TimeVectorLoader API.\n\n        Raises:\n            ValueError: When metadata in the TimeVectorLoader for both is_max_level and is_zero_one_profile for the\n                        given vector_id is not None. This would mean the TimeVector represents both a level and a\n                        profile, which is not allowed.\n\n        \"\"\"\n        self._vector_id = vector_id\n        self._loader = loader\n        self._check_type(self._vector_id, str)\n        self._check_type(self._loader, TimeVectorLoader)\n        self._is_max_level = self._loader.is_max_level(self._vector_id)\n        self._is_zero_one_profile = self._loader.is_zero_one_profile(self._vector_id)\n        self._unit = self._loader.get_unit(self._vector_id)\n        self._reference_period = self._loader.get_reference_period(self._vector_id)\n\n        self._check_is_level_or_profile()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overwrite string representation of LoadedTimeVector objects.\"\"\"\n        return f\"{type(self).__name__}(vector_id={self._vector_id},loader={self._loader},unit={self._unit})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality between two LoadedTimeVector objects.\"\"\"\n        if not isinstance(other, LoadedTimeVector):\n            return NotImplemented\n        return (self._vector_id == other._vector_id) and (self._loader == other._loader)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return hash of LoadedTimeVector object.\"\"\"\n        return hash((self._vector_id, self._loader))\n\n    def get_vector(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"Get the vector of the TimeVector as a numpy array.\"\"\"\n        vector = self._loader.get_values(self._vector_id)\n        if is_float32:\n            return vector.astype(np.float32)\n        return vector\n\n    def get_timeindex(self) -&gt; TimeIndex:\n        \"\"\"\n        Get this time vectors index.\n\n        Returns:\n            TimeIndex: Object describing the index.\n\n        \"\"\"\n        return self._loader.get_index(self._vector_id)\n\n    def is_constant(self) -&gt; bool:\n        \"\"\"Signify if this TimeVector is constant.\"\"\"\n        return False\n\n    def get_unit(self) -&gt; str:\n        \"\"\"Get the unit of this TimeVector.\"\"\"\n        return self._unit\n\n    def get_loader(self) -&gt; TimeVectorLoader:\n        \"\"\"Get the Loader this TimeVector retrieves its data from.\"\"\"\n        return self._loader\n\n    def get_reference_period(self) -&gt; ReferencePeriod | None:\n        \"\"\"Get the reference period which the data of this TimeVector is from.\"\"\"\n        return self._reference_period\n\n    def is_max_level(self) -&gt; bool | None:\n        \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n        return self._loader.is_max_level(self._vector_id)\n\n    def is_zero_one_profile(self) -&gt; bool | None:\n        \"\"\"Check if TimeVector is a profile with values between zero and one.\"\"\"\n        return self._loader.is_zero_one_profile(self._vector_id)\n\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the Fingerprint of this TimeVector.\"\"\"\n        return self._loader.get_fingerprint(self._vector_id)\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.__eq__","title":"<code>__eq__(other: object) -&gt; bool</code>","text":"<p>Check equality between two LoadedTimeVector objects.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality between two LoadedTimeVector objects.\"\"\"\n    if not isinstance(other, LoadedTimeVector):\n        return NotImplemented\n    return (self._vector_id == other._vector_id) and (self._loader == other._loader)\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Return hash of LoadedTimeVector object.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return hash of LoadedTimeVector object.\"\"\"\n    return hash((self._vector_id, self._loader))\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.__init__","title":"<code>__init__(vector_id: str, loader: TimeVectorLoader) -&gt; None</code>","text":"<p>Store vector id and loader in instance variables, get unit from loader.</p> <p>Parameters:</p> Name Type Description Default <code>vector_id</code> <code>str</code> <p>Unique name of this vector.</p> required <code>loader</code> <code>TimeVectorLoader</code> <p>Object connected to a data source where vector_id is associated with a time                        vector. The Loader object must also implement the TimeVectorLoader API.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>When metadata in the TimeVectorLoader for both is_max_level and is_zero_one_profile for the         given vector_id is not None. This would mean the TimeVector represents both a level and a         profile, which is not allowed.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def __init__(self, vector_id: str, loader: TimeVectorLoader) -&gt; None:\n    \"\"\"\n    Store vector id and loader in instance variables, get unit from loader.\n\n    Args:\n        vector_id (str): Unique name of this vector.\n        loader (TimeVectorLoader): Object connected to a data source where vector_id is associated with a time\n                                   vector. The Loader object must also implement the TimeVectorLoader API.\n\n    Raises:\n        ValueError: When metadata in the TimeVectorLoader for both is_max_level and is_zero_one_profile for the\n                    given vector_id is not None. This would mean the TimeVector represents both a level and a\n                    profile, which is not allowed.\n\n    \"\"\"\n    self._vector_id = vector_id\n    self._loader = loader\n    self._check_type(self._vector_id, str)\n    self._check_type(self._loader, TimeVectorLoader)\n    self._is_max_level = self._loader.is_max_level(self._vector_id)\n    self._is_zero_one_profile = self._loader.is_zero_one_profile(self._vector_id)\n    self._unit = self._loader.get_unit(self._vector_id)\n    self._reference_period = self._loader.get_reference_period(self._vector_id)\n\n    self._check_is_level_or_profile()\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Overwrite string representation of LoadedTimeVector objects.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overwrite string representation of LoadedTimeVector objects.\"\"\"\n    return f\"{type(self).__name__}(vector_id={self._vector_id},loader={self._loader},unit={self._unit})\"\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>","text":"<p>Get the Fingerprint of this TimeVector.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the Fingerprint of this TimeVector.\"\"\"\n    return self._loader.get_fingerprint(self._vector_id)\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.get_loader","title":"<code>get_loader() -&gt; TimeVectorLoader</code>","text":"<p>Get the Loader this TimeVector retrieves its data from.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def get_loader(self) -&gt; TimeVectorLoader:\n    \"\"\"Get the Loader this TimeVector retrieves its data from.\"\"\"\n    return self._loader\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.get_reference_period","title":"<code>get_reference_period() -&gt; ReferencePeriod | None</code>","text":"<p>Get the reference period which the data of this TimeVector is from.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def get_reference_period(self) -&gt; ReferencePeriod | None:\n    \"\"\"Get the reference period which the data of this TimeVector is from.\"\"\"\n    return self._reference_period\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.get_timeindex","title":"<code>get_timeindex() -&gt; TimeIndex</code>","text":"<p>Get this time vectors index.</p> <p>Returns:</p> Name Type Description <code>TimeIndex</code> <code>TimeIndex</code> <p>Object describing the index.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def get_timeindex(self) -&gt; TimeIndex:\n    \"\"\"\n    Get this time vectors index.\n\n    Returns:\n        TimeIndex: Object describing the index.\n\n    \"\"\"\n    return self._loader.get_index(self._vector_id)\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.get_unit","title":"<code>get_unit() -&gt; str</code>","text":"<p>Get the unit of this TimeVector.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def get_unit(self) -&gt; str:\n    \"\"\"Get the unit of this TimeVector.\"\"\"\n    return self._unit\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.get_vector","title":"<code>get_vector(is_float32: bool) -&gt; NDArray</code>","text":"<p>Get the vector of the TimeVector as a numpy array.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def get_vector(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"Get the vector of the TimeVector as a numpy array.\"\"\"\n    vector = self._loader.get_values(self._vector_id)\n    if is_float32:\n        return vector.astype(np.float32)\n    return vector\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.is_constant","title":"<code>is_constant() -&gt; bool</code>","text":"<p>Signify if this TimeVector is constant.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def is_constant(self) -&gt; bool:\n    \"\"\"Signify if this TimeVector is constant.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.is_max_level","title":"<code>is_max_level() -&gt; bool | None</code>","text":"<p>Check if TimeVector is a level representing maximum Volume/Capacity.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def is_max_level(self) -&gt; bool | None:\n    \"\"\"Check if TimeVector is a level representing maximum Volume/Capacity.\"\"\"\n    return self._loader.is_max_level(self._vector_id)\n</code></pre>"},{"location":"reference/#framcore.timevectors.LoadedTimeVector.LoadedTimeVector.is_zero_one_profile","title":"<code>is_zero_one_profile() -&gt; bool | None</code>","text":"<p>Check if TimeVector is a profile with values between zero and one.</p> Source code in <code>framcore/timevectors/LoadedTimeVector.py</code> <pre><code>def is_zero_one_profile(self) -&gt; bool | None:\n    \"\"\"Check if TimeVector is a profile with values between zero and one.\"\"\"\n    return self._loader.is_zero_one_profile(self._vector_id)\n</code></pre>"},{"location":"reference/#framcore.timevectors.ReferencePeriod","title":"<code>ReferencePeriod</code>","text":""},{"location":"reference/#framcore.timevectors.ReferencePeriod.ReferencePeriod","title":"<code>ReferencePeriod</code>","text":"<p>               Bases: <code>Base</code></p> <p>ReferencePeriod class represents a period of one or more years.</p> Source code in <code>framcore/timevectors/ReferencePeriod.py</code> <pre><code>class ReferencePeriod(Base):\n    \"\"\"ReferencePeriod class represents a period of one or more years.\"\"\"\n\n    def __init__(self, start_year: int, num_years: int) -&gt; None:\n        \"\"\"\n        Initialize a ReferencePeriod with the start year and number of years.\n\n        Args:\n            start_year (int): The first year in the reference period. Must be a positive integer.\n            num_years (int): The number of years in the reference period. Must be a positive non-zero integer.\n\n        \"\"\"\n        self._check_type(start_year, int)\n        self._check_type(num_years, int)\n\n        if start_year &lt; 0:\n            message = f\"start_year must be a positive integer. Got {start_year}.\"\n            raise ValueError(message)\n\n        if num_years &lt;= 0:\n            message = f\"num_years must be a positive non-zero integer. Got {num_years}.\"\n            raise ValueError(message)\n\n        self._start_year = start_year\n        self._num_years = num_years\n\n    def get_start_year(self) -&gt; int:\n        \"\"\"Get the start_year from a ReferencePeriod instance.\"\"\"\n        return self._start_year\n\n    def get_num_years(self) -&gt; int:\n        \"\"\"Get the number of years in the ReferencePeriod.\"\"\"\n        return self._num_years\n\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Check if self and other are equal.\"\"\"\n        if not isinstance(other, type(self)):\n            return False\n        return self._start_year == other._start_year and self._num_years == other._num_years\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute hash value..\"\"\"\n        return hash(\n            (\n                self._start_year,\n                self._num_years,\n            ),\n        )\n</code></pre>"},{"location":"reference/#framcore.timevectors.ReferencePeriod.ReferencePeriod.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Check if self and other are equal.</p> Source code in <code>framcore/timevectors/ReferencePeriod.py</code> <pre><code>def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Check if self and other are equal.\"\"\"\n    if not isinstance(other, type(self)):\n        return False\n    return self._start_year == other._start_year and self._num_years == other._num_years\n</code></pre>"},{"location":"reference/#framcore.timevectors.ReferencePeriod.ReferencePeriod.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Compute hash value..</p> Source code in <code>framcore/timevectors/ReferencePeriod.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute hash value..\"\"\"\n    return hash(\n        (\n            self._start_year,\n            self._num_years,\n        ),\n    )\n</code></pre>"},{"location":"reference/#framcore.timevectors.ReferencePeriod.ReferencePeriod.__init__","title":"<code>__init__(start_year: int, num_years: int) -&gt; None</code>","text":"<p>Initialize a ReferencePeriod with the start year and number of years.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <code>int</code> <p>The first year in the reference period. Must be a positive integer.</p> required <code>num_years</code> <code>int</code> <p>The number of years in the reference period. Must be a positive non-zero integer.</p> required Source code in <code>framcore/timevectors/ReferencePeriod.py</code> <pre><code>def __init__(self, start_year: int, num_years: int) -&gt; None:\n    \"\"\"\n    Initialize a ReferencePeriod with the start year and number of years.\n\n    Args:\n        start_year (int): The first year in the reference period. Must be a positive integer.\n        num_years (int): The number of years in the reference period. Must be a positive non-zero integer.\n\n    \"\"\"\n    self._check_type(start_year, int)\n    self._check_type(num_years, int)\n\n    if start_year &lt; 0:\n        message = f\"start_year must be a positive integer. Got {start_year}.\"\n        raise ValueError(message)\n\n    if num_years &lt;= 0:\n        message = f\"num_years must be a positive non-zero integer. Got {num_years}.\"\n        raise ValueError(message)\n\n    self._start_year = start_year\n    self._num_years = num_years\n</code></pre>"},{"location":"reference/#framcore.timevectors.ReferencePeriod.ReferencePeriod.get_num_years","title":"<code>get_num_years() -&gt; int</code>","text":"<p>Get the number of years in the ReferencePeriod.</p> Source code in <code>framcore/timevectors/ReferencePeriod.py</code> <pre><code>def get_num_years(self) -&gt; int:\n    \"\"\"Get the number of years in the ReferencePeriod.\"\"\"\n    return self._num_years\n</code></pre>"},{"location":"reference/#framcore.timevectors.ReferencePeriod.ReferencePeriod.get_start_year","title":"<code>get_start_year() -&gt; int</code>","text":"<p>Get the start_year from a ReferencePeriod instance.</p> Source code in <code>framcore/timevectors/ReferencePeriod.py</code> <pre><code>def get_start_year(self) -&gt; int:\n    \"\"\"Get the start_year from a ReferencePeriod instance.\"\"\"\n    return self._start_year\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector","title":"<code>TimeVector</code>","text":""},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector","title":"<code>TimeVector</code>","text":"<p>               Bases: <code>Base</code>, <code>ABC</code></p> <p>TimeVector interface class for defining timeseries data.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>class TimeVector(Base, ABC):\n    \"\"\"TimeVector interface class for defining timeseries data.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the TimeVector class.\"\"\"\n        super().__init__()\n\n    @abstractmethod\n    def __eq__(self, other) -&gt; bool:  # noqa: ANN001\n        \"\"\"Check if two TimeVectors are equal.\"\"\"\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute hash value.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_vector(self, is_float32: bool) -&gt; NDArray:\n        \"\"\"Get the values of the TimeVector.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_timeindex(self) -&gt; TimeIndex | None:\n        \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_constant(self) -&gt; bool:\n        \"\"\"Check if the TimeVector is constant.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_max_level(self) -&gt; bool | None:\n        \"\"\"\n        Whether the TimeVector represents the maximum level, average level given a reference period, or not a level at all.\n\n        See LevelProfile for a description of Level (max or avg) and Profile (max one or mean one), and their formats.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_zero_one_profile(self) -&gt; bool | None:\n        \"\"\"\n        Whether the TimeVector represents a profile with values between 0 and 1, a profile with average 1 over a given reference period, or is not a profile.\n\n        See LevelProfile for a description of Level (max or avg) and Profile (max one or mean one), and their formats.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_unit(self) -&gt; str | None:\n        \"\"\"Get the unit of the TimeVector.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_fingerprint(self) -&gt; Fingerprint:\n        \"\"\"Get the fingerprint of the TimeVector.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_reference_period(self) -&gt; ReferencePeriod | None:\n        \"\"\"Get the reference period of the TimeVector.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_loader(self) -&gt; TimeVectorLoader | None:\n        \"\"\"\n        Get the TimeVectorLoader of the TimeVector if self has one.\n\n        TimeVectors can store timeseries data in Loaders that point to databases. Data is only retrieved and cached when the TimeVector is queried.\n        \"\"\"\n        pass\n\n    \"\"\"\n    Checks that the TimeVector is either a level or a profile.\n\n    Raises:\n        ValueError: If both is_max_level and is_zero_one_profile are None or both are not None.\n    \"\"\"\n\n    def _check_is_level_or_profile(self) -&gt; None:\n        \"\"\"Ensure that the TimeVector is either a level or a profile.\"\"\"\n        if (self.is_max_level() is not None and self.is_zero_one_profile() is not None) or (self.is_max_level() is None and self.is_zero_one_profile() is None):\n            message = (\n                f\"Invalid input arguments for {self}: Must have exactly one 'non-None' value for \"\n                \"is_max_level and is_zero_one_profile. A TimeVector is either a level or a profile.\"\n            )\n            raise ValueError(message)\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.__eq__","title":"<code>__eq__(other) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if two TimeVectors are equal.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef __eq__(self, other) -&gt; bool:  # noqa: ANN001\n    \"\"\"Check if two TimeVectors are equal.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.__hash__","title":"<code>__hash__() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Compute hash value.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef __hash__(self) -&gt; int:\n    \"\"\"Compute hash value.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the TimeVector class.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the TimeVector class.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.get_fingerprint","title":"<code>get_fingerprint() -&gt; Fingerprint</code>  <code>abstractmethod</code>","text":"<p>Get the fingerprint of the TimeVector.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef get_fingerprint(self) -&gt; Fingerprint:\n    \"\"\"Get the fingerprint of the TimeVector.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.get_loader","title":"<code>get_loader() -&gt; TimeVectorLoader | None</code>  <code>abstractmethod</code>","text":"<p>Get the TimeVectorLoader of the TimeVector if self has one.</p> <p>TimeVectors can store timeseries data in Loaders that point to databases. Data is only retrieved and cached when the TimeVector is queried.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef get_loader(self) -&gt; TimeVectorLoader | None:\n    \"\"\"\n    Get the TimeVectorLoader of the TimeVector if self has one.\n\n    TimeVectors can store timeseries data in Loaders that point to databases. Data is only retrieved and cached when the TimeVector is queried.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.get_reference_period","title":"<code>get_reference_period() -&gt; ReferencePeriod | None</code>  <code>abstractmethod</code>","text":"<p>Get the reference period of the TimeVector.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef get_reference_period(self) -&gt; ReferencePeriod | None:\n    \"\"\"Get the reference period of the TimeVector.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.get_timeindex","title":"<code>get_timeindex() -&gt; TimeIndex | None</code>  <code>abstractmethod</code>","text":"<p>Get the TimeIndex of the TimeVector.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef get_timeindex(self) -&gt; TimeIndex | None:\n    \"\"\"Get the TimeIndex of the TimeVector.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.get_unit","title":"<code>get_unit() -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Get the unit of the TimeVector.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef get_unit(self) -&gt; str | None:\n    \"\"\"Get the unit of the TimeVector.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.get_vector","title":"<code>get_vector(is_float32: bool) -&gt; NDArray</code>  <code>abstractmethod</code>","text":"<p>Get the values of the TimeVector.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef get_vector(self, is_float32: bool) -&gt; NDArray:\n    \"\"\"Get the values of the TimeVector.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.is_constant","title":"<code>is_constant() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if the TimeVector is constant.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef is_constant(self) -&gt; bool:\n    \"\"\"Check if the TimeVector is constant.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.is_max_level","title":"<code>is_max_level() -&gt; bool | None</code>  <code>abstractmethod</code>","text":"<p>Whether the TimeVector represents the maximum level, average level given a reference period, or not a level at all.</p> <p>See LevelProfile for a description of Level (max or avg) and Profile (max one or mean one), and their formats.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef is_max_level(self) -&gt; bool | None:\n    \"\"\"\n    Whether the TimeVector represents the maximum level, average level given a reference period, or not a level at all.\n\n    See LevelProfile for a description of Level (max or avg) and Profile (max one or mean one), and their formats.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.timevectors.TimeVector.TimeVector.is_zero_one_profile","title":"<code>is_zero_one_profile() -&gt; bool | None</code>  <code>abstractmethod</code>","text":"<p>Whether the TimeVector represents a profile with values between 0 and 1, a profile with average 1 over a given reference period, or is not a profile.</p> <p>See LevelProfile for a description of Level (max or avg) and Profile (max one or mean one), and their formats.</p> Source code in <code>framcore/timevectors/TimeVector.py</code> <pre><code>@abstractmethod\ndef is_zero_one_profile(self) -&gt; bool | None:\n    \"\"\"\n    Whether the TimeVector represents a profile with values between 0 and 1, a profile with average 1 over a given reference period, or is not a profile.\n\n    See LevelProfile for a description of Level (max or avg) and Profile (max one or mean one), and their formats.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#framcore.utils","title":"<code>utils</code>","text":""},{"location":"reference/#framcore.utils.FlowInfo","title":"<code>FlowInfo</code>","text":"<p>               Bases: <code>Base</code></p> <p>Holds info about one or two related Arrows of a Flow.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>class FlowInfo(Base):\n    \"\"\"Holds info about one or two related Arrows of a Flow.\"\"\"\n\n    def __init__(\n        self,\n        category: str,\n        node_out: str | None = None,\n        commodity_out: str | None = None,\n        node_in: str | None = None,\n        commodity_in: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Based on its arrows, we derive properties about a Flow.\n\n        We use this class to store such info.\n        \"\"\"\n        self.category = category\n        self.node_out = node_out\n        self.commodity_out = commodity_out\n        self.node_in = node_in\n        self.commodity_in = commodity_in\n</code></pre>"},{"location":"reference/#framcore.utils.FlowInfo.__init__","title":"<code>__init__(category: str, node_out: str | None = None, commodity_out: str | None = None, node_in: str | None = None, commodity_in: str | None = None) -&gt; None</code>","text":"<p>Based on its arrows, we derive properties about a Flow.</p> <p>We use this class to store such info.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def __init__(\n    self,\n    category: str,\n    node_out: str | None = None,\n    commodity_out: str | None = None,\n    node_in: str | None = None,\n    commodity_in: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Based on its arrows, we derive properties about a Flow.\n\n    We use this class to store such info.\n    \"\"\"\n    self.category = category\n    self.node_out = node_out\n    self.commodity_out = commodity_out\n    self.node_in = node_in\n    self.commodity_in = commodity_in\n</code></pre>"},{"location":"reference/#framcore.utils.RegionalVolumes","title":"<code>RegionalVolumes</code>","text":"<p>Container for regional energy volumes.</p> <p>Stores production, consumption, import, and export vectors for each node and category. Provides methods to access these aggregated results.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>class RegionalVolumes:\n    \"\"\"\n    Container for regional energy volumes.\n\n    Stores production, consumption, import, and export vectors for each node and category.\n    Provides methods to access these aggregated results.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the RegionalVolumes instance with empty dictionaries for production, consumption, import, and export.\"\"\"\n        self._production: dict[str, dict[str, NDArray]] = dict()\n        self._consumption: dict[str, dict[str, NDArray]] = dict()\n        self._export: dict[str, dict[str, NDArray]] = dict()\n        self._import: dict[str, dict[str, NDArray]] = dict()\n\n    def get_production(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return dict with production vector by category for each node.\"\"\"\n        return self._production\n\n    def get_consumption(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return dict with consumption vector by category for each node.\"\"\"\n        return self._consumption\n\n    def get_export(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return nested dict with export vector for each trade partner to an exporting node.\"\"\"\n        return self._export\n\n    def get_import(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return nested dict with import vector for each trade partner to an importing node.\"\"\"\n        return self._import\n</code></pre>"},{"location":"reference/#framcore.utils.RegionalVolumes.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the RegionalVolumes instance with empty dictionaries for production, consumption, import, and export.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the RegionalVolumes instance with empty dictionaries for production, consumption, import, and export.\"\"\"\n    self._production: dict[str, dict[str, NDArray]] = dict()\n    self._consumption: dict[str, dict[str, NDArray]] = dict()\n    self._export: dict[str, dict[str, NDArray]] = dict()\n    self._import: dict[str, dict[str, NDArray]] = dict()\n</code></pre>"},{"location":"reference/#framcore.utils.RegionalVolumes.get_consumption","title":"<code>get_consumption() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return dict with consumption vector by category for each node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_consumption(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return dict with consumption vector by category for each node.\"\"\"\n    return self._consumption\n</code></pre>"},{"location":"reference/#framcore.utils.RegionalVolumes.get_export","title":"<code>get_export() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return nested dict with export vector for each trade partner to an exporting node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_export(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return nested dict with export vector for each trade partner to an exporting node.\"\"\"\n    return self._export\n</code></pre>"},{"location":"reference/#framcore.utils.RegionalVolumes.get_import","title":"<code>get_import() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return nested dict with import vector for each trade partner to an importing node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_import(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return nested dict with import vector for each trade partner to an importing node.\"\"\"\n    return self._import\n</code></pre>"},{"location":"reference/#framcore.utils.RegionalVolumes.get_production","title":"<code>get_production() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return dict with production vector by category for each node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_production(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return dict with production vector by category for each node.\"\"\"\n    return self._production\n</code></pre>"},{"location":"reference/#framcore.utils.add_loaders","title":"<code>add_loaders(loaders: set[Loader], model: Model) -&gt; None</code>","text":"<p>Add all loaders stored in Model to loaders set.</p> Source code in <code>framcore/utils/loaders.py</code> <pre><code>def add_loaders(loaders: set[Loader], model: Model) -&gt; None:\n    \"\"\"Add all loaders stored in Model to loaders set.\"\"\"\n    from framcore import Model\n    from framcore.components import Component, Flow, Node\n    from framcore.curves import Curve\n    from framcore.expressions import Expr\n    from framcore.timevectors import TimeVector\n    from framcore.utils import get_supported_components\n\n    _check_type(loaders, \"loaders\", set)\n    _check_type(model, \"model\", Model)\n\n    data = model.get_data()\n    components = dict()\n\n    for key, value in data.items():\n        if isinstance(value, Expr):\n            value.add_loaders(loaders)\n\n        elif isinstance(value, TimeVector | Curve):\n            loader = value.get_loader()\n            if loader is not None:\n                loaders.add(loader)\n\n        elif isinstance(value, Component):\n            components[key] = value\n\n    graph: dict[str, Flow | Node] = get_supported_components(components, (Flow, Node), tuple())\n\n    for c in graph.values():\n        c.add_loaders(loaders)\n</code></pre>"},{"location":"reference/#framcore.utils.add_loaders_if","title":"<code>add_loaders_if(loaders: set, value: object | None) -&gt; None</code>","text":"<p>Call value.add_loaders(loaders) if value is not None.</p> Source code in <code>framcore/utils/loaders.py</code> <pre><code>def add_loaders_if(loaders: set, value: object | None) -&gt; None:\n    \"\"\"Call value.add_loaders(loaders) if value is not None.\"\"\"\n    _check_type(loaders, \"loaders\", set)\n    if value is None:\n        return\n    value.add_loaders(loaders)\n</code></pre>"},{"location":"reference/#framcore.utils.get_component_to_nodes","title":"<code>get_component_to_nodes(data: Model | dict[str, object]) -&gt; dict[str, set[str]]</code>","text":"<p>For each str key in data where value is a Component find all Node id str in data directly connected to the Component.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_component_to_nodes(data: Model | dict[str, object]) -&gt; dict[str, set[str]]:\n    \"\"\"For each str key in data where value is a Component find all Node id str in data directly connected to the Component.\"\"\"\n    from framcore import Model\n\n    _check_type(data, Model | dict)\n\n    if isinstance(data, Model):\n        data = data.get_data()\n\n    components = {k: v for k, v in data.items() if isinstance(v, Component)}\n    for k in components:\n        assert isinstance(k, str), f\"Got invalid key {k}\"\n\n    g = get_supported_components(components, (Node, Flow), tuple())\n\n    nodes = {k: v for k, v in g.items() if isinstance(v, Node)}\n    flows = {k: v for k, v in g.items() if isinstance(v, Flow)}\n\n    domain_nodes = {k: v for k, v in nodes.items() if (k in components) and isinstance(v, Node)}\n    assert all(isinstance(v, Node) for v in domain_nodes.values())\n\n    parent_keys = {v: k for k, v in components.items()}\n\n    out = defaultdict(set)\n    for flow in flows.values():\n        parent_key = parent_keys[flow.get_top_parent()]\n        for a in flow.get_arrows():\n            node_id = a.get_node()\n            if node_id in domain_nodes:\n                out[parent_key].add(node_id)\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.get_flow_infos","title":"<code>get_flow_infos(flow: Flow, node_to_commodity: dict[str, str]) -&gt; list[FlowInfo]</code>","text":"<p>Get flow infos from analysis of all its arrows.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_flow_infos(flow: Flow, node_to_commodity: dict[str, str]) -&gt; list[FlowInfo]:  # noqa: C901\n    \"\"\"Get flow infos from analysis of all its arrows.\"\"\"\n    _check_type(flow, Flow)\n    _check_type(node_to_commodity, dict)\n\n    arrows = flow.get_arrows()\n\n    if len(arrows) == 1:\n        arrow = next(iter(arrows))\n        node_id = arrow.get_node()\n\n        if node_id not in node_to_commodity:\n            message = f\"node_id {node_id} missing from node_to_commodity for flow\\n{flow}\"\n            raise RuntimeError(message)\n\n        commodity = node_to_commodity[node_id]\n        if arrow.is_ingoing():\n            info = FlowInfo(\n                \"direct_in\",\n                node_in=node_id,\n                commodity_in=commodity,\n            )\n        else:\n            info = FlowInfo(\n                \"direct_out\",\n                node_out=node_id,\n                commodity_out=commodity,\n            )\n        return [info]\n\n    seen: set[tuple[str, str]] = set()\n    infos: list[FlowInfo] = []\n    for x in arrows:\n        for y in arrows:\n            if x is y:\n                continue\n\n            if x.is_ingoing() != y.is_ingoing():\n                arrow_in = x if x.is_ingoing() else y\n                arrow_out = x if y.is_ingoing() else y\n\n                node_in = arrow_in.get_node()\n                node_out = arrow_out.get_node()\n\n                if node_in not in node_to_commodity:\n                    message = f\"node_in {node_in} missing from node_to_commodity for flow\\n{flow}\"\n                    raise RuntimeError(message)\n\n                if node_out not in node_to_commodity:\n                    message = f\"node_out {node_out} missing from node_to_commodity for flow\\n{flow}\"\n                    raise RuntimeError(message)\n\n                commodity_in = node_to_commodity[node_in]\n                commodity_out = node_to_commodity[node_out]\n\n                info = FlowInfo(\n                    category=\"transport\" if commodity_in == commodity_out else \"conversion\",\n                    node_in=node_in,\n                    commodity_in=commodity_in,\n                    node_out=node_out,\n                    commodity_out=commodity_out,\n                )\n                key = (node_in, node_out)\n                if key in seen:\n                    continue\n\n                infos.append(info)\n                seen.add(key)\n\n    for arrow in arrows:\n        node = arrow.get_node()\n        if any(node in [info.node_in, info.node_out] for info in infos):\n            continue\n        node_id = arrow.get_node()\n        commodity = node_to_commodity[node_id]\n        if arrow.is_ingoing():\n            info = FlowInfo(\n                \"direct_in\",\n                node_in=node_id,\n                commodity_in=commodity,\n            )\n        else:\n            info = FlowInfo(\n                \"direct_out\",\n                node_out=node_id,\n                commodity_out=commodity,\n            )\n        infos.append(info)\n\n    return infos\n</code></pre>"},{"location":"reference/#framcore.utils.get_hydro_downstream_energy_equivalent","title":"<code>get_hydro_downstream_energy_equivalent(data: dict[str, Component | TimeVector | Curve | Expr], module_name: str, power_node: str | None = None) -&gt; Expr</code>","text":"<p>Get the expression for the sum downstream energy equivalent for a hydro module.</p> <ul> <li>If power node is given, only count downstream energy equivalents that are connected to the power node.</li> <li>Energy equivalents are collected from hydro generators downstream, and the main topology follows the release_to attribute.</li> <li>Transport pumps are included in the downstream topology, but counted as negative energy equivalents.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Component | TimeVector | Curve | Expr]</code> <p>The dict containing the components.</p> required <code>module_name</code> <code>str</code> <p>The name of the hydro module to start from.</p> required <code>power_node</code> <code>str</code> <p>Optional power node to filter energy equivalents.</p> <code>None</code> Source code in <code>framcore/utils/global_energy_equivalent.py</code> <pre><code>def get_hydro_downstream_energy_equivalent(\n    data: dict[str, Component | TimeVector | Curve | Expr],\n    module_name: str,\n    power_node: str | None = None,\n) -&gt; Expr:\n    \"\"\"\n    Get the expression for the sum downstream energy equivalent for a hydro module.\n\n    - If power node is given, only count downstream energy equivalents that are connected to the power node.\n    - Energy equivalents are collected from hydro generators downstream, and the main topology follows the release_to attribute.\n    - Transport pumps are included in the downstream topology, but counted as negative energy equivalents.\n\n    Args:\n        data (dict[str, Component | TimeVector | Curve | Expr]): The dict containing the components.\n        module_name (str): The name of the hydro module to start from.\n        power_node (str): Optional power node to filter energy equivalents.\n\n    \"\"\"\n    if data[module_name].get_pump() and data[module_name].get_pump().get_from_module() == module_name:  # transport pump\n        pump_power_node = data[module_name].get_pump().get_power_node()\n        pump_to = data[module_name].get_pump().get_to_module()\n        energy_equivalent = get_hydro_downstream_energy_equivalent(data, pump_to, power_node)  # continue downstream of pump_to module\n        if power_node in (pump_power_node, None):\n            return energy_equivalent - data[module_name].get_pump().get_energy_equivalent().get_level()  # pumps has negative energy equivalents\n        return energy_equivalent\n\n    energy_equivalent = 0\n    if data[module_name].get_generator():  # hydro generator\n        module_power_node = data[module_name].get_generator().get_power_node()\n        if power_node in (module_power_node, None):\n            energy_equivalent += data[module_name].get_generator().get_energy_equivalent().get_level()\n    if data[module_name].get_release_to():  # continue from release_to module\n        release_to = data[module_name].get_release_to()\n        energy_equivalent += get_hydro_downstream_energy_equivalent(data, release_to, power_node)\n    return energy_equivalent\n</code></pre>"},{"location":"reference/#framcore.utils.get_node_to_commodity","title":"<code>get_node_to_commodity(data: dict[str, object]) -&gt; dict[str, str]</code>","text":"<p>Return dict with commodity (str) for each node id (str) in data.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_node_to_commodity(data: dict[str, object]) -&gt; dict[str, str]:\n    \"\"\"Return dict with commodity (str) for each node id (str) in data.\"\"\"\n    _check_type(data, dict)\n\n    components = {k: v for k, v in data.items() if isinstance(v, Component)}\n    for k in components:\n        assert isinstance(k, str), f\"Got invalid key {k}\"\n\n    g = get_supported_components(components, (Node, Flow), tuple())\n\n    out = dict()\n    for k, v in g.items():\n        if isinstance(v, Node):\n            _check_type(k, str)\n            out[k] = v.get_commodity()\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.get_one_commodity_storage_subsystems","title":"<code>get_one_commodity_storage_subsystems(graph: dict[str, Node | Flow], include_boundaries: bool) -&gt; dict[str, tuple[str, set[str], set[str]]]</code>","text":"<p>Group all storage subsystems belonging to same commodity.</p> <p>Returns dict[subsystem_id, (domain_commodity, member_component_ids, boundary_domain_commodities)]</p> <p>The boundary_domain_commodities of the output is a set of boundary commodities. Some algorithms can only handle one boundary commodity, so this output is useful to verify that those conditions apply, and to derive conversion factor unit, which need both storage_commodity unit and boundray_commodity unit.</p> <p>If include_boundaries is False only nodes with same commodity as storage_node will be included in the subsystem.</p> Source code in <code>framcore/utils/storage_subsystems.py</code> <pre><code>def get_one_commodity_storage_subsystems(  # noqa: C901\n    graph: dict[str, Node | Flow],\n    include_boundaries: bool,\n) -&gt; dict[str, tuple[str, set[str], set[str]]]:\n    \"\"\"\n    Group all storage subsystems belonging to same commodity.\n\n    Returns dict[subsystem_id, (domain_commodity, member_component_ids, boundary_domain_commodities)]\n\n    The boundary_domain_commodities of the output is a set of boundary commodities.\n    Some algorithms can only handle one boundary commodity, so this output is useful\n    to verify that those conditions apply, and to derive conversion factor unit,\n    which need both storage_commodity unit and boundray_commodity unit.\n\n    If include_boundaries is False only nodes with same commodity as storage_node will\n    be included in the subsystem.\n    \"\"\"\n    if not all(isinstance(c, Flow | Node) for c in graph.values()):\n        invalid = {k: v for k, v in graph.items() if not isinstance(v, Flow | Node)}\n        message = f\"All values in graph must be Flow or Node objects. Found invalid objects: {invalid}\"\n        raise ValueError(message)\n\n    flows: dict[str, Flow] = {k: v for k, v in graph.items() if isinstance(v, Flow)}\n    nodes: dict[str, Node] = {k: v for k, v in graph.items() if isinstance(v, Node)}\n\n    storage_nodes: dict[str, Node] = {k: v for k, v in nodes.items() if v.get_storage()}\n\n    node_to_flows: dict[str, set[str]] = defaultdict(set)\n    flow_to_nodes: dict[str, set[str]] = defaultdict(set)\n    for flow_id, flow in flows.items():\n        for arrow in flow.get_arrows():\n            node_id = arrow.get_node()\n            node_to_flows[node_id].add(flow_id)\n            flow_to_nodes[flow_id].add(node_id)\n\n    out = dict()\n    allocated: set[str] = set()\n    for storage_node_id, storage_node in storage_nodes.items():\n        if storage_node_id in allocated:\n            continue\n\n        subsystem_id = storage_node_id\n        storage_commodity = storage_node.get_commodity()\n\n        member_component_ids: set[str] = set()\n        boundary_commodities: set[str] = set()\n\n        visited: set[str] = set()\n        remaining: set[str] = set()\n\n        remaining.add(storage_node_id)\n\n        while remaining:\n            component_id = remaining.pop()\n            if component_id in visited:\n                continue\n\n            visited.add(component_id)\n\n            if component_id in nodes:\n                node: Node = nodes[component_id]\n                node_commodity = node.get_commodity()\n\n                if node_commodity == storage_commodity:\n                    allocated.add(component_id)\n                    remaining.update(node_to_flows.get(component_id, set()))\n                else:\n                    boundary_commodities.add(node_commodity)\n\n                if include_boundaries or node_commodity == storage_commodity:\n                    member_component_ids.add(component_id)\n\n            else:\n                remaining.update(flow_to_nodes.get(component_id, set()))\n                member_component_ids.add(component_id)\n\n        out[subsystem_id] = (storage_commodity, member_component_ids, boundary_commodities)\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.get_transports_by_commodity","title":"<code>get_transports_by_commodity(data: Model | dict[str, object], commodity: str) -&gt; dict[str, tuple[str, str]]</code>","text":"<p>Return dict with key component_id and value (from_node_id, to_node_id) where both nodes belong to given commodity.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_transports_by_commodity(data: Model | dict[str, object], commodity: str) -&gt; dict[str, tuple[str, str]]:\n    \"\"\"Return dict with key component_id and value (from_node_id, to_node_id) where both nodes belong to given commodity.\"\"\"\n    from framcore import Model\n\n    _check_type(data, Model | dict)\n    _check_type(commodity, str)\n\n    if isinstance(data, Model):\n        data = data.get_data()\n\n    components = {k: v for k, v in data.items() if isinstance(v, Component)}\n    for k in components:\n        assert isinstance(k, str), f\"Got invalid key {k}\"\n\n    node_to_commodity = get_node_to_commodity(components)\n\n    g = get_supported_components(components, (Node, Flow), tuple())\n\n    flows = {k: v for k, v in g.items() if isinstance(v, Flow)}\n\n    parent_keys = {v: k for k, v in components.items()}\n\n    out = dict()\n    for flow in flows.values():\n        parent_key = parent_keys[flow.get_top_parent()]\n        infos = get_flow_infos(flow, node_to_commodity)\n        if len(infos) != 1:\n            continue\n        info = infos[0]\n        if info.category != \"transport\":\n            continue\n        if info.commodity_in != commodity:\n            continue\n        out[parent_key] = (info.node_out, info.node_in)\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.is_transport_by_commodity","title":"<code>is_transport_by_commodity(flow: Flow, node_to_commodity: dict[str, str], commodity: str) -&gt; bool</code>","text":"<p>Return True if flow is a transport of the given commodity.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def is_transport_by_commodity(flow: Flow, node_to_commodity: dict[str, str], commodity: str) -&gt; bool:\n    \"\"\"Return True if flow is a transport of the given commodity.\"\"\"\n    _check_type(flow, Flow)\n    _check_type(node_to_commodity, dict)\n    arrows = flow.get_arrows()\n    try:\n        x, y = tuple(arrows)\n        opposite_directions = x.is_ingoing() != y.is_ingoing()\n        x_commodity = node_to_commodity[x.get_node()]\n        y_commodity = node_to_commodity[y.get_node()]\n        correct_commodity = x_commodity == y_commodity == commodity\n        return opposite_directions and correct_commodity\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/#framcore.utils.replace_loader_path","title":"<code>replace_loader_path(loaders: set[Loader], old: Path, new: Path) -&gt; None</code>","text":"<p>Replace old path with new for all loaders using old path.</p> Source code in <code>framcore/utils/loaders.py</code> <pre><code>def replace_loader_path(loaders: set[Loader], old: Path, new: Path) -&gt; None:\n    \"\"\"Replace old path with new for all loaders using old path.\"\"\"\n    from framcore.loaders import FileLoader\n\n    _check_type(loaders, \"loaders\", set)\n\n    new = _check_path(new, \"new\", make_absolute=True)\n    old = _check_path(old, \"old\", error_if_not_absolute=True)\n\n    for loader in loaders:\n        try:\n            source = loader.get_source()\n        except Exception:\n            send_warning_event(f\"loader.get_source() failed for {loader}. Skipping this one.\")\n            continue\n\n        if isinstance(source, Path) and old in source.parents:\n            loader.set_source(new_source=new / source.relative_to(old))\n\n        if isinstance(loader, FileLoader) and not isinstance(source, Path):\n            send_warning_event(f\"FileLoader.get_source() does not return Path as it should for loader {loader}. Instead of Path, got {source}\")\n</code></pre>"},{"location":"reference/#framcore.utils.set_global_energy_equivalent","title":"<code>set_global_energy_equivalent(data: dict[str, Component | TimeVector | Curve | Expr], metakey_energy_eq_downstream: str) -&gt; None</code>","text":"<p>Loop through data dict and set the downstream energy equivalent for all HydroModules.</p> <p>Send a warning event if a HydroModule has no downstream energy equivalents.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Component | TimeVector | Curve | Expr]</code> <p>The dict containing the components.</p> required <code>metakey_energy_eq_downstream</code> <code>str</code> <p>The meta key to use for storing the downstream energy equivalent.</p> required Source code in <code>framcore/utils/global_energy_equivalent.py</code> <pre><code>def set_global_energy_equivalent(data: dict[str, Component | TimeVector | Curve | Expr], metakey_energy_eq_downstream: str) -&gt; None:\n    \"\"\"\n    Loop through data dict and set the downstream energy equivalent for all HydroModules.\n\n    Send a warning event if a HydroModule has no downstream energy equivalents.\n\n    Args:\n        data (dict[str, Component | TimeVector | Curve | Expr]): The dict containing the components.\n        metakey_energy_eq_downstream (str): The meta key to use for storing the downstream energy equivalent.\n\n    \"\"\"\n    for module_name, module in data.items():\n        if isinstance(module, HydroModule) and module.get_reservoir():\n            energy_equivalent = get_hydro_downstream_energy_equivalent(data, module_name)\n            if energy_equivalent == 0:\n                message = f\"HydroModule {module_name} has no downstream energy equivalents.\"\n                module.send_warning_event(message)\n                energy_equivalent = ConstantTimeVector(scalar=0.0, unit=\"kWh/m3\", is_max_level=False)\n            module.add_meta(metakey_energy_eq_downstream, LevelExprMeta(energy_equivalent))\n</code></pre>"},{"location":"reference/#framcore.utils.get_regional_volumes","title":"<code>get_regional_volumes</code>","text":""},{"location":"reference/#framcore.utils.get_regional_volumes.RegionalVolumes","title":"<code>RegionalVolumes</code>","text":"<p>Container for regional energy volumes.</p> <p>Stores production, consumption, import, and export vectors for each node and category. Provides methods to access these aggregated results.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>class RegionalVolumes:\n    \"\"\"\n    Container for regional energy volumes.\n\n    Stores production, consumption, import, and export vectors for each node and category.\n    Provides methods to access these aggregated results.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the RegionalVolumes instance with empty dictionaries for production, consumption, import, and export.\"\"\"\n        self._production: dict[str, dict[str, NDArray]] = dict()\n        self._consumption: dict[str, dict[str, NDArray]] = dict()\n        self._export: dict[str, dict[str, NDArray]] = dict()\n        self._import: dict[str, dict[str, NDArray]] = dict()\n\n    def get_production(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return dict with production vector by category for each node.\"\"\"\n        return self._production\n\n    def get_consumption(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return dict with consumption vector by category for each node.\"\"\"\n        return self._consumption\n\n    def get_export(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return nested dict with export vector for each trade partner to an exporting node.\"\"\"\n        return self._export\n\n    def get_import(self) -&gt; dict[str, dict[str, NDArray]]:\n        \"\"\"Return nested dict with import vector for each trade partner to an importing node.\"\"\"\n        return self._import\n</code></pre>"},{"location":"reference/#framcore.utils.get_regional_volumes.RegionalVolumes.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the RegionalVolumes instance with empty dictionaries for production, consumption, import, and export.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the RegionalVolumes instance with empty dictionaries for production, consumption, import, and export.\"\"\"\n    self._production: dict[str, dict[str, NDArray]] = dict()\n    self._consumption: dict[str, dict[str, NDArray]] = dict()\n    self._export: dict[str, dict[str, NDArray]] = dict()\n    self._import: dict[str, dict[str, NDArray]] = dict()\n</code></pre>"},{"location":"reference/#framcore.utils.get_regional_volumes.RegionalVolumes.get_consumption","title":"<code>get_consumption() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return dict with consumption vector by category for each node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_consumption(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return dict with consumption vector by category for each node.\"\"\"\n    return self._consumption\n</code></pre>"},{"location":"reference/#framcore.utils.get_regional_volumes.RegionalVolumes.get_export","title":"<code>get_export() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return nested dict with export vector for each trade partner to an exporting node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_export(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return nested dict with export vector for each trade partner to an exporting node.\"\"\"\n    return self._export\n</code></pre>"},{"location":"reference/#framcore.utils.get_regional_volumes.RegionalVolumes.get_import","title":"<code>get_import() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return nested dict with import vector for each trade partner to an importing node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_import(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return nested dict with import vector for each trade partner to an importing node.\"\"\"\n    return self._import\n</code></pre>"},{"location":"reference/#framcore.utils.get_regional_volumes.RegionalVolumes.get_production","title":"<code>get_production() -&gt; dict[str, dict[str, NDArray]]</code>","text":"<p>Return dict with production vector by category for each node.</p> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_production(self) -&gt; dict[str, dict[str, NDArray]]:\n    \"\"\"Return dict with production vector by category for each node.\"\"\"\n    return self._production\n</code></pre>"},{"location":"reference/#framcore.utils.get_regional_volumes.get_regional_volumes","title":"<code>get_regional_volumes(db: Model | QueryDB, commodity: str, node_category: str, production_category: str, consumption_category: str, data_period: SinglePeriodTimeIndex, scenario_period: FixedFrequencyTimeIndex, unit: str, is_float32: bool = True) -&gt; RegionalVolumes</code>","text":"<p>Calculate aggregated production, consumption, import and export for member in node_category.</p> <p>Decompose the model components into nodes and flows. Analyze the flows to determine their contribution to production, consumption, import, and export if they are associated with the specified commodity. Group these contributions based on the provided node_category, production_category, and consumption_category metadata.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Model | QueryDB</code> <p>Model or QueryDB to use</p> required <code>commodity</code> <code>str</code> <p>Commodity to consider</p> required <code>node_category</code> <code>str</code> <p>Meta key for node category to group the results by</p> required <code>production_category</code> <code>str</code> <p>Meta key for production category to group the results by</p> required <code>consumption_category</code> <code>str</code> <p>Meta key for consumption category to group the results by</p> required <code>data_period</code> <code>SinglePeriodTimeIndex</code> <p>Consider results for this data period</p> required <code>scenario_period</code> <code>FixedFrequencyTimeIndex</code> <p>Consider results for this scenario period</p> required <code>unit</code> <code>str</code> <p>Unit to use for the results</p> required <code>is_float32</code> <code>bool</code> <p>Use float32 for calculations and results if True</p> <code>True</code> Source code in <code>framcore/utils/get_regional_volumes.py</code> <pre><code>def get_regional_volumes(  # noqa C901\n    db: Model | QueryDB,\n    commodity: str,\n    node_category: str,\n    production_category: str,\n    consumption_category: str,\n    data_period: SinglePeriodTimeIndex,\n    scenario_period: FixedFrequencyTimeIndex,\n    unit: str,\n    is_float32: bool = True,\n) -&gt; RegionalVolumes:\n    \"\"\"\n    Calculate aggregated production, consumption, import and export for member in node_category.\n\n    Decompose the model components into nodes and flows. Analyze the flows to determine their contribution to production, consumption, import, and export if\n    they are associated with the specified commodity. Group these contributions based on the provided node_category, production_category, and\n    consumption_category metadata.\n\n    Args:\n        db (Model | QueryDB): Model or QueryDB to use\n        commodity (str): Commodity to consider\n        node_category (str): Meta key for node category to group the results by\n        production_category (str): Meta key for production category to group the results by\n        consumption_category (str): Meta key for consumption category to group the results by\n        data_period (SinglePeriodTimeIndex): Consider results for this data period\n        scenario_period (FixedFrequencyTimeIndex): Consider results for this scenario period\n        unit (str): Unit to use for the results\n        is_float32 (bool): Use float32 for calculations and results if True\n\n    \"\"\"\n    db = _load_model_and_create_model_db(db)\n\n    if not isinstance(is_float32, bool):\n        message = f\"Expected bool for is_float32, got {is_float32}\"\n        raise ValueError(message)\n\n    domain_components = {k: v for k, v in db.get_data().items() if isinstance(v, Component)}\n\n    graph: dict[str, Node | Flow] = get_supported_components(\n        components=domain_components,\n        supported_types=(Node, Flow),\n        forbidden_types=tuple(),\n    )\n\n    flows: dict[str, Flow] = {k: v for k, v in graph.items() if isinstance(v, Flow)}\n    nodes: dict[str, Node] = {k: v for k, v in graph.items() if isinstance(v, Node)}\n\n    node_to_commodity = get_node_to_commodity(graph)\n\n    # only nodes of prefered commodity\n    nodes_of_commodity: dict[str, Node] = {k: v for k, v in nodes.items() if v.get_commodity() == commodity}\n\n    # Mapping of node to category of prefered node level\n    node_to_category: dict[str, str] = {k: _get_meta_value(k, v, node_category) for k, v in nodes_of_commodity.items()}\n\n    category_to_nodes: dict[str, set[str]] = defaultdict(set)\n    visited = set()\n    for node_id, category in node_to_category.items():\n        assert node_id not in visited, f\"{node_id} is duplicated\"\n        category_to_nodes[category].add(node_id)\n        visited.add(node_id)\n\n    direct_production: dict[str, dict[str, list[Flow]]] = dict()\n    direct_consumption: dict[str, dict[str, list[Flow]]] = dict()\n    converted_production: dict[str, dict[str, list[Flow]]] = dict()\n    converted_consumption: dict[str, dict[str, list[Flow]]] = dict()\n    import_: dict[str, dict[str, list[Flow]]] = dict()\n    export: dict[str, dict[str, list[Flow]]] = dict()\n\n    for flow_id, flow in flows.items():\n        flow_infos = get_flow_infos(flow, node_to_commodity)\n\n        prod_category = None\n        cons_category = None\n        with contextlib.suppress(Exception):\n            prod_category = _get_meta_value(flow_id, flow, production_category)\n        with contextlib.suppress(Exception):\n            cons_category = _get_meta_value(flow_id, flow, consumption_category)\n\n        for flow_info in flow_infos:\n            flow_info: FlowInfo\n            if flow_info.category == \"direct_in\" and flow_info.commodity_in == commodity:\n                _check_category(prod_category, flow_id, flow_info)\n                node_category = node_to_category[flow_info.node_in]\n                if node_category not in direct_production:\n                    direct_production[node_category] = defaultdict(list)\n                direct_production[node_category][prod_category].append(flow)\n\n            elif flow_info.category == \"conversion\" and flow_info.commodity_in == commodity:\n                _check_category(prod_category, flow_id, flow_info)\n                node_category = node_to_category[flow_info.node_in]\n                if node_category not in converted_production:\n                    converted_production[node_category] = defaultdict(list)\n                converted_production[node_category][prod_category].append(flow)\n\n            elif flow_info.category == \"direct_out\" and flow_info.commodity_out == commodity:\n                _check_category(cons_category, flow_id, flow_info)\n                node_category = node_to_category[flow_info.node_out]\n                if node_category not in direct_consumption:\n                    direct_consumption[node_category] = defaultdict(list)\n                direct_consumption[node_category][cons_category].append(flow)\n\n            elif flow_info.category == \"conversion\" and flow_info.commodity_out == commodity:\n                _check_category(cons_category, flow_id, flow_info)\n                node_category = node_to_category[flow_info.node_out]\n                if node_category not in converted_consumption:\n                    converted_consumption[node_category] = defaultdict(list)\n                converted_consumption[node_category][cons_category].append(flow)\n\n            elif flow_info.category == \"transport\":\n                if node_to_commodity[flow_info.node_in] != commodity:\n                    continue\n                category_in = node_to_category[flow_info.node_in]\n                category_out = node_to_category[flow_info.node_out]\n                if category_in == category_out:\n                    continue\n\n                if category_in not in import_:\n                    import_[category_in] = defaultdict(list)\n                import_[category_in][category_out].append(flow)\n\n                if category_out not in export:\n                    export[category_out] = defaultdict(list)\n                export[category_out][category_in].append(flow)\n\n    num_periods = scenario_period.get_num_periods()\n    dtype = np.float32 if is_float32 else np.float64\n\n    out = RegionalVolumes()\n\n    # direct\n    for flow_dict, out_dict, is_ingoing in [(direct_production, out.get_production(), True), (direct_consumption, out.get_consumption(), False)]:\n        for node_category, flow_categories in flow_dict.items():\n            if node_category not in out_dict:\n                out_dict[node_category] = dict()\n            for flow_category, flows in flow_categories.items():\n                x = np.zeros(num_periods, dtype=dtype)\n                for flow in set(flows):\n                    try:\n                        vector = _get_vector(\n                            flow=flow,\n                            is_ingoing=is_ingoing,\n                            commodity=commodity,\n                            node_to_commodity=node_to_commodity,\n                            db=db,\n                            scenario_period=scenario_period,\n                            data_period=data_period,\n                            unit=unit,\n                            is_float32=is_float32,\n                        )\n                        np.add(x, vector, out=x)\n                    except Exception as e:\n                        send_warning_event(flow, f\"Could not get direct production or consumption for flow {flow}: {e}\")\n                out_dict[node_category][flow_category] = x\n\n    # converted\n    for flow_dict, out_dict, is_ingoing in [(converted_production, out.get_production(), True), (converted_consumption, out.get_consumption(), False)]:\n        for node_category, flow_categories in flow_dict.items():\n            if node_category not in out_dict:\n                out_dict[node_category] = dict()\n            for flow_category, flows in flow_categories.items():\n                x = out_dict[node_category][flow_category] if flow_category in out_dict[node_category] else np.zeros(num_periods, dtype=dtype)\n                for flow in set(flows):\n                    try:\n                        vector = _get_vector(\n                            flow=flow,\n                            is_ingoing=is_ingoing,\n                            commodity=commodity,\n                            node_to_commodity=node_to_commodity,\n                            db=db,\n                            scenario_period=scenario_period,\n                            data_period=data_period,\n                            unit=unit,\n                            is_float32=is_float32,\n                        )\n                        np.add(x, vector, out=x)\n                    except Exception as e:\n                        send_warning_event(flow, f\"Could not get indirect production or consumption for flow {flow}: {e}\")\n                out_dict[node_category][flow_category] = x\n\n    # trade\n    for flow_dict, out_dict, is_ingoing in [(import_, out.get_import(), True), (export, out.get_export(), False)]:\n        for category, trade_partners in flow_dict.items():\n            out_dict[category] = dict()\n            for trade_partner, flows in trade_partners.items():\n                x = np.zeros(num_periods, dtype=dtype)\n                for flow in set(flows):\n                    try:\n                        vector = _get_vector(\n                            flow=flow,\n                            is_ingoing=is_ingoing,\n                            commodity=commodity,\n                            node_to_commodity=node_to_commodity,\n                            db=db,\n                            scenario_period=scenario_period,\n                            data_period=data_period,\n                            unit=unit,\n                            is_float32=is_float32,\n                        )\n                        np.add(x, vector, out=x)\n                    except Exception as e:\n                        send_warning_event(flow, f\"Could not get trade for flow {flow}: {e}\")\n                out_dict[category][trade_partner] = x\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.get_supported_components","title":"<code>get_supported_components</code>","text":""},{"location":"reference/#framcore.utils.get_supported_components.get_supported_components","title":"<code>get_supported_components(components: dict[str, Component], supported_types: tuple[type[Component]], forbidden_types: tuple[type[Component]]) -&gt; dict[str, Component]</code>","text":"<p>Return simplified version of components in compliance with specified component types.See description in Component.</p> Source code in <code>framcore/utils/get_supported_components.py</code> <pre><code>def get_supported_components(\n    components: dict[str, Component],\n    supported_types: tuple[type[Component]],\n    forbidden_types: tuple[type[Component]],\n) -&gt; dict[str, Component]:\n    \"\"\"Return simplified version of components in compliance with specified component types.See description in Component.\"\"\"\n    output: dict[str, Component] = {}\n    errors: list[str] = []\n\n    _simplify_until_supported(\n        output,\n        errors,\n        components,\n        supported_types,\n        forbidden_types,\n    )\n\n    if errors:\n        message = \"\\n\".join(errors)\n        raise ValueError(message)\n\n    return output\n</code></pre>"},{"location":"reference/#framcore.utils.global_energy_equivalent","title":"<code>global_energy_equivalent</code>","text":""},{"location":"reference/#framcore.utils.global_energy_equivalent.get_hydro_downstream_energy_equivalent","title":"<code>get_hydro_downstream_energy_equivalent(data: dict[str, Component | TimeVector | Curve | Expr], module_name: str, power_node: str | None = None) -&gt; Expr</code>","text":"<p>Get the expression for the sum downstream energy equivalent for a hydro module.</p> <ul> <li>If power node is given, only count downstream energy equivalents that are connected to the power node.</li> <li>Energy equivalents are collected from hydro generators downstream, and the main topology follows the release_to attribute.</li> <li>Transport pumps are included in the downstream topology, but counted as negative energy equivalents.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Component | TimeVector | Curve | Expr]</code> <p>The dict containing the components.</p> required <code>module_name</code> <code>str</code> <p>The name of the hydro module to start from.</p> required <code>power_node</code> <code>str</code> <p>Optional power node to filter energy equivalents.</p> <code>None</code> Source code in <code>framcore/utils/global_energy_equivalent.py</code> <pre><code>def get_hydro_downstream_energy_equivalent(\n    data: dict[str, Component | TimeVector | Curve | Expr],\n    module_name: str,\n    power_node: str | None = None,\n) -&gt; Expr:\n    \"\"\"\n    Get the expression for the sum downstream energy equivalent for a hydro module.\n\n    - If power node is given, only count downstream energy equivalents that are connected to the power node.\n    - Energy equivalents are collected from hydro generators downstream, and the main topology follows the release_to attribute.\n    - Transport pumps are included in the downstream topology, but counted as negative energy equivalents.\n\n    Args:\n        data (dict[str, Component | TimeVector | Curve | Expr]): The dict containing the components.\n        module_name (str): The name of the hydro module to start from.\n        power_node (str): Optional power node to filter energy equivalents.\n\n    \"\"\"\n    if data[module_name].get_pump() and data[module_name].get_pump().get_from_module() == module_name:  # transport pump\n        pump_power_node = data[module_name].get_pump().get_power_node()\n        pump_to = data[module_name].get_pump().get_to_module()\n        energy_equivalent = get_hydro_downstream_energy_equivalent(data, pump_to, power_node)  # continue downstream of pump_to module\n        if power_node in (pump_power_node, None):\n            return energy_equivalent - data[module_name].get_pump().get_energy_equivalent().get_level()  # pumps has negative energy equivalents\n        return energy_equivalent\n\n    energy_equivalent = 0\n    if data[module_name].get_generator():  # hydro generator\n        module_power_node = data[module_name].get_generator().get_power_node()\n        if power_node in (module_power_node, None):\n            energy_equivalent += data[module_name].get_generator().get_energy_equivalent().get_level()\n    if data[module_name].get_release_to():  # continue from release_to module\n        release_to = data[module_name].get_release_to()\n        energy_equivalent += get_hydro_downstream_energy_equivalent(data, release_to, power_node)\n    return energy_equivalent\n</code></pre>"},{"location":"reference/#framcore.utils.global_energy_equivalent.set_global_energy_equivalent","title":"<code>set_global_energy_equivalent(data: dict[str, Component | TimeVector | Curve | Expr], metakey_energy_eq_downstream: str) -&gt; None</code>","text":"<p>Loop through data dict and set the downstream energy equivalent for all HydroModules.</p> <p>Send a warning event if a HydroModule has no downstream energy equivalents.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Component | TimeVector | Curve | Expr]</code> <p>The dict containing the components.</p> required <code>metakey_energy_eq_downstream</code> <code>str</code> <p>The meta key to use for storing the downstream energy equivalent.</p> required Source code in <code>framcore/utils/global_energy_equivalent.py</code> <pre><code>def set_global_energy_equivalent(data: dict[str, Component | TimeVector | Curve | Expr], metakey_energy_eq_downstream: str) -&gt; None:\n    \"\"\"\n    Loop through data dict and set the downstream energy equivalent for all HydroModules.\n\n    Send a warning event if a HydroModule has no downstream energy equivalents.\n\n    Args:\n        data (dict[str, Component | TimeVector | Curve | Expr]): The dict containing the components.\n        metakey_energy_eq_downstream (str): The meta key to use for storing the downstream energy equivalent.\n\n    \"\"\"\n    for module_name, module in data.items():\n        if isinstance(module, HydroModule) and module.get_reservoir():\n            energy_equivalent = get_hydro_downstream_energy_equivalent(data, module_name)\n            if energy_equivalent == 0:\n                message = f\"HydroModule {module_name} has no downstream energy equivalents.\"\n                module.send_warning_event(message)\n                energy_equivalent = ConstantTimeVector(scalar=0.0, unit=\"kWh/m3\", is_max_level=False)\n            module.add_meta(metakey_energy_eq_downstream, LevelExprMeta(energy_equivalent))\n</code></pre>"},{"location":"reference/#framcore.utils.isolate_subnodes","title":"<code>isolate_subnodes</code>","text":"<p>Demo to show how we can use the core to write some functions we need.</p>"},{"location":"reference/#framcore.utils.isolate_subnodes.isolate_subnodes","title":"<code>isolate_subnodes(model: Model, commodity: str, meta_key: str, members: list[str]) -&gt; None</code>","text":"<p>For components in model, delete all nodes of commodity except member nodes, and their flows and boundary nodes.</p> <ul> <li>Keep member nodes and all flows between them.</li> <li>Set boundary nodes exogenous and keep boundary flows into or out from member nodes.</li> <li>Delete all other nodes of commodity and all other flows pointing to them.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Model to modify</p> required <code>commodity</code> <code>str</code> <p>Commodity of nodes to consider</p> required <code>meta_key</code> <code>str</code> <p>Meta key to use to identify members</p> required <code>members</code> <code>List[str]</code> <p>List of meta key values identifying member nodes</p> required Source code in <code>framcore/utils/isolate_subnodes.py</code> <pre><code>def isolate_subnodes(model: Model, commodity: str, meta_key: str, members: list[str]) -&gt; None:  # noqa: PLR0915, C901\n    \"\"\"\n    For components in model, delete all nodes of commodity except member nodes, and their flows and boundary nodes.\n\n    - Keep member nodes and all flows between them.\n    - Set boundary nodes exogenous and keep boundary flows into or out from member nodes.\n    - Delete all other nodes of commodity and all other flows pointing to them.\n\n    Args:\n        model (Model): Model to modify\n        commodity (str): Commodity of nodes to consider\n        meta_key (str): Meta key to use to identify members\n        members (List[str]): List of meta key values identifying member nodes\n\n    \"\"\"\n    t = time()\n\n    data = model.get_data()\n    counts_before = model.get_content_counts()\n\n    has_not_converged = True\n    num_iterations = 0\n\n    while has_not_converged:\n        num_iterations += 1\n\n        n_data_before = len(data)\n\n        # We need copy of components to set _parent None so component becomes top_parent in upcoming code\n        components: dict[str, Component] = {k: copy(v) for k, v in data.items() if isinstance(v, Component)}\n        for c in components.values():\n            c: Component\n            c._parent = None  # noqa: SLF001\n\n        node_to_commodity = get_node_to_commodity(components)\n\n        parent_keys: dict[Component, str] = {v: k for k, v in components.items()}\n\n        graph: dict[str, Node | Flow] = get_supported_components(components, (Node, Flow), tuple())\n\n        parent_to_components = defaultdict(set)\n        for c in graph.values():\n            parent_to_components[c.get_top_parent()].add(c)\n\n        nodes: dict[str, Node] = {k: v for k, v in graph.items() if isinstance(v, Node)}\n        flows: dict[str, Flow] = {k: v for k, v in graph.items() if isinstance(v, Flow)}\n\n        commodity_nodes: dict[str, Node] = {k: v for k, v in nodes.items() if commodity == v.get_commodity()}\n        for k, v in commodity_nodes.items():\n            assert v.get_meta(meta_key), f\"missing meta_key {meta_key} node_id {k}\"\n\n        inside_nodes: dict[str, Node] = {k: v for k, v in commodity_nodes.items() if _is_member(v, meta_key, members)}\n\n        transports: dict[str, Flow] = {k: v for k, v in flows.items() if is_transport_by_commodity(v, node_to_commodity, commodity)}\n\n        boundary_flows: dict[str, Flow] = {k: v for k, v in transports.items() if _is_boundary_flow(v, inside_nodes.keys())}\n\n        boundary_nodes: dict[str, Node] = dict()\n        for flow_id, flow in boundary_flows.items():\n            for a in flow.get_arrows():\n                node_id = a.get_node()\n                if node_id not in inside_nodes:\n                    boundary_nodes[node_id] = nodes[node_id]\n\n        outside_nodes: dict[str, Node] = {k: v for k, v in commodity_nodes.items() if not (k in inside_nodes or k in boundary_nodes)}\n\n        deletes: set[str] = set()\n\n        deletes.update(outside_nodes.keys())\n        deletes.update(boundary_nodes.keys())  # will be kept in delete step below\n        deletes.update(boundary_flows.keys())  # will be kept in delete step below\n\n        # delete flows delivering to deleted node\n        for k, flow in flows.items():\n            for a in flow.get_arrows():\n                if a.get_node() in deletes:\n                    deletes.add(k)\n                    break  # goto next k, flow\n\n        # needed for next two steps\n        node_to_flows: dict[str, set[str]] = defaultdict(set)\n        flow_to_nodes: dict[str, set[str]] = defaultdict(set)\n        for flow_id, flow in flows.items():\n            for arrow in flow.get_arrows():\n                node_id = arrow.get_node()\n                node_to_flows[node_id].add(flow_id)\n                flow_to_nodes[flow_id].add(node_id)\n\n        # delete disconnected subgraphs\n        remaining = set(n for n in nodes if n not in commodity_nodes)\n        while remaining:\n            is_disconnected_subgraph = True\n            subgraph = set()\n            possible_members = set()\n            possible_members.add(remaining.pop())\n            while possible_members:\n                member = possible_members.pop()\n                if member in subgraph:  # avoid cycle\n                    continue\n                if member in flows:\n                    subgraph.add(member)\n                    for node in flow_to_nodes[member]:\n                        if node not in outside_nodes or node not in boundary_nodes:\n                            possible_members.add(node)\n                            if node in inside_nodes:\n                                is_disconnected_subgraph = False\n                else:\n                    subgraph.add(member)\n                    for flow in node_to_flows[member]:\n                        possible_members.add(flow)\n            if is_disconnected_subgraph:\n                deletes.update(subgraph)\n\n        for key in deletes:\n            if (key in boundary_flows) or (key in boundary_nodes):\n                continue\n\n            if key not in graph:\n                continue\n\n            parent_key = parent_keys[graph[key].get_top_parent()]\n\n            if parent_key in data:\n                del data[parent_key]\n\n        n_data_after = len(data)\n\n        if n_data_after == n_data_before:\n            has_not_converged = False\n\n    counts_after = model.get_content_counts()\n\n    added_components = counts_after[\"components\"] - counts_before[\"components\"]\n    if added_components.total() &gt; 0:\n        message = f\"Expected only deleted components. Got additions {added_components}\"\n        raise RuntimeError(message)\n\n    deleted_components = counts_before[\"components\"] - counts_after[\"components\"]\n\n    for node_id in boundary_nodes:\n        if node_id in data:\n            node: Node = data[node_id]\n            node.set_exogenous()\n            if not node.get_price().has_level():\n                message = f\"{node_id} set to be exogenous, but no price is available.\"\n                raise RuntimeError(message)\n\n    send_debug_event(isolate_subnodes, f\"Used {num_iterations} iterations and {round(time() - t, 2)} seconds and deleted {deleted_components}\")\n</code></pre>"},{"location":"reference/#framcore.utils.loaders","title":"<code>loaders</code>","text":""},{"location":"reference/#framcore.utils.loaders.add_loaders","title":"<code>add_loaders(loaders: set[Loader], model: Model) -&gt; None</code>","text":"<p>Add all loaders stored in Model to loaders set.</p> Source code in <code>framcore/utils/loaders.py</code> <pre><code>def add_loaders(loaders: set[Loader], model: Model) -&gt; None:\n    \"\"\"Add all loaders stored in Model to loaders set.\"\"\"\n    from framcore import Model\n    from framcore.components import Component, Flow, Node\n    from framcore.curves import Curve\n    from framcore.expressions import Expr\n    from framcore.timevectors import TimeVector\n    from framcore.utils import get_supported_components\n\n    _check_type(loaders, \"loaders\", set)\n    _check_type(model, \"model\", Model)\n\n    data = model.get_data()\n    components = dict()\n\n    for key, value in data.items():\n        if isinstance(value, Expr):\n            value.add_loaders(loaders)\n\n        elif isinstance(value, TimeVector | Curve):\n            loader = value.get_loader()\n            if loader is not None:\n                loaders.add(loader)\n\n        elif isinstance(value, Component):\n            components[key] = value\n\n    graph: dict[str, Flow | Node] = get_supported_components(components, (Flow, Node), tuple())\n\n    for c in graph.values():\n        c.add_loaders(loaders)\n</code></pre>"},{"location":"reference/#framcore.utils.loaders.add_loaders_if","title":"<code>add_loaders_if(loaders: set, value: object | None) -&gt; None</code>","text":"<p>Call value.add_loaders(loaders) if value is not None.</p> Source code in <code>framcore/utils/loaders.py</code> <pre><code>def add_loaders_if(loaders: set, value: object | None) -&gt; None:\n    \"\"\"Call value.add_loaders(loaders) if value is not None.\"\"\"\n    _check_type(loaders, \"loaders\", set)\n    if value is None:\n        return\n    value.add_loaders(loaders)\n</code></pre>"},{"location":"reference/#framcore.utils.loaders.replace_loader_path","title":"<code>replace_loader_path(loaders: set[Loader], old: Path, new: Path) -&gt; None</code>","text":"<p>Replace old path with new for all loaders using old path.</p> Source code in <code>framcore/utils/loaders.py</code> <pre><code>def replace_loader_path(loaders: set[Loader], old: Path, new: Path) -&gt; None:\n    \"\"\"Replace old path with new for all loaders using old path.\"\"\"\n    from framcore.loaders import FileLoader\n\n    _check_type(loaders, \"loaders\", set)\n\n    new = _check_path(new, \"new\", make_absolute=True)\n    old = _check_path(old, \"old\", error_if_not_absolute=True)\n\n    for loader in loaders:\n        try:\n            source = loader.get_source()\n        except Exception:\n            send_warning_event(f\"loader.get_source() failed for {loader}. Skipping this one.\")\n            continue\n\n        if isinstance(source, Path) and old in source.parents:\n            loader.set_source(new_source=new / source.relative_to(old))\n\n        if isinstance(loader, FileLoader) and not isinstance(source, Path):\n            send_warning_event(f\"FileLoader.get_source() does not return Path as it should for loader {loader}. Instead of Path, got {source}\")\n</code></pre>"},{"location":"reference/#framcore.utils.node_flow_utils","title":"<code>node_flow_utils</code>","text":""},{"location":"reference/#framcore.utils.node_flow_utils.FlowInfo","title":"<code>FlowInfo</code>","text":"<p>               Bases: <code>Base</code></p> <p>Holds info about one or two related Arrows of a Flow.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>class FlowInfo(Base):\n    \"\"\"Holds info about one or two related Arrows of a Flow.\"\"\"\n\n    def __init__(\n        self,\n        category: str,\n        node_out: str | None = None,\n        commodity_out: str | None = None,\n        node_in: str | None = None,\n        commodity_in: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Based on its arrows, we derive properties about a Flow.\n\n        We use this class to store such info.\n        \"\"\"\n        self.category = category\n        self.node_out = node_out\n        self.commodity_out = commodity_out\n        self.node_in = node_in\n        self.commodity_in = commodity_in\n</code></pre>"},{"location":"reference/#framcore.utils.node_flow_utils.FlowInfo.__init__","title":"<code>__init__(category: str, node_out: str | None = None, commodity_out: str | None = None, node_in: str | None = None, commodity_in: str | None = None) -&gt; None</code>","text":"<p>Based on its arrows, we derive properties about a Flow.</p> <p>We use this class to store such info.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def __init__(\n    self,\n    category: str,\n    node_out: str | None = None,\n    commodity_out: str | None = None,\n    node_in: str | None = None,\n    commodity_in: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Based on its arrows, we derive properties about a Flow.\n\n    We use this class to store such info.\n    \"\"\"\n    self.category = category\n    self.node_out = node_out\n    self.commodity_out = commodity_out\n    self.node_in = node_in\n    self.commodity_in = commodity_in\n</code></pre>"},{"location":"reference/#framcore.utils.node_flow_utils.get_component_to_nodes","title":"<code>get_component_to_nodes(data: Model | dict[str, object]) -&gt; dict[str, set[str]]</code>","text":"<p>For each str key in data where value is a Component find all Node id str in data directly connected to the Component.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_component_to_nodes(data: Model | dict[str, object]) -&gt; dict[str, set[str]]:\n    \"\"\"For each str key in data where value is a Component find all Node id str in data directly connected to the Component.\"\"\"\n    from framcore import Model\n\n    _check_type(data, Model | dict)\n\n    if isinstance(data, Model):\n        data = data.get_data()\n\n    components = {k: v for k, v in data.items() if isinstance(v, Component)}\n    for k in components:\n        assert isinstance(k, str), f\"Got invalid key {k}\"\n\n    g = get_supported_components(components, (Node, Flow), tuple())\n\n    nodes = {k: v for k, v in g.items() if isinstance(v, Node)}\n    flows = {k: v for k, v in g.items() if isinstance(v, Flow)}\n\n    domain_nodes = {k: v for k, v in nodes.items() if (k in components) and isinstance(v, Node)}\n    assert all(isinstance(v, Node) for v in domain_nodes.values())\n\n    parent_keys = {v: k for k, v in components.items()}\n\n    out = defaultdict(set)\n    for flow in flows.values():\n        parent_key = parent_keys[flow.get_top_parent()]\n        for a in flow.get_arrows():\n            node_id = a.get_node()\n            if node_id in domain_nodes:\n                out[parent_key].add(node_id)\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.node_flow_utils.get_flow_infos","title":"<code>get_flow_infos(flow: Flow, node_to_commodity: dict[str, str]) -&gt; list[FlowInfo]</code>","text":"<p>Get flow infos from analysis of all its arrows.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_flow_infos(flow: Flow, node_to_commodity: dict[str, str]) -&gt; list[FlowInfo]:  # noqa: C901\n    \"\"\"Get flow infos from analysis of all its arrows.\"\"\"\n    _check_type(flow, Flow)\n    _check_type(node_to_commodity, dict)\n\n    arrows = flow.get_arrows()\n\n    if len(arrows) == 1:\n        arrow = next(iter(arrows))\n        node_id = arrow.get_node()\n\n        if node_id not in node_to_commodity:\n            message = f\"node_id {node_id} missing from node_to_commodity for flow\\n{flow}\"\n            raise RuntimeError(message)\n\n        commodity = node_to_commodity[node_id]\n        if arrow.is_ingoing():\n            info = FlowInfo(\n                \"direct_in\",\n                node_in=node_id,\n                commodity_in=commodity,\n            )\n        else:\n            info = FlowInfo(\n                \"direct_out\",\n                node_out=node_id,\n                commodity_out=commodity,\n            )\n        return [info]\n\n    seen: set[tuple[str, str]] = set()\n    infos: list[FlowInfo] = []\n    for x in arrows:\n        for y in arrows:\n            if x is y:\n                continue\n\n            if x.is_ingoing() != y.is_ingoing():\n                arrow_in = x if x.is_ingoing() else y\n                arrow_out = x if y.is_ingoing() else y\n\n                node_in = arrow_in.get_node()\n                node_out = arrow_out.get_node()\n\n                if node_in not in node_to_commodity:\n                    message = f\"node_in {node_in} missing from node_to_commodity for flow\\n{flow}\"\n                    raise RuntimeError(message)\n\n                if node_out not in node_to_commodity:\n                    message = f\"node_out {node_out} missing from node_to_commodity for flow\\n{flow}\"\n                    raise RuntimeError(message)\n\n                commodity_in = node_to_commodity[node_in]\n                commodity_out = node_to_commodity[node_out]\n\n                info = FlowInfo(\n                    category=\"transport\" if commodity_in == commodity_out else \"conversion\",\n                    node_in=node_in,\n                    commodity_in=commodity_in,\n                    node_out=node_out,\n                    commodity_out=commodity_out,\n                )\n                key = (node_in, node_out)\n                if key in seen:\n                    continue\n\n                infos.append(info)\n                seen.add(key)\n\n    for arrow in arrows:\n        node = arrow.get_node()\n        if any(node in [info.node_in, info.node_out] for info in infos):\n            continue\n        node_id = arrow.get_node()\n        commodity = node_to_commodity[node_id]\n        if arrow.is_ingoing():\n            info = FlowInfo(\n                \"direct_in\",\n                node_in=node_id,\n                commodity_in=commodity,\n            )\n        else:\n            info = FlowInfo(\n                \"direct_out\",\n                node_out=node_id,\n                commodity_out=commodity,\n            )\n        infos.append(info)\n\n    return infos\n</code></pre>"},{"location":"reference/#framcore.utils.node_flow_utils.get_node_to_commodity","title":"<code>get_node_to_commodity(data: dict[str, object]) -&gt; dict[str, str]</code>","text":"<p>Return dict with commodity (str) for each node id (str) in data.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_node_to_commodity(data: dict[str, object]) -&gt; dict[str, str]:\n    \"\"\"Return dict with commodity (str) for each node id (str) in data.\"\"\"\n    _check_type(data, dict)\n\n    components = {k: v for k, v in data.items() if isinstance(v, Component)}\n    for k in components:\n        assert isinstance(k, str), f\"Got invalid key {k}\"\n\n    g = get_supported_components(components, (Node, Flow), tuple())\n\n    out = dict()\n    for k, v in g.items():\n        if isinstance(v, Node):\n            _check_type(k, str)\n            out[k] = v.get_commodity()\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.node_flow_utils.get_transports_by_commodity","title":"<code>get_transports_by_commodity(data: Model | dict[str, object], commodity: str) -&gt; dict[str, tuple[str, str]]</code>","text":"<p>Return dict with key component_id and value (from_node_id, to_node_id) where both nodes belong to given commodity.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def get_transports_by_commodity(data: Model | dict[str, object], commodity: str) -&gt; dict[str, tuple[str, str]]:\n    \"\"\"Return dict with key component_id and value (from_node_id, to_node_id) where both nodes belong to given commodity.\"\"\"\n    from framcore import Model\n\n    _check_type(data, Model | dict)\n    _check_type(commodity, str)\n\n    if isinstance(data, Model):\n        data = data.get_data()\n\n    components = {k: v for k, v in data.items() if isinstance(v, Component)}\n    for k in components:\n        assert isinstance(k, str), f\"Got invalid key {k}\"\n\n    node_to_commodity = get_node_to_commodity(components)\n\n    g = get_supported_components(components, (Node, Flow), tuple())\n\n    flows = {k: v for k, v in g.items() if isinstance(v, Flow)}\n\n    parent_keys = {v: k for k, v in components.items()}\n\n    out = dict()\n    for flow in flows.values():\n        parent_key = parent_keys[flow.get_top_parent()]\n        infos = get_flow_infos(flow, node_to_commodity)\n        if len(infos) != 1:\n            continue\n        info = infos[0]\n        if info.category != \"transport\":\n            continue\n        if info.commodity_in != commodity:\n            continue\n        out[parent_key] = (info.node_out, info.node_in)\n\n    return out\n</code></pre>"},{"location":"reference/#framcore.utils.node_flow_utils.is_transport_by_commodity","title":"<code>is_transport_by_commodity(flow: Flow, node_to_commodity: dict[str, str], commodity: str) -&gt; bool</code>","text":"<p>Return True if flow is a transport of the given commodity.</p> Source code in <code>framcore/utils/node_flow_utils.py</code> <pre><code>def is_transport_by_commodity(flow: Flow, node_to_commodity: dict[str, str], commodity: str) -&gt; bool:\n    \"\"\"Return True if flow is a transport of the given commodity.\"\"\"\n    _check_type(flow, Flow)\n    _check_type(node_to_commodity, dict)\n    arrows = flow.get_arrows()\n    try:\n        x, y = tuple(arrows)\n        opposite_directions = x.is_ingoing() != y.is_ingoing()\n        x_commodity = node_to_commodity[x.get_node()]\n        y_commodity = node_to_commodity[y.get_node()]\n        correct_commodity = x_commodity == y_commodity == commodity\n        return opposite_directions and correct_commodity\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/#framcore.utils.storage_subsystems","title":"<code>storage_subsystems</code>","text":""},{"location":"reference/#framcore.utils.storage_subsystems.get_one_commodity_storage_subsystems","title":"<code>get_one_commodity_storage_subsystems(graph: dict[str, Node | Flow], include_boundaries: bool) -&gt; dict[str, tuple[str, set[str], set[str]]]</code>","text":"<p>Group all storage subsystems belonging to same commodity.</p> <p>Returns dict[subsystem_id, (domain_commodity, member_component_ids, boundary_domain_commodities)]</p> <p>The boundary_domain_commodities of the output is a set of boundary commodities. Some algorithms can only handle one boundary commodity, so this output is useful to verify that those conditions apply, and to derive conversion factor unit, which need both storage_commodity unit and boundray_commodity unit.</p> <p>If include_boundaries is False only nodes with same commodity as storage_node will be included in the subsystem.</p> Source code in <code>framcore/utils/storage_subsystems.py</code> <pre><code>def get_one_commodity_storage_subsystems(  # noqa: C901\n    graph: dict[str, Node | Flow],\n    include_boundaries: bool,\n) -&gt; dict[str, tuple[str, set[str], set[str]]]:\n    \"\"\"\n    Group all storage subsystems belonging to same commodity.\n\n    Returns dict[subsystem_id, (domain_commodity, member_component_ids, boundary_domain_commodities)]\n\n    The boundary_domain_commodities of the output is a set of boundary commodities.\n    Some algorithms can only handle one boundary commodity, so this output is useful\n    to verify that those conditions apply, and to derive conversion factor unit,\n    which need both storage_commodity unit and boundray_commodity unit.\n\n    If include_boundaries is False only nodes with same commodity as storage_node will\n    be included in the subsystem.\n    \"\"\"\n    if not all(isinstance(c, Flow | Node) for c in graph.values()):\n        invalid = {k: v for k, v in graph.items() if not isinstance(v, Flow | Node)}\n        message = f\"All values in graph must be Flow or Node objects. Found invalid objects: {invalid}\"\n        raise ValueError(message)\n\n    flows: dict[str, Flow] = {k: v for k, v in graph.items() if isinstance(v, Flow)}\n    nodes: dict[str, Node] = {k: v for k, v in graph.items() if isinstance(v, Node)}\n\n    storage_nodes: dict[str, Node] = {k: v for k, v in nodes.items() if v.get_storage()}\n\n    node_to_flows: dict[str, set[str]] = defaultdict(set)\n    flow_to_nodes: dict[str, set[str]] = defaultdict(set)\n    for flow_id, flow in flows.items():\n        for arrow in flow.get_arrows():\n            node_id = arrow.get_node()\n            node_to_flows[node_id].add(flow_id)\n            flow_to_nodes[flow_id].add(node_id)\n\n    out = dict()\n    allocated: set[str] = set()\n    for storage_node_id, storage_node in storage_nodes.items():\n        if storage_node_id in allocated:\n            continue\n\n        subsystem_id = storage_node_id\n        storage_commodity = storage_node.get_commodity()\n\n        member_component_ids: set[str] = set()\n        boundary_commodities: set[str] = set()\n\n        visited: set[str] = set()\n        remaining: set[str] = set()\n\n        remaining.add(storage_node_id)\n\n        while remaining:\n            component_id = remaining.pop()\n            if component_id in visited:\n                continue\n\n            visited.add(component_id)\n\n            if component_id in nodes:\n                node: Node = nodes[component_id]\n                node_commodity = node.get_commodity()\n\n                if node_commodity == storage_commodity:\n                    allocated.add(component_id)\n                    remaining.update(node_to_flows.get(component_id, set()))\n                else:\n                    boundary_commodities.add(node_commodity)\n\n                if include_boundaries or node_commodity == storage_commodity:\n                    member_component_ids.add(component_id)\n\n            else:\n                remaining.update(flow_to_nodes.get(component_id, set()))\n                member_component_ids.add(component_id)\n\n        out[subsystem_id] = (storage_commodity, member_component_ids, boundary_commodities)\n\n    return out\n</code></pre>"},{"location":"tech_details/","title":"Macro Rendering Error","text":"<p>File: <code>tech_details.md</code></p> <p>UndefinedError: 'HL' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/home/runner/work/fram-core/fram-core/.venv/lib/python3.12/site-packages/mkdocs_macros/plugin.py\", line 703, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/work/fram-core/fram-core/.venv/lib/python3.12/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/home/runner/work/fram-core/fram-core/.venv/lib/python3.12/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 28, in top-level template code\njinja2.exceptions.UndefinedError: 'HL' is undefined\n\n</code></pre>"}]}